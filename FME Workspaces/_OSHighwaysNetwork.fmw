#! <?xml version="1.0" encoding="UTF-8" ?>
#! <WORKSPACE
#    Command-line to run this workspace:
#        "C:\Program Files\FME\fme.exe" "C:\OSMM_Highways\Software - OS HighwaysNetwork Translator\FMEworkspaces\_OSHighwaysNetwork.fmw"
#              --MASTER_FILES ""
#              --ROADS_INPUT ""
#              --PATHS_INPUT ""
#              --DEST_FOLDER ""
#    
#!   ATTR_TYPE_ENCODING="SDF"
#!   BEGIN_PYTHON=""
#!   BEGIN_TCL=""
#!   CATEGORY=""
#!   DESCRIPTION=""
#!   DESTINATION="NONE"
#!   DESTINATION_ROUTING_FILE=""
#!   DOC_EXTENTS="2862.49 2458.6"
#!   DOC_TOP_LEFT="30.2711 -2363.66"
#!   END_PYTHON=""
#!   END_TCL=""
#!   EXPLICIT_BOOKMARK_ORDER="false"
#!   FME_BUILD_NUM="18547"
#!   FME_DOCUMENT_GUID="229f887d-2780-4e51-a7ac-1017e12c69c9"
#!   FME_DOCUMENT_PRIORGUID="5983ef5f-61ec-409e-87b3-2056d3e5d616,c0a90da5-7580-4166-906b-e11686e64908,6300878c-1d04-4da9-b84d-bd5d5a9fa1e8,1b8553ae-85ae-45ed-93c1-9bfaf8c50213,bd2fe7f2-89f1-48a3-94a2-6e875b7a870c,2ed32e18-4ca8-428c-a965-364d47512d5b,b8586ce0-e25d-4c67-af57-5fb472e51eaa,5ee76c10-513b-49b3-b7ba-d8bb27b11dea,9d4bb918-9480-42f9-bfd2-8aae454ee511,d155a7f9-a62e-40f5-87be-d3ef9b68e5fc,1ff2e8dd-bbd1-4d82-b36f-e6e4e0bf61da,8ca97492-0842-42be-bf50-fd2a4199e25e,84ad0891-11b5-4ea9-b851-4e211d4ca891,edda837d-689c-4d86-a8ea-c357e5136c1e,4eed2e67-b607-4a63-8fc8-52e579166df2,dfacf3f3-d54f-42a7-9a92-16914a7eabc3,61c2d1f5-330d-40df-b17e-f6a220676d08,e3f53cf9-373e-4a26-9212-bb4c8ab9a24b,5e092afb-9d02-4189-bca3-c66a3e8a3ad3,d440c0b8-fa56-4466-b662-9c177180b960,bd4ea97f-a60d-40cc-8912-da4400df2133,4fc1ef72-f3dd-4327-bb94-4f3ae16f9293,9df0fc31-1bc3-428e-9440-5e6f49ac88f8,1e872a6d-c987-4200-b5a6-886139f3503b,58c26fa9-a60c-4246-b760-08f99b898afa,e63ad74a-2cf1-4e04-9c24-64a77f4771c0,6bec160e-5532-4dc3-a324-85cd621a4cf8,001ee7d8-9dac-449a-bf1f-6cb4c903d275,395545b5-b7ca-4277-9f28-d94517beeefd,375e3049-7412-4e94-8e75-61edc125a1cc,ed6a9b8c-0250-4b3f-9ae4-19d9f3e885d6,fd59f97d-0596-427a-b383-b61e7735645b,e52d0c2c-dc29-4d47-b1a1-89701537ae56,c07c0fdc-fe2c-4788-9b18-045427f7a1df,ddcfdd80-c28c-4bb5-9c48-76afdbdf3f5c,ad4bccd4-262a-4031-8303-9f417855a141,6bfacabe-7dd0-4bbb-ba7e-e049d219330f,8d289c86-5f2e-4810-bf96-f758a85323c7,b933ffb3-d7f0-4a84-9e28-bebd7260bd34,2782f6b9-d81c-49b9-81b4-da36a838c6d8,3a8b3660-6853-4872-b6f8-4d346b306e07,db15f0d5-9974-4441-9ec0-0f988b455d49,d1791ac9-3731-44db-ba8b-db86d4668f1b,b42dd854-a495-4412-812c-16f346f31bc5,212b4bba-498f-4acc-b2b1-5b748262800a,a1954db3-5e1d-4868-842a-b9a1b3fff094,1f8ab15e-6f56-4781-812e-9b1373797220,c5dc0710-75d9-498b-a996-3299cc4f0fc3,fe1765b7-2afd-4070-9d59-91ed77e75062,da99e616-678a-4b5e-a03e-8001d05eacd7,78a2a066-8470-41ff-a263-87297e3ca93d,4f940b72-9daf-4473-a3b2-960ebd0f1756,e6eec5af-5e89-4dac-b364-7ffe4ce43c6f,f21fab84-98d2-4da3-b9a0-39e59275b418,34e934e5-ac2c-4cff-9f33-6babe7c17918,d038a4bc-655e-440a-9802-4cfb0d81fa04,a78875b8-84a5-4a05-9eed-3229dc5233a2,9d46ab3b-fd0e-4d61-8f45-be4606ec3fe0,1aaf1c88-6a6d-4d7c-adf9-29c1abce69b5,8d384892-4a6e-41ea-81d4-cb6fdecfc9bd,0fd44f41-d8e1-44ce-a31f-e8a299e50ae7,5724dc7e-2a79-4323-9b3a-1fc0533d0416,1baac979-78c0-483c-b133-2be7b3c21b6a,7db0bb6b-8632-45bf-9da7-d9390c483403,39b2aa4a-b7ee-472a-8691-5ef4db833077,c3c2dd74-62ef-4df8-90e5-80f101508807,ec2680c8-fdbb-4bb6-8447-6daeb14279c0,6e19b092-58ff-4e85-bd8b-99aa3216e2f0,ad1670ab-58a9-40c6-b326-7343112e2172,eff61066-e98b-4119-adf0-8002d7bc765e,1c6d8bc5-4e05-4ca1-9f72-d70e3a1b5a6f,d01da4b6-50a3-4d89-9c88-a4540e6c2028,88ee8bf3-3068-472e-8097-04432d61eed7,fdb9cb79-b6a7-4601-ad6d-a0f004ad9fd7,42f82676-1799-4432-aeb5-4147705b682d,c88c305c-942d-459f-a2bb-765f71e3a938,e491c006-c30c-48dd-bd42-48cc019eeab8,325caf31-a22d-41fa-a011-91508e618d02,4ba7d08e-8273-46c7-b8bc-2c6ae20d2aaf,84646d77-09da-4adb-968a-adf0851720e2,7562e21b-b39e-4454-8347-3060daeae063,4d198bcc-2756-4744-8f0b-769827c0b7e5,917adca8-4637-4e82-bb4a-38e1a91d341d,58d0669c-421c-4bcf-958e-4833093d76aa,1f73aca7-3e59-48ed-9e41-d39b1467ed65,7f4ee798-e88d-4dde-8ce5-ae8b71c49071,2fad8309-d4e5-4fcb-8cd3-de8346281134,2516e877-7def-4b17-9c4b-485fc7bfed22,71b360c6-14d8-42f8-8dff-de4f5267445b,a4c3189e-5f38-43c4-b703-bfdb8adc7216"
#!   FME_GEOMETRY_HANDLING="Enhanced"
#!   FME_IMPLICIT_CSMAP_REPROJECTION_MODE="Auto"
#!   FME_REPROJECTION_ENGINE="FME"
#!   FME_SERVER_SERVICES=""
#!   FME_STROKE_MAX_DEVIATION="0"
#!   HISTORY=""
#!   IGNORE_READER_FAILURE="No"
#!   LAST_SAVE_BUILD="FME(R) 2018.1.0.2 (20180903 - Build 18547 - WIN64)"
#!   LAST_SAVE_DATE="2019-01-18T11:35:05"
#!   LOG_FILE=""
#!   LOG_MAX_RECORDED_FEATURES="200"
#!   MARKDOWN_DESCRIPTION=""
#!   MARKDOWN_USAGE=""
#!   MAX_LOG_FEATURES="200"
#!   MULTI_WRITER_DATASET_ORDER="BY_ID"
#!   PASSWORD=""
#!   PYTHON_COMPATIBILITY="27"
#!   REDIRECT_TERMINATORS="NONE"
#!   SHOW_ANNOTATIONS="true"
#!   SHOW_INFO_NODES="true"
#!   SOURCE="NONE"
#!   SOURCE_ROUTING_FILE=""
#!   TERMINATE_REJECTED="NO"
#!   TITLE=""
#!   USAGE=""
#!   USE_MARKDOWN=""
#!   VIEW_POSITION="71.0234 153.411"
#!   WARN_INVALID_XFORM_PARAM="Yes"
#!   WORKSPACE_VERSION="1"
#!   ZOOM_SCALE="110"
#! >
#! <DATASETS>
#! </DATASETS>
#! <DATA_TYPES>
#! </DATA_TYPES>
#! <GEOM_TYPES>
#! </GEOM_TYPES>
#! <FEATURE_TYPES>
#! </FEATURE_TYPES>
#! <FMESERVER>
#! </FMESERVER>
#! <GLOBAL_PARAMETERS>
#! <GLOBAL_PARAMETER
#!   GUI_LINE="GUI OPTIONAL DIRNAME_SRC_OR_ATTR MASTER_FILES Supplied folder called EmptyMasterFiles:"
#!   DEFAULT_VALUE=""
#!   IS_STAND_ALONE="true"
#! />
#! <GLOBAL_PARAMETER
#!   GUI_LINE="GUI OPTIONAL DIRNAME_SRC_OR_ATTR ROADS_INPUT Folder containing Rrami*.gz raw data files:"
#!   DEFAULT_VALUE=""
#!   IS_STAND_ALONE="true"
#! />
#! <GLOBAL_PARAMETER
#!   GUI_LINE="GUI OPTIONAL DIRNAME_SRC_OR_ATTR PATHS_INPUT Folder containing Paths*.gz raw data files:"
#!   DEFAULT_VALUE=""
#!   IS_STAND_ALONE="true"
#! />
#! <GLOBAL_PARAMETER
#!   GUI_LINE="GUI OPTIONAL DIRNAME_OR_ATTR DEST_FOLDER Destination folder to contain all output files:"
#!   DEFAULT_VALUE=""
#!   IS_STAND_ALONE="true"
#! />
#! </GLOBAL_PARAMETERS>
#! <COMMENTS>
#! <COMMENT
#!   IDENTIFIER="76"
#!   COMMENT_VALUE="&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.0//EN&quot; &quot;http://www.w3.org/TR/REC-html40/strict.dtd&quot;&gt;&#10;&lt;html&gt;&lt;head&gt;&lt;meta name=&quot;qrichtext&quot; content=&quot;1&quot; /&gt;&lt;style type=&quot;text/css&quot;&gt;&#10;p, li { white-space: pre-wrap; }&#10;&lt;/style&gt;&lt;/head&gt;&lt;body style=&quot; font-family:&apos;MS Shell Dlg 2&apos;; font-size:9pt; font-weight:400; font-style:normal;&quot;&gt;&#10;&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;Other FME workspaces will be run in turn to complete the translation.&lt;/p&gt;&#10;&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;&#10;&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;All the workspaces to be run must be in the same folder as this one.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;"
#!   POSITION="932.64779192791934 -261.83102751642076"
#!   TOP_LEFT="932.64779192791934 -261.83102751642076"
#!   BOTTOM_RIGHT="1625.3627919279193 -404.33202751642079"
#!   BOUNDING_RECT="932.64779192791934 -261.83102751642076 692.71500000000003 142.501"
#!   ORDER="500000000000000"
#!   FOLLOW_ANCHOR="true"
#!   INFO_NODE="false"
#!   COLOUR="1,0.33333333333333331,0.49803921568627452,0.19215686274509805"
#!   SIZE_POLICY="10"
#!   ANCHORED_NODE="0"
#! />
#! <COMMENT
#!   IDENTIFIER="98"
#!   COMMENT_VALUE="&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.0//EN&quot; &quot;http://www.w3.org/TR/REC-html40/strict.dtd&quot;&gt;&#10;&lt;html&gt;&lt;head&gt;&lt;meta name=&quot;qrichtext&quot; content=&quot;1&quot; /&gt;&lt;style type=&quot;text/css&quot;&gt;&#10;p, li { white-space: pre-wrap; }&#10;&lt;/style&gt;&lt;/head&gt;&lt;body style=&quot; font-family:&apos;MS Shell Dlg 2&apos;; font-size:9pt; font-weight:400; font-style:normal;&quot;&gt;&#10;&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;Just run this FME workspace to complete the entire translation.&lt;/p&gt;&#10;&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;&#10;&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;This may take some time, but may simply be left running unattended.&lt;/p&gt;&#10;&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;&#10;&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;When starting, choose your folders using the Translation Parameters.&lt;/p&gt;&#10;&lt;p style=&quot;-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;br /&gt;&lt;/p&gt;&#10;&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;Ignore any warnings of &apos;failure&apos; for  feature types not in your data set.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;"
#!   POSITION="104.27106250426095 0.67159750982960986"
#!   TOP_LEFT="104.27106250426095 0.67159750982960986"
#!   BOTTOM_RIGHT="796.98606250426099 -141.82940249017039"
#!   BOUNDING_RECT="104.27106250426095 0.67159750982960986 692.71500000000003 142.501"
#!   ORDER="500000000000000"
#!   FOLLOW_ANCHOR="true"
#!   INFO_NODE="false"
#!   COLOUR="0,0.66666666666666663,1,0.19215686274509805"
#!   SIZE_POLICY="10"
#!   ANCHORED_NODE="0"
#! />
#! </COMMENTS>
#! <CONSTANTS>
#! </CONSTANTS>
#! <BOOKMARKS>
#! <BOOKMARK
#!   IDENTIFIER="124"
#!   NAME="Create GPKG files, using workspaces derived from OS OpenSource files, with added value from miso"
#!   DESCRIPTION="&lt;html&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;"
#!   TOP_LEFT="30.271062504260954 -608.4729375502842"
#!   ORDER="500000000000142"
#!   BOTTOM_RIGHT="2892.7606625042617 -2363.6600002363652"
#!   BOUNDING_RECT="30.271062504260954 -608.4729375502842 2862.4896000000008 1755.1870626860809"
#!   STICKY="true"
#!   COLOUR="0.77254901960784317,0.792156862745098,0.38823529411764707"
#!   CONTENTS="46 86 53 60 31 47 8 80 71 4 49 52 22 91 96 55 11 51 10 27 82 59 78 25 18 93 90 74 37 75 36 56 68 44 7 131 70 30 6 48 24 3 72 135 35 87 50 132 95 29 32 19 5 33 21 62 38 9 34 94 23 20 83 57 26 77 12 133 54 134 88 61 58 "
#! >
#! </BOOKMARK>
#! <BOOKMARK
#!   IDENTIFIER="97"
#!   NAME="Initial copying of required files"
#!   DESCRIPTION="&lt;html&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;"
#!   TOP_LEFT="31.250312503126679 94.942972496306837"
#!   ORDER="500000000000214"
#!   BOTTOM_RIGHT="2892.7606625042617 -573.86937505738683"
#!   BOUNDING_RECT="31.250312503126679 94.942972496306837 2861.5103500011351 668.81234755369371"
#!   STICKY="true"
#!   COLOUR="0.34901960784313724,0.27450980392156865,0.13333333333333333"
#!   CONTENTS="81 89 152 76 98 79 85 2 84 "
#! >
#! </BOOKMARK>
#! </BOOKMARKS>
#! <TRANSFORMERS>
#! <TRANSFORMER
#!   IDENTIFIER="2"
#!   TYPE="Creator"
#!   VERSION="5"
#!   POSITION="1098.3097749892065 -33.557027503693178"
#!   BOUNDING_RECT="1098.3097749892065 -33.557027503693178 -1 -1"
#!   ORDER="500000000000000"
#!   PARMS_EDITED="true"
#!   ENABLED="true"
#!   LAST_PARM_EDIT="18547"
#! >
#!     <OUTPUT_FEAT NAME="CREATED"/>
#!     <FEAT_COLLAPSED COLLAPSED="0"/>
#!     <XFORM_PARM PARM_NAME="ATEND" PARM_VALUE="no"/>
#!     <XFORM_PARM PARM_NAME="COORDS" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="COORDSYS" PARM_VALUE="OSGB-GPS-2015"/>
#!     <XFORM_PARM PARM_NAME="CRE_ATTR" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="GEOM" PARM_VALUE="&lt;lt&gt;?xml&lt;space&gt;version=&lt;quote&gt;1.0&lt;quote&gt;&lt;space&gt;encoding=&lt;quote&gt;US_ASCII&lt;quote&gt;&lt;space&gt;standalone=&lt;quote&gt;no&lt;quote&gt;&lt;space&gt;?&lt;gt&gt;&lt;lt&gt;geometry&lt;gt&gt;&lt;lt&gt;point&lt;gt&gt;&lt;lt&gt;coord&lt;space&gt;x=&lt;quote&gt;0&lt;quote&gt;&lt;space&gt;y=&lt;quote&gt;0&lt;quote&gt;&lt;solidus&gt;&lt;gt&gt;&lt;lt&gt;&lt;solidus&gt;point&lt;gt&gt;&lt;lt&gt;&lt;solidus&gt;geometry&lt;gt&gt;"/>
#!     <XFORM_PARM PARM_NAME="GEOMTYPE" PARM_VALUE="Geometry Object"/>
#!     <XFORM_PARM PARM_NAME="NUM" PARM_VALUE="1"/>
#!     <XFORM_PARM PARM_NAME="PARAMETERS_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="TRANSFORMER_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="XFORMER_NAME" PARM_VALUE="Creator"/>
#! </TRANSFORMER>
#! <TRANSFORMER
#!   IDENTIFIER="3"
#!   TYPE="WorkspaceRunner"
#!   VERSION="2"
#!   POSITION="104.27106250426095 -1059.1019375502838"
#!   BOUNDING_RECT="104.27106250426095 -1059.1019375502838 -1 -1"
#!   ORDER="500000000000000"
#!   PARMS_EDITED="true"
#!   ENABLED="true"
#!   LAST_PARM_EDIT="18547"
#! >
#!     <OUTPUT_FEAT NAME="SUCCEEDED"/>
#!     <FEAT_COLLAPSED COLLAPSED="0"/>
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.count" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.name" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_dataset" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_total_features_written" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_failure_message" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <OUTPUT_FEAT NAME="FAILED"/>
#!     <FEAT_COLLAPSED COLLAPSED="1"/>
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.count" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.name" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_dataset" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_total_features_written" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_failure_message" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <OUTPUT_FEAT NAME="SUMMARY"/>
#!     <FEAT_COLLAPSED COLLAPSED="2"/>
#!     <XFORM_ATTR ATTR_NAME="_proc_count" IS_USER_CREATED="false" FEAT_INDEX="2" />
#!     <XFORM_ATTR ATTR_NAME="_processes{}" IS_USER_CREATED="false" FEAT_INDEX="2" />
#!     <XFORM_PARM PARM_NAME="BLOCKING" PARM_VALUE="Yes"/>
#!     <XFORM_PARM PARM_NAME="MAX_PROC" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="PARAMETERS_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="PARAMETER_TYPES" PARM_VALUE="MULTIFILE,FILENAME"/>
#!     <XFORM_PARM PARM_NAME="TRANSFORMER_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="WORKSPACE_FILE" PARM_VALUE="PathLink.fmw"/>
#!     <XFORM_PARM PARM_NAME="WORKSPACE_PARAMETERS" PARM_VALUE="SourceDataset_GML,$(PATHS_INPUT)&lt;backslash&gt;Highways_Paths_PathLink_*.gml.gz,DestDataset_GEOPACKAGE,$(DEST_FOLDER)&lt;backslash&gt;PathLink.gpkg"/>
#!     <XFORM_PARM PARM_NAME="XFORMER_NAME" PARM_VALUE="PathLink"/>
#! </TRANSFORMER>
#! <TRANSFORMER
#!   IDENTIFIER="4"
#!   TYPE="WorkspaceRunner"
#!   VERSION="2"
#!   POSITION="104.27106250426095 -1402.8549375502839"
#!   BOUNDING_RECT="104.27106250426095 -1402.8549375502839 -1 -1"
#!   ORDER="500000000000000"
#!   PARMS_EDITED="true"
#!   ENABLED="true"
#!   LAST_PARM_EDIT="18547"
#! >
#!     <OUTPUT_FEAT NAME="SUCCEEDED"/>
#!     <FEAT_COLLAPSED COLLAPSED="0"/>
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.count" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.name" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_dataset" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_total_features_written" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_failure_message" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <OUTPUT_FEAT NAME="FAILED"/>
#!     <FEAT_COLLAPSED COLLAPSED="1"/>
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.count" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.name" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_dataset" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_total_features_written" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_failure_message" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <OUTPUT_FEAT NAME="SUMMARY"/>
#!     <FEAT_COLLAPSED COLLAPSED="2"/>
#!     <XFORM_ATTR ATTR_NAME="_proc_count" IS_USER_CREATED="false" FEAT_INDEX="2" />
#!     <XFORM_ATTR ATTR_NAME="_processes{}" IS_USER_CREATED="false" FEAT_INDEX="2" />
#!     <XFORM_PARM PARM_NAME="BLOCKING" PARM_VALUE="Yes"/>
#!     <XFORM_PARM PARM_NAME="MAX_PROC" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="PARAMETERS_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="PARAMETER_TYPES" PARM_VALUE="MULTIFILE,FILENAME"/>
#!     <XFORM_PARM PARM_NAME="TRANSFORMER_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="WORKSPACE_FILE" PARM_VALUE="ConnectingLink.fmw"/>
#!     <XFORM_PARM PARM_NAME="WORKSPACE_PARAMETERS" PARM_VALUE="SourceDataset_GML,$(PATHS_INPUT)&lt;backslash&gt;Highways_Paths_ConnectingLink_*.gml.gz,DestDataset_GEOPACKAGE,$(DEST_FOLDER)&lt;backslash&gt;ConnectingLink.gpkg"/>
#!     <XFORM_PARM PARM_NAME="XFORMER_NAME" PARM_VALUE="ConnectingLink"/>
#! </TRANSFORMER>
#! <TRANSFORMER
#!   IDENTIFIER="5"
#!   TYPE="WorkspaceRunner"
#!   VERSION="2"
#!   POSITION="107.52746250426148 -1734.1059375502819"
#!   BOUNDING_RECT="107.52746250426148 -1734.1059375502819 -1 -1"
#!   ORDER="500000000000000"
#!   PARMS_EDITED="true"
#!   ENABLED="true"
#!   LAST_PARM_EDIT="18547"
#! >
#!     <OUTPUT_FEAT NAME="SUCCEEDED"/>
#!     <FEAT_COLLAPSED COLLAPSED="0"/>
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.count" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.name" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_dataset" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_total_features_written" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_failure_message" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <OUTPUT_FEAT NAME="FAILED"/>
#!     <FEAT_COLLAPSED COLLAPSED="1"/>
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.count" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.name" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_dataset" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_total_features_written" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_failure_message" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <OUTPUT_FEAT NAME="SUMMARY"/>
#!     <FEAT_COLLAPSED COLLAPSED="2"/>
#!     <XFORM_ATTR ATTR_NAME="_proc_count" IS_USER_CREATED="false" FEAT_INDEX="2" />
#!     <XFORM_ATTR ATTR_NAME="_processes{}" IS_USER_CREATED="false" FEAT_INDEX="2" />
#!     <XFORM_PARM PARM_NAME="BLOCKING" PARM_VALUE="Yes"/>
#!     <XFORM_PARM PARM_NAME="MAX_PROC" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="PARAMETERS_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="PARAMETER_TYPES" PARM_VALUE="MULTIFILE,FILENAME"/>
#!     <XFORM_PARM PARM_NAME="TRANSFORMER_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="WORKSPACE_FILE" PARM_VALUE="FerryLink.fmw"/>
#!     <XFORM_PARM PARM_NAME="WORKSPACE_PARAMETERS" PARM_VALUE="SourceDataset_GML,$(ROADS_INPUT)&lt;backslash&gt;Highways_Rrami_FerryLink_*.gml.gz,DestDataset_GEOPACKAGE,$(DEST_FOLDER)&lt;backslash&gt;FerryLink_Roads.gpkg"/>
#!     <XFORM_PARM PARM_NAME="XFORMER_NAME" PARM_VALUE="FerryLink_Roads"/>
#! </TRANSFORMER>
#! <TRANSFORMER
#!   IDENTIFIER="6"
#!   TYPE="WorkspaceRunner"
#!   VERSION="2"
#!   POSITION="110.65546250426149 -2068.4859375502815"
#!   BOUNDING_RECT="110.65546250426149 -2068.4859375502815 -1 -1"
#!   ORDER="500000000000000"
#!   PARMS_EDITED="true"
#!   ENABLED="true"
#!   LAST_PARM_EDIT="18547"
#! >
#!     <OUTPUT_FEAT NAME="SUCCEEDED"/>
#!     <FEAT_COLLAPSED COLLAPSED="0"/>
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.count" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.name" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_dataset" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_total_features_written" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_failure_message" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <OUTPUT_FEAT NAME="FAILED"/>
#!     <FEAT_COLLAPSED COLLAPSED="1"/>
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.count" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.name" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_dataset" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_total_features_written" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_failure_message" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <OUTPUT_FEAT NAME="SUMMARY"/>
#!     <FEAT_COLLAPSED COLLAPSED="2"/>
#!     <XFORM_ATTR ATTR_NAME="_proc_count" IS_USER_CREATED="false" FEAT_INDEX="2" />
#!     <XFORM_ATTR ATTR_NAME="_processes{}" IS_USER_CREATED="false" FEAT_INDEX="2" />
#!     <XFORM_PARM PARM_NAME="BLOCKING" PARM_VALUE="Yes"/>
#!     <XFORM_PARM PARM_NAME="MAX_PROC" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="PARAMETERS_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="PARAMETER_TYPES" PARM_VALUE="MULTIFILE,FILENAME"/>
#!     <XFORM_PARM PARM_NAME="TRANSFORMER_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="WORKSPACE_FILE" PARM_VALUE="FerryLink.fmw"/>
#!     <XFORM_PARM PARM_NAME="WORKSPACE_PARAMETERS" PARM_VALUE="SourceDataset_GML,$(PATHS_INPUT)&lt;backslash&gt;Highways_Paths_FerryLink_*.gml.gz,DestDataset_GEOPACKAGE,$(DEST_FOLDER)&lt;backslash&gt;FerryLink_Paths.gpkg"/>
#!     <XFORM_PARM PARM_NAME="XFORMER_NAME" PARM_VALUE="FerryLink_Paths"/>
#! </TRANSFORMER>
#! <TRANSFORMER
#!   IDENTIFIER="7"
#!   TYPE="WorkspaceRunner"
#!   VERSION="2"
#!   POSITION="667.62006250426145 -736.97293755028397"
#!   BOUNDING_RECT="667.62006250426145 -736.97293755028397 -1 -1"
#!   ORDER="500000000000000"
#!   PARMS_EDITED="true"
#!   ENABLED="true"
#!   LAST_PARM_EDIT="18547"
#! >
#!     <OUTPUT_FEAT NAME="SUCCEEDED"/>
#!     <FEAT_COLLAPSED COLLAPSED="0"/>
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.count" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.name" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_dataset" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_total_features_written" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_failure_message" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <OUTPUT_FEAT NAME="FAILED"/>
#!     <FEAT_COLLAPSED COLLAPSED="1"/>
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.count" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.name" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_dataset" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_total_features_written" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_failure_message" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <OUTPUT_FEAT NAME="SUMMARY"/>
#!     <FEAT_COLLAPSED COLLAPSED="2"/>
#!     <XFORM_ATTR ATTR_NAME="_proc_count" IS_USER_CREATED="false" FEAT_INDEX="2" />
#!     <XFORM_ATTR ATTR_NAME="_processes{}" IS_USER_CREATED="false" FEAT_INDEX="2" />
#!     <XFORM_PARM PARM_NAME="BLOCKING" PARM_VALUE="Yes"/>
#!     <XFORM_PARM PARM_NAME="MAX_PROC" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="PARAMETERS_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="PARAMETER_TYPES" PARM_VALUE="MULTIFILE,FILENAME"/>
#!     <XFORM_PARM PARM_NAME="TRANSFORMER_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="WORKSPACE_FILE" PARM_VALUE="RoadNode.fmw"/>
#!     <XFORM_PARM PARM_NAME="WORKSPACE_PARAMETERS" PARM_VALUE="SourceDataset_GML,$(ROADS_INPUT)&lt;backslash&gt;Highways_Rrami_RoadNode_*.gml.gz,DestDataset_GEOPACKAGE,$(DEST_FOLDER)&lt;backslash&gt;RoadNode.gpkg"/>
#!     <XFORM_PARM PARM_NAME="XFORMER_NAME" PARM_VALUE="RoadNode"/>
#! </TRANSFORMER>
#! <TRANSFORMER
#!   IDENTIFIER="8"
#!   TYPE="WorkspaceRunner"
#!   VERSION="2"
#!   POSITION="667.62006250426123 -1059.1019375502838"
#!   BOUNDING_RECT="667.62006250426123 -1059.1019375502838 -1 -1"
#!   ORDER="500000000000000"
#!   PARMS_EDITED="true"
#!   ENABLED="true"
#!   LAST_PARM_EDIT="18547"
#! >
#!     <OUTPUT_FEAT NAME="SUCCEEDED"/>
#!     <FEAT_COLLAPSED COLLAPSED="0"/>
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.count" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.name" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_dataset" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_total_features_written" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_failure_message" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <OUTPUT_FEAT NAME="FAILED"/>
#!     <FEAT_COLLAPSED COLLAPSED="1"/>
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.count" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.name" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_dataset" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_total_features_written" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_failure_message" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <OUTPUT_FEAT NAME="SUMMARY"/>
#!     <FEAT_COLLAPSED COLLAPSED="2"/>
#!     <XFORM_ATTR ATTR_NAME="_proc_count" IS_USER_CREATED="false" FEAT_INDEX="2" />
#!     <XFORM_ATTR ATTR_NAME="_processes{}" IS_USER_CREATED="false" FEAT_INDEX="2" />
#!     <XFORM_PARM PARM_NAME="BLOCKING" PARM_VALUE="Yes"/>
#!     <XFORM_PARM PARM_NAME="MAX_PROC" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="PARAMETERS_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="PARAMETER_TYPES" PARM_VALUE="MULTIFILE,FILENAME"/>
#!     <XFORM_PARM PARM_NAME="TRANSFORMER_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="WORKSPACE_FILE" PARM_VALUE="PathNode.fmw"/>
#!     <XFORM_PARM PARM_NAME="WORKSPACE_PARAMETERS" PARM_VALUE="SourceDataset_GML,$(PATHS_INPUT)&lt;backslash&gt;Highways_Paths_PathNode_*.gml.gz,DestDataset_GEOPACKAGE,$(DEST_FOLDER)&lt;backslash&gt;PathNode.gpkg"/>
#!     <XFORM_PARM PARM_NAME="XFORMER_NAME" PARM_VALUE="PathNode"/>
#! </TRANSFORMER>
#! <TRANSFORMER
#!   IDENTIFIER="9"
#!   TYPE="WorkspaceRunner"
#!   VERSION="2"
#!   POSITION="667.62006250426123 -1402.8549375502839"
#!   BOUNDING_RECT="667.62006250426123 -1402.8549375502839 -1 -1"
#!   ORDER="500000000000000"
#!   PARMS_EDITED="true"
#!   ENABLED="true"
#!   LAST_PARM_EDIT="18547"
#! >
#!     <OUTPUT_FEAT NAME="SUCCEEDED"/>
#!     <FEAT_COLLAPSED COLLAPSED="0"/>
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.count" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.name" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_dataset" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_total_features_written" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_failure_message" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <OUTPUT_FEAT NAME="FAILED"/>
#!     <FEAT_COLLAPSED COLLAPSED="1"/>
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.count" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.name" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_dataset" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_total_features_written" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_failure_message" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <OUTPUT_FEAT NAME="SUMMARY"/>
#!     <FEAT_COLLAPSED COLLAPSED="2"/>
#!     <XFORM_ATTR ATTR_NAME="_proc_count" IS_USER_CREATED="false" FEAT_INDEX="2" />
#!     <XFORM_ATTR ATTR_NAME="_processes{}" IS_USER_CREATED="false" FEAT_INDEX="2" />
#!     <XFORM_PARM PARM_NAME="BLOCKING" PARM_VALUE="Yes"/>
#!     <XFORM_PARM PARM_NAME="MAX_PROC" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="PARAMETERS_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="PARAMETER_TYPES" PARM_VALUE="MULTIFILE,FILENAME"/>
#!     <XFORM_PARM PARM_NAME="TRANSFORMER_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="WORKSPACE_FILE" PARM_VALUE="ConnectingNode.fmw"/>
#!     <XFORM_PARM PARM_NAME="WORKSPACE_PARAMETERS" PARM_VALUE="SourceDataset_GML,$(PATHS_INPUT)&lt;backslash&gt;Highways_Paths_ConnectingNode_*.gml.gz,DestDataset_GEOPACKAGE,$(DEST_FOLDER)&lt;backslash&gt;ConnectingNode.gpkg"/>
#!     <XFORM_PARM PARM_NAME="XFORMER_NAME" PARM_VALUE="ConnectingNode"/>
#! </TRANSFORMER>
#! <TRANSFORMER
#!   IDENTIFIER="10"
#!   TYPE="WorkspaceRunner"
#!   VERSION="2"
#!   POSITION="667.62006250426123 -1734.1059375502819"
#!   BOUNDING_RECT="667.62006250426123 -1734.1059375502819 -1 -1"
#!   ORDER="500000000000000"
#!   PARMS_EDITED="true"
#!   ENABLED="true"
#!   LAST_PARM_EDIT="18547"
#! >
#!     <OUTPUT_FEAT NAME="SUCCEEDED"/>
#!     <FEAT_COLLAPSED COLLAPSED="0"/>
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.count" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.name" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_dataset" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_total_features_written" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_failure_message" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <OUTPUT_FEAT NAME="FAILED"/>
#!     <FEAT_COLLAPSED COLLAPSED="1"/>
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.count" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.name" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_dataset" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_total_features_written" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_failure_message" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <OUTPUT_FEAT NAME="SUMMARY"/>
#!     <FEAT_COLLAPSED COLLAPSED="2"/>
#!     <XFORM_ATTR ATTR_NAME="_proc_count" IS_USER_CREATED="false" FEAT_INDEX="2" />
#!     <XFORM_ATTR ATTR_NAME="_processes{}" IS_USER_CREATED="false" FEAT_INDEX="2" />
#!     <XFORM_PARM PARM_NAME="BLOCKING" PARM_VALUE="Yes"/>
#!     <XFORM_PARM PARM_NAME="MAX_PROC" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="PARAMETERS_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="PARAMETER_TYPES" PARM_VALUE="MULTIFILE,FILENAME"/>
#!     <XFORM_PARM PARM_NAME="TRANSFORMER_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="WORKSPACE_FILE" PARM_VALUE="FerryNode.fmw"/>
#!     <XFORM_PARM PARM_NAME="WORKSPACE_PARAMETERS" PARM_VALUE="SourceDataset_GML,$(ROADS_INPUT)&lt;backslash&gt;Highways_Rrami_FerryNode_*.gml.gz,DestDataset_GEOPACKAGE,$(DEST_FOLDER)&lt;backslash&gt;FerryNode_Roads.gpkg"/>
#!     <XFORM_PARM PARM_NAME="XFORMER_NAME" PARM_VALUE="FerryNode_Roads"/>
#! </TRANSFORMER>
#! <TRANSFORMER
#!   IDENTIFIER="11"
#!   TYPE="WorkspaceRunner"
#!   VERSION="2"
#!   POSITION="667.62006250426123 -2068.4859375502815"
#!   BOUNDING_RECT="667.62006250426123 -2068.4859375502815 -1 -1"
#!   ORDER="500000000000000"
#!   PARMS_EDITED="true"
#!   ENABLED="true"
#!   LAST_PARM_EDIT="18547"
#! >
#!     <OUTPUT_FEAT NAME="SUCCEEDED"/>
#!     <FEAT_COLLAPSED COLLAPSED="0"/>
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.count" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.name" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_dataset" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_total_features_written" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_failure_message" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <OUTPUT_FEAT NAME="FAILED"/>
#!     <FEAT_COLLAPSED COLLAPSED="1"/>
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.count" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.name" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_dataset" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_total_features_written" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_failure_message" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <OUTPUT_FEAT NAME="SUMMARY"/>
#!     <FEAT_COLLAPSED COLLAPSED="2"/>
#!     <XFORM_ATTR ATTR_NAME="_proc_count" IS_USER_CREATED="false" FEAT_INDEX="2" />
#!     <XFORM_ATTR ATTR_NAME="_processes{}" IS_USER_CREATED="false" FEAT_INDEX="2" />
#!     <XFORM_PARM PARM_NAME="BLOCKING" PARM_VALUE="Yes"/>
#!     <XFORM_PARM PARM_NAME="MAX_PROC" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="PARAMETERS_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="PARAMETER_TYPES" PARM_VALUE="MULTIFILE,FILENAME"/>
#!     <XFORM_PARM PARM_NAME="TRANSFORMER_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="WORKSPACE_FILE" PARM_VALUE="FerryNode.fmw"/>
#!     <XFORM_PARM PARM_NAME="WORKSPACE_PARAMETERS" PARM_VALUE="SourceDataset_GML,$(PATHS_INPUT)&lt;backslash&gt;Highways_Paths_FerryNode_*.gml.gz,DestDataset_GEOPACKAGE,$(DEST_FOLDER)&lt;backslash&gt;FerryNode_Paths.gpkg"/>
#!     <XFORM_PARM PARM_NAME="XFORMER_NAME" PARM_VALUE="FerryNode_Paths"/>
#! </TRANSFORMER>
#! <TRANSFORMER
#!   IDENTIFIER="12"
#!   TYPE="WorkspaceRunner"
#!   VERSION="2"
#!   POSITION="1237.9440625042614 -2071.6159375502816"
#!   BOUNDING_RECT="1237.9440625042614 -2071.6159375502816 -1 -1"
#!   ORDER="500000000000000"
#!   PARMS_EDITED="true"
#!   ENABLED="true"
#!   LAST_PARM_EDIT="18547"
#! >
#!     <OUTPUT_FEAT NAME="SUCCEEDED"/>
#!     <FEAT_COLLAPSED COLLAPSED="0"/>
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.count" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.name" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_dataset" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_total_features_written" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_failure_message" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <OUTPUT_FEAT NAME="FAILED"/>
#!     <FEAT_COLLAPSED COLLAPSED="1"/>
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.count" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.name" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_dataset" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_total_features_written" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_failure_message" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <OUTPUT_FEAT NAME="SUMMARY"/>
#!     <FEAT_COLLAPSED COLLAPSED="2"/>
#!     <XFORM_ATTR ATTR_NAME="_proc_count" IS_USER_CREATED="false" FEAT_INDEX="2" />
#!     <XFORM_ATTR ATTR_NAME="_processes{}" IS_USER_CREATED="false" FEAT_INDEX="2" />
#!     <XFORM_PARM PARM_NAME="BLOCKING" PARM_VALUE="Yes"/>
#!     <XFORM_PARM PARM_NAME="MAX_PROC" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="PARAMETERS_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="PARAMETER_TYPES" PARM_VALUE="MULTIFILE,MULTIFILE,MULTIFILE,FILENAME"/>
#!     <XFORM_PARM PARM_NAME="TRANSFORMER_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="WORKSPACE_FILE" PARM_VALUE="HazardsAndStructures.fmw"/>
#!     <XFORM_PARM PARM_NAME="WORKSPACE_PARAMETERS" PARM_VALUE="SourceDataset_Hazard,$(ROADS_INPUT)&lt;backslash&gt;Highways_Rrami_Hazard_*.gml.gz,SourceDataset_Structure,$(ROADS_INPUT)&lt;backslash&gt;Highways_Rrami_Structure_*.gml.gz,SourceDataset_RoadLink,$(ROADS_INPUT)&lt;backslash&gt;Highways_Rrami_RoadLink_*.gml.gz,DestDataset_HazardAndStructure,$(DEST_FOLDER)&lt;backslash&gt;HazardAndStructure.gpkg"/>
#!     <XFORM_PARM PARM_NAME="XFORMER_NAME" PARM_VALUE="HazardAndStructure"/>
#! </TRANSFORMER>
#! <TRANSFORMER
#!   IDENTIFIER="18"
#!   TYPE="WorkspaceRunner"
#!   VERSION="2"
#!   POSITION="1239.5040625042616 -736.97293755028397"
#!   BOUNDING_RECT="1239.5040625042616 -736.97293755028397 -1 -1"
#!   ORDER="500000000000000"
#!   PARMS_EDITED="true"
#!   ENABLED="true"
#!   LAST_PARM_EDIT="18547"
#! >
#!     <OUTPUT_FEAT NAME="SUCCEEDED"/>
#!     <FEAT_COLLAPSED COLLAPSED="0"/>
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.count" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.name" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_dataset" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_total_features_written" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_failure_message" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <OUTPUT_FEAT NAME="FAILED"/>
#!     <FEAT_COLLAPSED COLLAPSED="1"/>
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.count" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.name" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_dataset" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_total_features_written" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_failure_message" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <OUTPUT_FEAT NAME="SUMMARY"/>
#!     <FEAT_COLLAPSED COLLAPSED="2"/>
#!     <XFORM_ATTR ATTR_NAME="_proc_count" IS_USER_CREATED="false" FEAT_INDEX="2" />
#!     <XFORM_ATTR ATTR_NAME="_processes{}" IS_USER_CREATED="false" FEAT_INDEX="2" />
#!     <XFORM_PARM PARM_NAME="BLOCKING" PARM_VALUE="Yes"/>
#!     <XFORM_PARM PARM_NAME="MAX_PROC" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="PARAMETERS_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="PARAMETER_TYPES" PARM_VALUE="MULTIFILE,FILENAME"/>
#!     <XFORM_PARM PARM_NAME="TRANSFORMER_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="WORKSPACE_FILE" PARM_VALUE="Street.fmw"/>
#!     <XFORM_PARM PARM_NAME="WORKSPACE_PARAMETERS" PARM_VALUE="SourceDataset_Street,$(ROADS_INPUT)&lt;backslash&gt;Highways_Rrami_Street_*.gml.gz,DestDataset_Street,$(DEST_FOLDER)&lt;backslash&gt;Street_Roads.gpkg"/>
#!     <XFORM_PARM PARM_NAME="XFORMER_NAME" PARM_VALUE="Street_Roads"/>
#! </TRANSFORMER>
#! <TRANSFORMER
#!   IDENTIFIER="19"
#!   TYPE="WorkspaceRunner"
#!   VERSION="2"
#!   POSITION="1237.9440625042614 -1059.1019375502838"
#!   BOUNDING_RECT="1237.9440625042614 -1059.1019375502838 -1 -1"
#!   ORDER="500000000000000"
#!   PARMS_EDITED="true"
#!   ENABLED="true"
#!   LAST_PARM_EDIT="18547"
#! >
#!     <OUTPUT_FEAT NAME="SUCCEEDED"/>
#!     <FEAT_COLLAPSED COLLAPSED="0"/>
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.count" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.name" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_dataset" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_total_features_written" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_failure_message" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <OUTPUT_FEAT NAME="FAILED"/>
#!     <FEAT_COLLAPSED COLLAPSED="1"/>
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.count" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.name" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_dataset" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_total_features_written" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_failure_message" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <OUTPUT_FEAT NAME="SUMMARY"/>
#!     <FEAT_COLLAPSED COLLAPSED="2"/>
#!     <XFORM_ATTR ATTR_NAME="_proc_count" IS_USER_CREATED="false" FEAT_INDEX="2" />
#!     <XFORM_ATTR ATTR_NAME="_processes{}" IS_USER_CREATED="false" FEAT_INDEX="2" />
#!     <XFORM_PARM PARM_NAME="BLOCKING" PARM_VALUE="Yes"/>
#!     <XFORM_PARM PARM_NAME="MAX_PROC" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="PARAMETERS_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="PARAMETER_TYPES" PARM_VALUE="MULTIFILE,FILENAME"/>
#!     <XFORM_PARM PARM_NAME="TRANSFORMER_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="WORKSPACE_FILE" PARM_VALUE="Street.fmw"/>
#!     <XFORM_PARM PARM_NAME="WORKSPACE_PARAMETERS" PARM_VALUE="SourceDataset_Street,$(PATHS_INPUT)&lt;backslash&gt;Highways_Paths_Street_*.gml.gz,DestDataset_Street,$(DEST_FOLDER)&lt;backslash&gt;Street_Paths.gpkg"/>
#!     <XFORM_PARM PARM_NAME="XFORMER_NAME" PARM_VALUE="Street_Paths"/>
#! </TRANSFORMER>
#! <TRANSFORMER
#!   IDENTIFIER="20"
#!   TYPE="WorkspaceRunner"
#!   VERSION="2"
#!   POSITION="1239.5040625042616 -1402.8549375502839"
#!   BOUNDING_RECT="1239.5040625042616 -1402.8549375502839 -1 -1"
#!   ORDER="500000000000000"
#!   PARMS_EDITED="true"
#!   ENABLED="true"
#!   LAST_PARM_EDIT="18547"
#! >
#!     <OUTPUT_FEAT NAME="SUCCEEDED"/>
#!     <FEAT_COLLAPSED COLLAPSED="0"/>
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.count" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.name" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_dataset" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_total_features_written" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_failure_message" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <OUTPUT_FEAT NAME="FAILED"/>
#!     <FEAT_COLLAPSED COLLAPSED="1"/>
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.count" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.name" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_dataset" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_total_features_written" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_failure_message" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <OUTPUT_FEAT NAME="SUMMARY"/>
#!     <FEAT_COLLAPSED COLLAPSED="2"/>
#!     <XFORM_ATTR ATTR_NAME="_proc_count" IS_USER_CREATED="false" FEAT_INDEX="2" />
#!     <XFORM_ATTR ATTR_NAME="_processes{}" IS_USER_CREATED="false" FEAT_INDEX="2" />
#!     <XFORM_PARM PARM_NAME="BLOCKING" PARM_VALUE="Yes"/>
#!     <XFORM_PARM PARM_NAME="MAX_PROC" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="PARAMETERS_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="PARAMETER_TYPES" PARM_VALUE="MULTIFILE,FILENAME"/>
#!     <XFORM_PARM PARM_NAME="TRANSFORMER_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="WORKSPACE_FILE" PARM_VALUE="HighwayDedication.fmw"/>
#!     <XFORM_PARM PARM_NAME="WORKSPACE_PARAMETERS" PARM_VALUE="SourceDataset_GML,$(ROADS_INPUT)&lt;backslash&gt;Highways_Rrami_Dedication_*.gml.gz,DestDataset_GEOPACKAGE,$(DEST_FOLDER)&lt;backslash&gt;Dedication_Roads.gpkg"/>
#!     <XFORM_PARM PARM_NAME="XFORMER_NAME" PARM_VALUE="Dedication_Roads"/>
#! </TRANSFORMER>
#! <TRANSFORMER
#!   IDENTIFIER="21"
#!   TYPE="WorkspaceRunner"
#!   VERSION="2"
#!   POSITION="1240.3440625042617 -1734.1059375502819"
#!   BOUNDING_RECT="1240.3440625042617 -1734.1059375502819 -1 -1"
#!   ORDER="500000000000000"
#!   PARMS_EDITED="true"
#!   ENABLED="true"
#!   LAST_PARM_EDIT="18547"
#! >
#!     <OUTPUT_FEAT NAME="SUCCEEDED"/>
#!     <FEAT_COLLAPSED COLLAPSED="0"/>
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.count" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.name" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_dataset" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_total_features_written" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_failure_message" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <OUTPUT_FEAT NAME="FAILED"/>
#!     <FEAT_COLLAPSED COLLAPSED="1"/>
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.count" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.name" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_dataset" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_total_features_written" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_failure_message" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <OUTPUT_FEAT NAME="SUMMARY"/>
#!     <FEAT_COLLAPSED COLLAPSED="2"/>
#!     <XFORM_ATTR ATTR_NAME="_proc_count" IS_USER_CREATED="false" FEAT_INDEX="2" />
#!     <XFORM_ATTR ATTR_NAME="_processes{}" IS_USER_CREATED="false" FEAT_INDEX="2" />
#!     <XFORM_PARM PARM_NAME="BLOCKING" PARM_VALUE="Yes"/>
#!     <XFORM_PARM PARM_NAME="MAX_PROC" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="PARAMETERS_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="PARAMETER_TYPES" PARM_VALUE="MULTIFILE,FILENAME"/>
#!     <XFORM_PARM PARM_NAME="TRANSFORMER_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="WORKSPACE_FILE" PARM_VALUE="HighwayDedication.fmw"/>
#!     <XFORM_PARM PARM_NAME="WORKSPACE_PARAMETERS" PARM_VALUE="SourceDataset_GML,$(PATHS_INPUT)&lt;backslash&gt;Highways_Paths_Dedication_*.gml.gz,DestDataset_GEOPACKAGE,$(DEST_FOLDER)&lt;backslash&gt;Dedication_Paths.gpkg"/>
#!     <XFORM_PARM PARM_NAME="XFORMER_NAME" PARM_VALUE="Dedication_Paths"/>
#! </TRANSFORMER>
#! <TRANSFORMER
#!   IDENTIFIER="22"
#!   TYPE="WorkspaceRunner"
#!   VERSION="2"
#!   POSITION="1805.8440625042615 -736.97293755028397"
#!   BOUNDING_RECT="1805.8440625042615 -736.97293755028397 -1 -1"
#!   ORDER="500000000000000"
#!   PARMS_EDITED="true"
#!   ENABLED="true"
#!   LAST_PARM_EDIT="18547"
#! >
#!     <OUTPUT_FEAT NAME="SUCCEEDED"/>
#!     <FEAT_COLLAPSED COLLAPSED="0"/>
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.count" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.name" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_dataset" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_total_features_written" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_failure_message" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <OUTPUT_FEAT NAME="FAILED"/>
#!     <FEAT_COLLAPSED COLLAPSED="1"/>
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.count" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.name" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_dataset" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_total_features_written" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_failure_message" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <OUTPUT_FEAT NAME="SUMMARY"/>
#!     <FEAT_COLLAPSED COLLAPSED="2"/>
#!     <XFORM_ATTR ATTR_NAME="_proc_count" IS_USER_CREATED="false" FEAT_INDEX="2" />
#!     <XFORM_ATTR ATTR_NAME="_processes{}" IS_USER_CREATED="false" FEAT_INDEX="2" />
#!     <XFORM_PARM PARM_NAME="BLOCKING" PARM_VALUE="Yes"/>
#!     <XFORM_PARM PARM_NAME="MAX_PROC" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="PARAMETERS_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="PARAMETER_TYPES" PARM_VALUE="MULTIFILE,FILENAME"/>
#!     <XFORM_PARM PARM_NAME="TRANSFORMER_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="WORKSPACE_FILE" PARM_VALUE="Road.fmw"/>
#!     <XFORM_PARM PARM_NAME="WORKSPACE_PARAMETERS" PARM_VALUE="SourceDataset_Road,$(ROADS_INPUT)&lt;backslash&gt;Highways_Rrami_Road_*.gml.gz,DestDataset_GEOPACKAGE,$(DEST_FOLDER)&lt;backslash&gt;Road.gpkg"/>
#!     <XFORM_PARM PARM_NAME="XFORMER_NAME" PARM_VALUE="Road"/>
#! </TRANSFORMER>
#! <TRANSFORMER
#!   IDENTIFIER="23"
#!   TYPE="WorkspaceRunner"
#!   VERSION="2"
#!   POSITION="1805.8440625042615 -1059.1019375502838"
#!   BOUNDING_RECT="1805.8440625042615 -1059.1019375502838 -1 -1"
#!   ORDER="500000000000000"
#!   PARMS_EDITED="true"
#!   ENABLED="true"
#!   LAST_PARM_EDIT="18547"
#! >
#!     <OUTPUT_FEAT NAME="SUCCEEDED"/>
#!     <FEAT_COLLAPSED COLLAPSED="0"/>
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.count" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.name" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_dataset" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_total_features_written" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_failure_message" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <OUTPUT_FEAT NAME="FAILED"/>
#!     <FEAT_COLLAPSED COLLAPSED="1"/>
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.count" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.name" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_dataset" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_total_features_written" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_failure_message" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <OUTPUT_FEAT NAME="SUMMARY"/>
#!     <FEAT_COLLAPSED COLLAPSED="2"/>
#!     <XFORM_ATTR ATTR_NAME="_proc_count" IS_USER_CREATED="false" FEAT_INDEX="2" />
#!     <XFORM_ATTR ATTR_NAME="_processes{}" IS_USER_CREATED="false" FEAT_INDEX="2" />
#!     <XFORM_PARM PARM_NAME="BLOCKING" PARM_VALUE="Yes"/>
#!     <XFORM_PARM PARM_NAME="MAX_PROC" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="PARAMETERS_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="PARAMETER_TYPES" PARM_VALUE="MULTIFILE,FILENAME"/>
#!     <XFORM_PARM PARM_NAME="TRANSFORMER_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="WORKSPACE_FILE" PARM_VALUE="Path.fmw"/>
#!     <XFORM_PARM PARM_NAME="WORKSPACE_PARAMETERS" PARM_VALUE="SourceDataset_GML,$(PATHS_INPUT)&lt;backslash&gt;Highways_Paths_Path_*.gml.gz,DestDataset_GEOPACKAGE,$(DEST_FOLDER)&lt;backslash&gt;Path.gpkg"/>
#!     <XFORM_PARM PARM_NAME="XFORMER_NAME" PARM_VALUE="Path"/>
#! </TRANSFORMER>
#! <TRANSFORMER
#!   IDENTIFIER="24"
#!   TYPE="WorkspaceRunner"
#!   VERSION="2"
#!   POSITION="110.65546250426148 -736.97293755028397"
#!   BOUNDING_RECT="110.65546250426148 -736.97293755028397 -1 -1"
#!   ORDER="500000000000000"
#!   PARMS_EDITED="true"
#!   ENABLED="true"
#!   LAST_PARM_EDIT="18547"
#! >
#!     <OUTPUT_FEAT NAME="SUCCEEDED"/>
#!     <FEAT_COLLAPSED COLLAPSED="0"/>
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.count" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.name" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_dataset" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_total_features_written" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <OUTPUT_FEAT NAME="FAILED"/>
#!     <FEAT_COLLAPSED COLLAPSED="1"/>
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.count" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.name" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_dataset" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_total_features_written" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_failure_message" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <OUTPUT_FEAT NAME="SUMMARY"/>
#!     <FEAT_COLLAPSED COLLAPSED="2"/>
#!     <XFORM_ATTR ATTR_NAME="_proc_count" IS_USER_CREATED="false" FEAT_INDEX="2" />
#!     <XFORM_ATTR ATTR_NAME="_processes{}" IS_USER_CREATED="false" FEAT_INDEX="2" />
#!     <XFORM_PARM PARM_NAME="BLOCKING" PARM_VALUE="Yes"/>
#!     <XFORM_PARM PARM_NAME="MAX_PROC" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="PARAMETERS_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="PARAMETER_TYPES" PARM_VALUE="MULTIFILE,FILENAME"/>
#!     <XFORM_PARM PARM_NAME="TRANSFORMER_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="WORKSPACE_FILE" PARM_VALUE="RoadLink.fmw"/>
#!     <XFORM_PARM PARM_NAME="WORKSPACE_PARAMETERS" PARM_VALUE="SourceDataset_GML,$(ROADS_INPUT)&lt;backslash&gt;Highways_Rrami_RoadLink_*.gml.gz,DestDataset_GEOPACKAGE,$(DEST_FOLDER)&lt;backslash&gt;RoadLink.gpkg"/>
#!     <XFORM_PARM PARM_NAME="XFORMER_NAME" PARM_VALUE="RoadLink"/>
#! </TRANSFORMER>
#! <TRANSFORMER
#!   IDENTIFIER="25"
#!   TYPE="WorkspaceRunner"
#!   VERSION="2"
#!   POSITION="1798.0366625042609 -2071.6159375502816"
#!   BOUNDING_RECT="1798.0366625042609 -2071.6159375502816 -1 -1"
#!   ORDER="500000000000000"
#!   PARMS_EDITED="true"
#!   ENABLED="true"
#!   LAST_PARM_EDIT="18547"
#! >
#!     <OUTPUT_FEAT NAME="SUCCEEDED"/>
#!     <FEAT_COLLAPSED COLLAPSED="0"/>
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.count" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.name" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_dataset" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_total_features_written" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_failure_message" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <OUTPUT_FEAT NAME="FAILED"/>
#!     <FEAT_COLLAPSED COLLAPSED="1"/>
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.count" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.name" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_dataset" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_total_features_written" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_failure_message" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <OUTPUT_FEAT NAME="SUMMARY"/>
#!     <FEAT_COLLAPSED COLLAPSED="2"/>
#!     <XFORM_ATTR ATTR_NAME="_proc_count" IS_USER_CREATED="false" FEAT_INDEX="2" />
#!     <XFORM_ATTR ATTR_NAME="_processes{}" IS_USER_CREATED="false" FEAT_INDEX="2" />
#!     <XFORM_PARM PARM_NAME="BLOCKING" PARM_VALUE="Yes"/>
#!     <XFORM_PARM PARM_NAME="MAX_PROC" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="PARAMETERS_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="PARAMETER_TYPES" PARM_VALUE="MULTIFILE,FILENAME"/>
#!     <XFORM_PARM PARM_NAME="TRANSFORMER_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="WORKSPACE_FILE" PARM_VALUE="RoadJunction.fmw"/>
#!     <XFORM_PARM PARM_NAME="WORKSPACE_PARAMETERS" PARM_VALUE="SourceDataset_RoadJunction,$(ROADS_INPUT)&lt;backslash&gt;Highways_Rrami_RoadJunction_*.gml*,DestDataset_RoadJunction,$(DEST_FOLDER)&lt;backslash&gt;RoadJunction.gpkg"/>
#!     <XFORM_PARM PARM_NAME="XFORMER_NAME" PARM_VALUE="RoadJunction"/>
#! </TRANSFORMER>
#! <TRANSFORMER
#!   IDENTIFIER="26"
#!   TYPE="WorkspaceRunner"
#!   VERSION="2"
#!   POSITION="1805.8440625042615 -1402.8549375502839"
#!   BOUNDING_RECT="1805.8440625042615 -1402.8549375502839 -1 -1"
#!   ORDER="500000000000000"
#!   PARMS_EDITED="true"
#!   ENABLED="true"
#!   LAST_PARM_EDIT="18547"
#! >
#!     <OUTPUT_FEAT NAME="SUCCEEDED"/>
#!     <FEAT_COLLAPSED COLLAPSED="0"/>
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.count" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.name" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_dataset" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_total_features_written" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_failure_message" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <OUTPUT_FEAT NAME="FAILED"/>
#!     <FEAT_COLLAPSED COLLAPSED="1"/>
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.count" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.name" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_dataset" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_total_features_written" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_failure_message" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <OUTPUT_FEAT NAME="SUMMARY"/>
#!     <FEAT_COLLAPSED COLLAPSED="2"/>
#!     <XFORM_ATTR ATTR_NAME="_proc_count" IS_USER_CREATED="false" FEAT_INDEX="2" />
#!     <XFORM_ATTR ATTR_NAME="_processes{}" IS_USER_CREATED="false" FEAT_INDEX="2" />
#!     <XFORM_PARM PARM_NAME="BLOCKING" PARM_VALUE="Yes"/>
#!     <XFORM_PARM PARM_NAME="MAX_PROC" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="PARAMETERS_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="PARAMETER_TYPES" PARM_VALUE="MULTIFILE,FILENAME"/>
#!     <XFORM_PARM PARM_NAME="TRANSFORMER_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="WORKSPACE_FILE" PARM_VALUE="FerryTerminal.fmw"/>
#!     <XFORM_PARM PARM_NAME="WORKSPACE_PARAMETERS" PARM_VALUE="SourceDataset_GML_3,$(ROADS_INPUT)&lt;backslash&gt;Highways_Rrami_FerryTerminal_*.gml.gz,DestDataset_GEOPACKAGE,$(DEST_FOLDER)&lt;backslash&gt;FerryTerminal_Roads.gpkg"/>
#!     <XFORM_PARM PARM_NAME="XFORMER_NAME" PARM_VALUE="FerryTerminal_Roads"/>
#! </TRANSFORMER>
#! <TRANSFORMER
#!   IDENTIFIER="27"
#!   TYPE="WorkspaceRunner"
#!   VERSION="2"
#!   POSITION="1802.0040625042616 -1734.1059375502819"
#!   BOUNDING_RECT="1802.0040625042616 -1734.1059375502819 -1 -1"
#!   ORDER="500000000000000"
#!   PARMS_EDITED="true"
#!   ENABLED="true"
#!   LAST_PARM_EDIT="18547"
#! >
#!     <OUTPUT_FEAT NAME="SUCCEEDED"/>
#!     <FEAT_COLLAPSED COLLAPSED="0"/>
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.count" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.name" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_dataset" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_total_features_written" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_failure_message" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <OUTPUT_FEAT NAME="FAILED"/>
#!     <FEAT_COLLAPSED COLLAPSED="1"/>
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.count" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.name" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_dataset" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_total_features_written" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_failure_message" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <OUTPUT_FEAT NAME="SUMMARY"/>
#!     <FEAT_COLLAPSED COLLAPSED="2"/>
#!     <XFORM_ATTR ATTR_NAME="_proc_count" IS_USER_CREATED="false" FEAT_INDEX="2" />
#!     <XFORM_ATTR ATTR_NAME="_processes{}" IS_USER_CREATED="false" FEAT_INDEX="2" />
#!     <XFORM_PARM PARM_NAME="BLOCKING" PARM_VALUE="Yes"/>
#!     <XFORM_PARM PARM_NAME="MAX_PROC" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="PARAMETERS_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="PARAMETER_TYPES" PARM_VALUE="MULTIFILE,FILENAME"/>
#!     <XFORM_PARM PARM_NAME="TRANSFORMER_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="WORKSPACE_FILE" PARM_VALUE="FerryTerminal.fmw"/>
#!     <XFORM_PARM PARM_NAME="WORKSPACE_PARAMETERS" PARM_VALUE="SourceDataset_GML_3,$(PATHS_INPUT)&lt;backslash&gt;Highways_Paths_FerryTerminal_*.gml.gz,DestDataset_GEOPACKAGE,$(DEST_FOLDER)&lt;backslash&gt;FerryTerminal_Paths.gpkg"/>
#!     <XFORM_PARM PARM_NAME="XFORMER_NAME" PARM_VALUE="FerryTerminal_Paths"/>
#! </TRANSFORMER>
#! <TRANSFORMER
#!   IDENTIFIER="77"
#!   TYPE="WorkspaceRunner"
#!   VERSION="2"
#!   POSITION="2370.7606625042608 -1402.8549375502839"
#!   BOUNDING_RECT="2370.7606625042608 -1402.8549375502839 -1 -1"
#!   ORDER="500000000000000"
#!   PARMS_EDITED="true"
#!   ENABLED="true"
#!   LAST_PARM_EDIT="18547"
#! >
#!     <OUTPUT_FEAT NAME="SUCCEEDED"/>
#!     <FEAT_COLLAPSED COLLAPSED="0"/>
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.count" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.name" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_dataset" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_total_features_written" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_failure_message" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <OUTPUT_FEAT NAME="FAILED"/>
#!     <FEAT_COLLAPSED COLLAPSED="1"/>
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.count" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.name" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_dataset" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_total_features_written" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_failure_message" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <OUTPUT_FEAT NAME="SUMMARY"/>
#!     <FEAT_COLLAPSED COLLAPSED="2"/>
#!     <XFORM_ATTR ATTR_NAME="_proc_count" IS_USER_CREATED="false" FEAT_INDEX="2" />
#!     <XFORM_ATTR ATTR_NAME="_processes{}" IS_USER_CREATED="false" FEAT_INDEX="2" />
#!     <XFORM_PARM PARM_NAME="BLOCKING" PARM_VALUE="Yes"/>
#!     <XFORM_PARM PARM_NAME="MAX_PROC" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="PARAMETERS_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="PARAMETER_TYPES" PARM_VALUE="MULTIFILE,MULTIFILE,FILENAME"/>
#!     <XFORM_PARM PARM_NAME="TRANSFORMER_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="WORKSPACE_FILE" PARM_VALUE="AccessRestriction.fmw"/>
#!     <XFORM_PARM PARM_NAME="WORKSPACE_PARAMETERS" PARM_VALUE="SourceDataset_RoadLink,$(ROADS_INPUT)&lt;backslash&gt;Highways_Rrami_RoadLink_*.gml.gz,SourceDataset_GML_3,$(ROADS_INPUT)&lt;backslash&gt;Highways_Rrami_AccessRestriction_*.gml.gz,DestDataset_GEOPACKAGE,$(DEST_FOLDER)&lt;backslash&gt;AccessRestriction.gpkg"/>
#!     <XFORM_PARM PARM_NAME="XFORMER_NAME" PARM_VALUE="AccessRestriction"/>
#! </TRANSFORMER>
#! <TRANSFORMER
#!   IDENTIFIER="78"
#!   TYPE="WorkspaceRunner"
#!   VERSION="2"
#!   POSITION="2365.9366625042603 -1734.1059375502819"
#!   BOUNDING_RECT="2365.9366625042603 -1734.1059375502819 -1 -1"
#!   ORDER="500000000000000"
#!   PARMS_EDITED="true"
#!   ENABLED="true"
#!   LAST_PARM_EDIT="18547"
#! >
#!     <OUTPUT_FEAT NAME="SUCCEEDED"/>
#!     <FEAT_COLLAPSED COLLAPSED="0"/>
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.count" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.name" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_dataset" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_total_features_written" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_failure_message" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <OUTPUT_FEAT NAME="FAILED"/>
#!     <FEAT_COLLAPSED COLLAPSED="1"/>
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.count" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.name" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_dataset" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_total_features_written" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_failure_message" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <OUTPUT_FEAT NAME="SUMMARY"/>
#!     <FEAT_COLLAPSED COLLAPSED="2"/>
#!     <XFORM_ATTR ATTR_NAME="_proc_count" IS_USER_CREATED="false" FEAT_INDEX="2" />
#!     <XFORM_ATTR ATTR_NAME="_processes{}" IS_USER_CREATED="false" FEAT_INDEX="2" />
#!     <XFORM_PARM PARM_NAME="BLOCKING" PARM_VALUE="Yes"/>
#!     <XFORM_PARM PARM_NAME="MAX_PROC" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="PARAMETERS_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="PARAMETER_TYPES" PARM_VALUE="MULTIFILE,MULTIFILE,FILENAME"/>
#!     <XFORM_PARM PARM_NAME="TRANSFORMER_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="WORKSPACE_FILE" PARM_VALUE="TurnRestrictions.fmw"/>
#!     <XFORM_PARM PARM_NAME="WORKSPACE_PARAMETERS" PARM_VALUE="SourceDataset_RoadLink,$(ROADS_INPUT)&lt;backslash&gt;Highways_Rrami_RoadLink_*.gml.gz,SourceDataset_TurnRestriction,$(ROADS_INPUT)&lt;backslash&gt;Highways_Rrami_TurnRestriction_*.gml.gz,DestDataset_GEOPACKAGE,$(DEST_FOLDER)&lt;backslash&gt;TurnRestriction.gpkg"/>
#!     <XFORM_PARM PARM_NAME="XFORMER_NAME" PARM_VALUE="TurnRestriction"/>
#! </TRANSFORMER>
#! <TRANSFORMER
#!   IDENTIFIER="80"
#!   TYPE="WorkspaceRunner"
#!   VERSION="2"
#!   POSITION="2366.7940625042611 -2071.6159375502816"
#!   BOUNDING_RECT="2366.7940625042611 -2071.6159375502816 -1 -1"
#!   ORDER="500000000000000"
#!   PARMS_EDITED="true"
#!   ENABLED="true"
#!   LAST_PARM_EDIT="18547"
#! >
#!     <OUTPUT_FEAT NAME="SUCCEEDED"/>
#!     <FEAT_COLLAPSED COLLAPSED="0"/>
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.count" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.name" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_dataset" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_total_features_written" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_failure_message" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <OUTPUT_FEAT NAME="FAILED"/>
#!     <FEAT_COLLAPSED COLLAPSED="1"/>
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.count" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.name" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_dataset" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_total_features_written" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_failure_message" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <OUTPUT_FEAT NAME="SUMMARY"/>
#!     <FEAT_COLLAPSED COLLAPSED="2"/>
#!     <XFORM_ATTR ATTR_NAME="_proc_count" IS_USER_CREATED="false" FEAT_INDEX="2" />
#!     <XFORM_ATTR ATTR_NAME="_processes{}" IS_USER_CREATED="false" FEAT_INDEX="2" />
#!     <XFORM_PARM PARM_NAME="BLOCKING" PARM_VALUE="Yes"/>
#!     <XFORM_PARM PARM_NAME="MAX_PROC" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="PARAMETERS_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="PARAMETER_TYPES" PARM_VALUE="MULTIFILE,MULTIFILE,FILENAME"/>
#!     <XFORM_PARM PARM_NAME="TRANSFORMER_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="WORKSPACE_FILE" PARM_VALUE="RestrictionForVehicles.fmw"/>
#!     <XFORM_PARM PARM_NAME="WORKSPACE_PARAMETERS" PARM_VALUE="SourceDataset_RoadLink,$(ROADS_INPUT)&lt;backslash&gt;Highways_Rrami_RoadLink_*.gml.gz,SourceDataset_GML,$(ROADS_INPUT)&lt;backslash&gt;Highways_Rrami_RestrictionForVehicles_*.gml.gz,DestDataset_GEOPACKAGE,$(DEST_FOLDER)&lt;backslash&gt;RestrictionForVehicles.gpkg"/>
#!     <XFORM_PARM PARM_NAME="XFORMER_NAME" PARM_VALUE="RestrictionForVehicles"/>
#! </TRANSFORMER>
#! <TRANSFORMER
#!   IDENTIFIER="88"
#!   TYPE="WorkspaceRunner"
#!   VERSION="2"
#!   POSITION="2370.7606625042608 -736.97293755028397"
#!   BOUNDING_RECT="2370.7606625042608 -736.97293755028397 -1 -1"
#!   ORDER="500000000000000"
#!   PARMS_EDITED="true"
#!   ENABLED="true"
#!   LAST_PARM_EDIT="18547"
#! >
#!     <OUTPUT_FEAT NAME="SUCCEEDED"/>
#!     <FEAT_COLLAPSED COLLAPSED="0"/>
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.count" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.name" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_dataset" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_total_features_written" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_failure_message" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <OUTPUT_FEAT NAME="FAILED"/>
#!     <FEAT_COLLAPSED COLLAPSED="1"/>
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.count" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.name" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_dataset" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_total_features_written" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_failure_message" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <OUTPUT_FEAT NAME="SUMMARY"/>
#!     <FEAT_COLLAPSED COLLAPSED="2"/>
#!     <XFORM_ATTR ATTR_NAME="_proc_count" IS_USER_CREATED="false" FEAT_INDEX="2" />
#!     <XFORM_ATTR ATTR_NAME="_processes{}" IS_USER_CREATED="false" FEAT_INDEX="2" />
#!     <XFORM_PARM PARM_NAME="BLOCKING" PARM_VALUE="Yes"/>
#!     <XFORM_PARM PARM_NAME="MAX_PROC" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="PARAMETERS_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="PARAMETER_TYPES" PARM_VALUE="MULTIFILE,MULTIFILE,MULTIFILE,MULTIFILE,FILENAME,FILENAME"/>
#!     <XFORM_PARM PARM_NAME="TRANSFORMER_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="WORKSPACE_FILE" PARM_VALUE="AssetManagement.fmw"/>
#!     <XFORM_PARM PARM_NAME="WORKSPACE_PARAMETERS" PARM_VALUE="SourceDataset_Maintenance,$(ROADS_INPUT)&lt;backslash&gt;Highways_Rrami_Maintenance_*.gml.gz,SourceDataset_Reinstatement,$(ROADS_INPUT)&lt;backslash&gt;Highways_Rrami_Reinstatement_*.gml.gz,SourceDataset_SpecialDesignation,$(ROADS_INPUT)&lt;backslash&gt;Highways_Rrami_SpecialDesignation_*.gml.gz,SourceDataset_Street,$(ROADS_INPUT)&lt;backslash&gt;Highways_Rrami_Street_*.gml.gz,DestDataset_AssetManagement,$(DEST_FOLDER)&lt;backslash&gt;AssetManagement_Roads.gpkg,DestDataset_SpDesignation,$(DEST_FOLDER)&lt;backslash&gt;SpDesignation_Roads.gpkg"/>
#!     <XFORM_PARM PARM_NAME="XFORMER_NAME" PARM_VALUE="AssetManagement_Roads"/>
#! </TRANSFORMER>
#! <TRANSFORMER
#!   IDENTIFIER="91"
#!   TYPE="WorkspaceRunner"
#!   VERSION="2"
#!   POSITION="2370.7606625042608 -1059.1019375502838"
#!   BOUNDING_RECT="2370.7606625042608 -1059.1019375502838 -1 -1"
#!   ORDER="500000000000000"
#!   PARMS_EDITED="true"
#!   ENABLED="true"
#!   LAST_PARM_EDIT="18547"
#! >
#!     <OUTPUT_FEAT NAME="SUCCEEDED"/>
#!     <FEAT_COLLAPSED COLLAPSED="0"/>
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.count" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.name" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_dataset" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_total_features_written" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_failure_message" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <OUTPUT_FEAT NAME="FAILED"/>
#!     <FEAT_COLLAPSED COLLAPSED="1"/>
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.count" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.name" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_dataset" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_total_features_written" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="_failure_message" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <OUTPUT_FEAT NAME="SUMMARY"/>
#!     <FEAT_COLLAPSED COLLAPSED="2"/>
#!     <XFORM_ATTR ATTR_NAME="_proc_count" IS_USER_CREATED="false" FEAT_INDEX="2" />
#!     <XFORM_ATTR ATTR_NAME="_processes{}" IS_USER_CREATED="false" FEAT_INDEX="2" />
#!     <XFORM_PARM PARM_NAME="BLOCKING" PARM_VALUE="Yes"/>
#!     <XFORM_PARM PARM_NAME="MAX_PROC" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="PARAMETERS_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="PARAMETER_TYPES" PARM_VALUE="MULTIFILE,MULTIFILE,MULTIFILE,MULTIFILE,FILENAME,FILENAME"/>
#!     <XFORM_PARM PARM_NAME="TRANSFORMER_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="WORKSPACE_FILE" PARM_VALUE="AssetManagement.fmw"/>
#!     <XFORM_PARM PARM_NAME="WORKSPACE_PARAMETERS" PARM_VALUE="SourceDataset_Maintenance,$(PATHS_INPUT)&lt;backslash&gt;Highways_Paths_Maintenance_*.gml.gz,SourceDataset_Reinstatement,$(PATHS_INPUT)&lt;backslash&gt;Highways_Paths_Reinstatement_*.gml.gz,SourceDataset_SpecialDesignation,$(PATHS_INPUT)&lt;backslash&gt;Highways_Paths_SpecialDesignation_*.gml.gz,SourceDataset_Street,$(PATHS_INPUT)&lt;backslash&gt;Highways_Paths_Street_*.gml.gz,DestDataset_AssetManagement,$(DEST_FOLDER)&lt;backslash&gt;AssetManagement_Paths.gpkg,DestDataset_SpDesignation,$(DEST_FOLDER)&lt;backslash&gt;SpDesignation_Paths.gpkg"/>
#!     <XFORM_PARM PARM_NAME="XFORMER_NAME" PARM_VALUE="AssetManagement_Paths"/>
#! </TRANSFORMER>
#! <TRANSFORMER
#!   IDENTIFIER="79"
#!   TYPE="FeatureReader"
#!   VERSION="11"
#!   POSITION="1805.8440625042631 -33.557027503693163"
#!   BOUNDING_RECT="1805.8440625042631 -33.557027503693163 -1 -1"
#!   ORDER="500000000000180"
#!   PARMS_EDITED="true"
#!   ENABLED="true"
#!   LAST_PARM_EDIT="18547"
#! >
#!     <OUTPUT_FEAT NAME="&lt;SCHEMA&gt;"/>
#!     <FEAT_COLLAPSED COLLAPSED="0"/>
#!     <XFORM_ATTR ATTR_NAME="fme_feature_type_name" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="attribute{}.name" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="attribute{}.fme_data_type" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="attribute{}.native_data_type" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="fme_format_short_name" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="fme_format_long_name" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="fme_schema_handling" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <OUTPUT_FEAT NAME="PATH"/>
#!     <FEAT_COLLAPSED COLLAPSED="1"/>
#!     <XFORM_ATTR ATTR_NAME="path_unix" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="path_windows" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="path_rootname" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="path_filename" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="path_extension" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="path_filesize" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="path_ownername" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="path_readonly" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="path_modified_date" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="path_created_date" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="path_accessed_date" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="path_directory_unix" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="path_directory_windows" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="path_type" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="fme_geometry{0}" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="fme_basename" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <XFORM_ATTR ATTR_NAME="fme_dataset" IS_USER_CREATED="false" FEAT_INDEX="1" />
#!     <OUTPUT_FEAT NAME="&lt;OTHER&gt;"/>
#!     <FEAT_COLLAPSED COLLAPSED="2"/>
#!     <OUTPUT_FEAT NAME="INITIATOR"/>
#!     <FEAT_COLLAPSED COLLAPSED="3"/>
#!     <XFORM_ATTR ATTR_NAME="_matched_records" IS_USER_CREATED="false" FEAT_INDEX="3" />
#!     <OUTPUT_FEAT NAME="&lt;REJECTED&gt;"/>
#!     <FEAT_COLLAPSED COLLAPSED="4"/>
#!     <XFORM_ATTR ATTR_NAME="_reader_error" IS_USER_CREATED="false" FEAT_INDEX="4" />
#!     <XFORM_PARM PARM_NAME="ATTRIBUTES" PARM_VALUE="PATH,&quot;path_unix,path_windows,path_rootname,path_filename,path_extension,path_filesize,path_ownername,path_readonly,path_modified_date,path_created_date,path_accessed_date,path_directory_unix,path_directory_windows,path_type,fme_geometry{0},fme_basename,fme_dataset&quot;"/>
#!     <XFORM_PARM PARM_NAME="ATTRS_TO_EXPOSE" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="ATTR_ACCUM_MODE" PARM_VALUE="Only Use Result"/>
#!     <XFORM_PARM PARM_NAME="ATTR_CONFLICT_RES" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="ATTR_PREFIX" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="AVAILABLE_FEATURE_TYPES" PARM_VALUE="_FEATUREREADER_OPTIONAL_FTTR_%PATH"/>
#!     <XFORM_PARM PARM_NAME="CACHE_TIMEOUT_HRS" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="COMBINE_GEOM" PARM_VALUE="Use Result"/>
#!     <XFORM_PARM PARM_NAME="CONSTRAINTS_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="COORDSYS" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="DATASET" PARM_VALUE="$(MASTER_FILES)"/>
#!     <XFORM_PARM PARM_NAME="DYNGROUP_0" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="ENABLE_CACHE" PARM_VALUE="NO"/>
#!     <XFORM_PARM PARM_NAME="FEATURETYPES" PARM_VALUE="PATH"/>
#!     <XFORM_PARM PARM_NAME="FORMAT" PARM_VALUE="PATH"/>
#!     <XFORM_PARM PARM_NAME="FORMAT_DIRECTIVES" PARM_VALUE="META_MACROS,SourceOFFSET_DATETIME&lt;comma&gt;&lt;comma&gt;SourceGLOB_PATTERN&lt;comma&gt;*&lt;comma&gt;SourceRECURSE_DIRECTORIES&lt;comma&gt;NO&lt;comma&gt;SourceTYPE&lt;comma&gt;ANY&lt;comma&gt;SourceRETRIEVE_FILE_PROPERTIES&lt;comma&gt;NO&lt;comma&gt;SourceEXPOSE_ATTRS_GROUP&lt;comma&gt;FME_DISCLOSURE_OPEN&lt;comma&gt;SourcePATH_EXPOSE_FORMAT_ATTRS&lt;comma&gt;&lt;quote&gt;fme_basename&lt;comma&gt;char&lt;openparen&gt;50&lt;closeparen&gt;&lt;space&gt;fme_dataset&lt;comma&gt;char&lt;openparen&gt;50&lt;closeparen&gt;&lt;quote&gt;,METAFILE,PATH"/>
#!     <XFORM_PARM PARM_NAME="FORMAT_PARAMS" PARM_VALUE="PATH_EXPOSE_ATTRS_GROUP,&quot;OPTIONAL DISCLOSUREGROUP PATH_EXPOSE_FORMAT_ATTRS&quot;,PATH&lt;space&gt;Schema&lt;space&gt;Attributes,PATH_RECURSE_DIRECTORIES,&quot;OPTIONAL CHOICE YES%NO&quot;,PATH&lt;space&gt;Recurse&lt;space&gt;Into&lt;space&gt;Subfolders:,PATH_TYPE,&quot;OPTIONAL LOOKUP_CHOICE Any,ANY%Directory,DIRECTORY%File,FILE&quot;,PATH&lt;space&gt;Allowed&lt;space&gt;Path&lt;space&gt;Type:,PATH_GLOB_PATTERN,&quot;OPTIONAL TEXT_ENCODED&quot;,PATH&lt;space&gt;Path&lt;space&gt;Filter:,PATH_OFFSET_DATETIME,&quot;OPTIONAL NO_EDIT TEXT&quot;,PATH&lt;space&gt;,PATH_RETRIEVE_FILE_PROPERTIES,&quot;OPTIONAL CHOICE YES%NO&quot;,PATH&lt;space&gt;Retrieve&lt;space&gt;file&lt;space&gt;properties:,PATH_PATH_EXPOSE_FORMAT_ATTRS,&quot;OPTIONAL LITERAL EXPOSED_ATTRS PATH%Source&quot;,PATH&lt;space&gt;Additional&lt;space&gt;Attributes&lt;space&gt;to&lt;space&gt;Expose:"/>
#!     <XFORM_PARM PARM_NAME="FTTR_SEPARATOR" PARM_VALUE="SPACE"/>
#!     <XFORM_PARM PARM_NAME="GENERIC_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="INTERACT" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="MAX_FEATURES" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="MERGE_HANDLING_GROUP" PARM_VALUE="FME_DISCLOSURE_CLOSED"/>
#!     <XFORM_PARM PARM_NAME="OUTPUTPORTS_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="OUTPUT_FEATURES_DISPLAY" PARM_VALUE="Schema and Data Features"/>
#!     <XFORM_PARM PARM_NAME="OUTPUT_FEATURES_GROUP" PARM_VALUE="FME_DISCLOSURE_OPEN"/>
#!     <XFORM_PARM PARM_NAME="OUTPUT_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="OUTPUT_PORTS_MODE" PARM_VALUE="PORTS_FROM_FTTR"/>
#!     <XFORM_PARM PARM_NAME="PATH_EXPOSE_ATTRS_GROUP" PARM_VALUE="FME_DISCLOSURE_OPEN"/>
#!     <XFORM_PARM PARM_NAME="PATH_GLOB_PATTERN" PARM_VALUE="*"/>
#!     <XFORM_PARM PARM_NAME="PATH_OFFSET_DATETIME" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="PATH_PATH_EXPOSE_FORMAT_ATTRS" PARM_VALUE="fme_basename,char(50) fme_dataset,char(50)"/>
#!     <XFORM_PARM PARM_NAME="PATH_RECURSE_DIRECTORIES" PARM_VALUE="NO"/>
#!     <XFORM_PARM PARM_NAME="PATH_RETRIEVE_FILE_PROPERTIES" PARM_VALUE="NO"/>
#!     <XFORM_PARM PARM_NAME="PATH_TYPE" PARM_VALUE="ANY"/>
#!     <XFORM_PARM PARM_NAME="PORTS_FROM_FTTR" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="READER_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="READ_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="SELECTED_PORTS" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="SINGLE_PORT" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="SUPPORTED_SPATIAL_INTERACTIONS" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="TRANSFORMER_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="WHERE" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="XFORMER_NAME" PARM_VALUE="FeatureReader"/>
#! </TRANSFORMER>
#! <TRANSFORMER
#!   IDENTIFIER="81"
#!   TYPE="FeatureWriter"
#!   VERSION="0"
#!   POSITION="2370.7606625042627 -213.55702750369306"
#!   BOUNDING_RECT="2370.7606625042627 -213.55702750369306 -1 -1"
#!   ORDER="500000000000183"
#!   PARMS_EDITED="true"
#!   ENABLED="true"
#!   LAST_PARM_EDIT="18547"
#! >
#!     <OUTPUT_FEAT NAME="SUMMARY"/>
#!     <FEAT_COLLAPSED COLLAPSED="0"/>
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.count" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_feature_type{}.name" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_dataset" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="_total_features_written" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_PARM PARM_NAME="COORDSYS" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="DATASET" PARM_VALUE="$(DEST_FOLDER)"/>
#!     <XFORM_PARM PARM_NAME="DATASET_ATTR" PARM_VALUE="_dataset"/>
#!     <XFORM_PARM PARM_NAME="DYNGROUP_0" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="FEATURE_TYPES_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="FEATURE_TYPE_LIST_ATTR" PARM_VALUE="_feature_type"/>
#!     <XFORM_PARM PARM_NAME="FILECOPY_COORDINATE_SYSTEM_GRANULARITY" PARM_VALUE="FEATURE"/>
#!     <XFORM_PARM PARM_NAME="FILECOPY_COPY_SOURCE_DIRECTORY" PARM_VALUE="NO"/>
#!     <XFORM_PARM PARM_NAME="FILECOPY_COPY_SUBDIRECTORIES" PARM_VALUE="YES"/>
#!     <XFORM_PARM PARM_NAME="FILECOPY_DESTINATION_DATASETTYPE_VALIDATION" PARM_VALUE="Yes"/>
#!     <XFORM_PARM PARM_NAME="FILECOPY_FAIL_INVALID_DESTINATION" PARM_VALUE="NO"/>
#!     <XFORM_PARM PARM_NAME="FILECOPY_FAIL_NONEXISTENT_SOURCE" PARM_VALUE="NO"/>
#!     <XFORM_PARM PARM_NAME="FILECOPY_FILE_OPERATION" PARM_VALUE="COPY"/>
#!     <XFORM_PARM PARM_NAME="FILECOPY_MIME_TYPE" PARM_VALUE="text/plain"/>
#!     <XFORM_PARM PARM_NAME="FILECOPY_OVERWRITE_FILE" PARM_VALUE="YES"/>
#!     <XFORM_PARM PARM_NAME="FORMAT" PARM_VALUE="FILECOPY"/>
#!     <XFORM_PARM PARM_NAME="FORMAT_DIRECTIVES" PARM_VALUE="RUNTIME_MACROS,FILE_OPERATION&lt;comma&gt;COPY&lt;comma&gt;OVERWRITE_FILE&lt;comma&gt;YES&lt;comma&gt;COPY_SOURCE_DIRECTORY&lt;comma&gt;NO&lt;comma&gt;COPY_SUBDIRECTORIES&lt;comma&gt;YES&lt;comma&gt;FAIL_NONEXISTENT_SOURCE&lt;comma&gt;NO&lt;comma&gt;FAIL_INVALID_DESTINATION&lt;comma&gt;NO&lt;comma&gt;MIME_TYPE&lt;comma&gt;text&lt;solidus&gt;plain&lt;comma&gt;DESTINATION_DATASETTYPE_VALIDATION&lt;comma&gt;Yes&lt;comma&gt;COORDINATE_SYSTEM_GRANULARITY&lt;comma&gt;FEATURE,METAFILE,FILECOPY"/>
#!     <XFORM_PARM PARM_NAME="FORMAT_PARAMS" PARM_VALUE="FILECOPY_FAIL_INVALID_DESTINATION,&quot;OPTIONAL CHOICE YES%NO&quot;,FILECOPY&lt;space&gt;Error&lt;space&gt;on&lt;space&gt;Invalid&lt;space&gt;Destination:,FILECOPY_MIME_TYPE,&quot;OPTIONAL STRING_OR_CHOICE application/json%application/pdf%application/x-dvi%application/x-shockwave-flash%application/x-rar-compressed%application/x-tar%application/zip%audio/mpeg%audio/vnd.rn-realaudio%audio/x-ms-wma%audio/x-wav%image/gif%image/jpeg%image/png%image/svg+xml%image/tiff%text/css%text/csv%text/html%text/plain%text/xml%video/mp4%video/mpeg%video/quicktime%video/x-ms-wmv&quot;,FILECOPY&lt;space&gt;MIME&lt;space&gt;Type:,FILECOPY_COPY_SUBDIRECTORIES,&quot;OPTIONAL CHOICE YES%NO&quot;,FILECOPY&lt;space&gt;Copy&lt;space&gt;Subfolders:,FILECOPY_FAIL_NONEXISTENT_SOURCE,&quot;OPTIONAL CHOICE YES%NO&quot;,FILECOPY&lt;space&gt;Error&lt;space&gt;on&lt;space&gt;Non-Existent&lt;space&gt;Source:,FILECOPY_COORDINATE_SYSTEM_GRANULARITY,&quot;OPTIONAL NO_EDIT TEXT&quot;,FILECOPY&lt;space&gt;,FILECOPY_OVERWRITE_FILE,&quot;OPTIONAL CHOICE YES%NO&quot;,FILECOPY&lt;space&gt;Overwrite&lt;space&gt;Existing&lt;space&gt;File:,FILECOPY_FILE_OPERATION,&quot;OPTIONAL LOOKUP_CHOICE Copy,COPY%Move,MOVE&quot;,FILECOPY&lt;space&gt;File&lt;space&gt;Operation:,FILECOPY_DESTINATION_DATASETTYPE_VALIDATION,&quot;OPTIONAL NO_EDIT TEXT&quot;,FILECOPY&lt;space&gt;,FILECOPY_COPY_SOURCE_DIRECTORY,&quot;OPTIONAL CHOICE YES%NO&quot;,FILECOPY&lt;space&gt;Copy&lt;space&gt;Source&lt;space&gt;Folder:"/>
#!     <XFORM_PARM PARM_NAME="MORE_SUMMARY_ATTRS" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="NO_OUTPUT_PORTS" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="OUTPUTPORTS_GROUP" PARM_VALUE="NO"/>
#!     <XFORM_PARM PARM_NAME="OUTPUT_PORTS" PARM_VALUE="&quot;&quot;"/>
#!     <XFORM_PARM PARM_NAME="OUTPUT_PORTS_MODE" PARM_VALUE="NO_OUTPUT_PORTS"/>
#!     <XFORM_PARM PARM_NAME="PER_EACH_INPUT" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="SELECTED_PORTS" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="SUMMARY_ATTRS_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="TOTAL_FEATURES_WRITTEN_ATTR" PARM_VALUE="_total_features_written"/>
#!     <XFORM_PARM PARM_NAME="TRANSFORMER_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="WRITER_DIRECTIVES" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="WRITER_FEATURE_TYPE_PARAMS" PARM_VALUE="filecopy:filecopy,ftp_feature_type_name,filecopy,ftp_writer,FILECOPY,ftp_dynamic_schema,no,ftp_dynamic_feature_type_name_type,DYN_SCHEMA_PROP_AUTO,ftp_dynamic_geometry_type,DYN_SCHEMA_PROP_AUTO,ftp_dynamic_schema_def_name_type,DYN_SCHEMA_PROP_AUTO,ftp_dynamic_schema_sources,&lt;lt&gt;lt&lt;gt&gt;Unused&lt;lt&gt;gt&lt;gt&gt;,ftp_attribute_source,1,ftp_user_attributes,filecopy_source_dataset&lt;comma&gt;char&lt;lt&gt;openparen&lt;gt&gt;512&lt;lt&gt;closeparen&lt;gt&gt;&lt;comma&gt;filecopy_dest_dataset&lt;comma&gt;char&lt;lt&gt;openparen&lt;gt&gt;512&lt;lt&gt;closeparen&lt;gt&gt;&lt;comma&gt;filecopy_dest_filename&lt;comma&gt;char&lt;lt&gt;openparen&lt;gt&gt;128&lt;lt&gt;closeparen&lt;gt&gt;,ftp_user_attribute_values,&lt;comma&gt;&lt;comma&gt;"/>
#!     <XFORM_PARM PARM_NAME="WRITER_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="WRITER_METAFILE" PARM_VALUE="ATTRIBUTE_CASE,ANY,ATTRIBUTE_INVALID_CHARS,,ATTRIBUTE_LENGTH,512,ATTR_TYPE_MAP,char&lt;openparen&gt;width&lt;closeparen&gt;&lt;comma&gt;fme_varchar&lt;openparen&gt;width&lt;closeparen&gt;&lt;comma&gt;char&lt;openparen&gt;width&lt;closeparen&gt;&lt;comma&gt;fme_varbinary&lt;openparen&gt;width&lt;closeparen&gt;&lt;comma&gt;char&lt;openparen&gt;width&lt;closeparen&gt;&lt;comma&gt;fme_char&lt;openparen&gt;width&lt;closeparen&gt;&lt;comma&gt;char&lt;openparen&gt;width&lt;closeparen&gt;&lt;comma&gt;fme_binary&lt;openparen&gt;width&lt;closeparen&gt;&lt;comma&gt;string&lt;comma&gt;fme_buffer&lt;comma&gt;string&lt;comma&gt;fme_binarybuffer&lt;comma&gt;string&lt;comma&gt;fme_xml&lt;comma&gt;string&lt;comma&gt;fme_json&lt;comma&gt;datetime&lt;comma&gt;fme_datetime&lt;comma&gt;time&lt;comma&gt;fme_time&lt;comma&gt;date&lt;comma&gt;fme_date&lt;comma&gt;real64&lt;comma&gt;fme_real64&lt;comma&gt;real32&lt;comma&gt;fme_real32&lt;comma&gt;&lt;quote&gt;number&lt;openparen&gt;width&lt;comma&gt;decimal&lt;closeparen&gt;&lt;quote&gt;&lt;comma&gt;&lt;quote&gt;fme_decimal&lt;openparen&gt;width&lt;comma&gt;decimal&lt;closeparen&gt;&lt;quote&gt;&lt;comma&gt;int32&lt;comma&gt;fme_int32&lt;comma&gt;&lt;quote&gt;number&lt;openparen&gt;11&lt;comma&gt;0&lt;closeparen&gt;&lt;quote&gt;&lt;comma&gt;fme_uint32&lt;comma&gt;&lt;quote&gt;number&lt;openparen&gt;20&lt;comma&gt;0&lt;closeparen&gt;&lt;quote&gt;&lt;comma&gt;fme_int64&lt;comma&gt;&lt;quote&gt;number&lt;openparen&gt;20&lt;comma&gt;0&lt;closeparen&gt;&lt;quote&gt;&lt;comma&gt;fme_uint64&lt;comma&gt;logical&lt;comma&gt;fme_boolean&lt;comma&gt;int16&lt;comma&gt;fme_int16&lt;comma&gt;int32&lt;comma&gt;fme_uint16&lt;comma&gt;int16&lt;comma&gt;fme_int8&lt;comma&gt;int16&lt;comma&gt;fme_uint8,DEST_ILLEGAL_ATTR_LIST,,FEATURE_TYPE_CASE,ANY,FEATURE_TYPE_INVALID_CHARS,,FEATURE_TYPE_LENGTH,0,FEATURE_TYPE_LENGTH_INCLUDES_PREFIX,false,FEATURE_TYPE_RESERVED_WORDS,,FORMAT_METAFILE,$(FME_HOME_ENCODED)metafile&lt;backslash&gt;FILECOPY.fmf,FORMAT_NAME,FILECOPY,GEOM_MAP,filecopy_none&lt;comma&gt;fme_no_geom&lt;comma&gt;filecopy_none&lt;comma&gt;fme_point&lt;comma&gt;filecopy_none&lt;comma&gt;fme_line&lt;comma&gt;filecopy_none&lt;comma&gt;fme_polygon&lt;comma&gt;filecopy_none&lt;comma&gt;fme_arc&lt;comma&gt;filecopy_none&lt;comma&gt;fme_text&lt;comma&gt;filecopy_none&lt;comma&gt;fme_ellipse&lt;comma&gt;filecopy_none&lt;comma&gt;fme_rectangle&lt;comma&gt;filecopy_none&lt;comma&gt;fme_rounded_rectangle&lt;comma&gt;filecopy_none&lt;comma&gt;fme_collection&lt;comma&gt;filecopy_none&lt;comma&gt;fme_surface&lt;comma&gt;filecopy_none&lt;comma&gt;fme_solid&lt;comma&gt;filecopy_none&lt;comma&gt;fme_raster&lt;comma&gt;filecopy_none&lt;comma&gt;fme_point_cloud&lt;comma&gt;filecopy_none&lt;comma&gt;fme_feature_table,READER_ATTR_INDEX_TYPES,,SOURCE,no,SUPPORTS_FEAT_TYPE_FANOUT,no,SUPPORTS_MULTI_GEOM,yes,WORKBENCH_CANNED_SCHEMA,filecopy.sch,WRITER,FILECOPY,WRITER_ATTR_INDEX_TYPES,,WRITER_DEFLINE_PARMS,,WRITER_DEF_LINE_TEMPLATE,&lt;opencurly&gt;FME_GEN_GROUP_NAME&lt;closecurly&gt;,WRITER_FORMAT_PARAMETER,WRITER_FEATURE_TYPE_EDITING&lt;comma&gt;NO&lt;comma&gt;MIME_TYPE&lt;comma&gt;text&lt;solidus&gt;plain&lt;comma&gt;READER_FEATURE_TYPE_EDITING&lt;comma&gt;NO&lt;comma&gt;FEATURE_TYPE_NAME&lt;comma&gt;FILECOPY&lt;comma&gt;FEATURE_TYPE_DEFAULT_NAME&lt;comma&gt;File1&lt;comma&gt;WRITER_DATASET_HINT&lt;comma&gt;&lt;quote&gt;Specify&lt;space&gt;a&lt;space&gt;folder&lt;space&gt;for&lt;space&gt;the&lt;space&gt;File&lt;space&gt;Copy&lt;quote&gt;,WRITER_HAS_DEFLINE_ATTRS,yes"/>
#!     <XFORM_PARM PARM_NAME="XFORMER_NAME" PARM_VALUE="FeatureWriter"/>
#! </TRANSFORMER>
#! <TRANSFORMER
#!   IDENTIFIER="84"
#!   TYPE="AttributeManager"
#!   VERSION="2"
#!   POSITION="2370.7606625042627 -33.557027503693163"
#!   BOUNDING_RECT="2370.7606625042627 -33.557027503693163 -1 -1"
#!   ORDER="500000000000184"
#!   PARMS_EDITED="true"
#!   ENABLED="true"
#!   LAST_PARM_EDIT="18547"
#! >
#!     <OUTPUT_FEAT NAME="OUTPUT"/>
#!     <FEAT_COLLAPSED COLLAPSED="0"/>
#!     <XFORM_ATTR ATTR_NAME="filecopy_source_dataset" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="filecopy_dest_filename" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_ATTR ATTR_NAME="filecopy_dest_dataset" IS_USER_CREATED="false" FEAT_INDEX="0" />
#!     <XFORM_PARM PARM_NAME="ATTRIBUTE_GRP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="ATTRIBUTE_HANDLING" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="ATTR_TABLE" PARM_VALUE="path_unix path_unix  REMOVE path_windows filecopy_source_dataset  RENAME_SET_VALUE path_rootname path_rootname  REMOVE path_filename filecopy_dest_filename  RENAME_SET_VALUE path_extension path_extension  REMOVE path_filesize path_filesize  REMOVE path_ownername path_ownername  REMOVE path_readonly path_readonly  REMOVE path_modified_date path_modified_date  REMOVE path_created_date path_created_date  REMOVE path_accessed_date path_accessed_date  REMOVE path_directory_unix path_directory_unix  REMOVE path_directory_windows path_directory_windows  REMOVE path_type path_type  REMOVE fme_geometry&lt;opencurly&gt;0&lt;closecurly&gt; fme_geometry&lt;opencurly&gt;0&lt;closecurly&gt;  REMOVE fme_basename fme_basename  REMOVE fme_dataset fme_dataset  REMOVE fme_geometry&lt;opencurly&gt;&lt;closecurly&gt; fme_geometry&lt;opencurly&gt;&lt;closecurly&gt;  REMOVE  filecopy_dest_dataset $(DEST_FOLDER)&lt;backslash&gt; SET_TO"/>
#!     <XFORM_PARM PARM_NAME="MULTI_FEATURE_MODE" PARM_VALUE="NO"/>
#!     <XFORM_PARM PARM_NAME="NULL_ATTR_MODE_DISPLAY" PARM_VALUE="No Substitution"/>
#!     <XFORM_PARM PARM_NAME="NULL_ATTR_VALUE" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="NUM_PRIOR_FEATURES" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="NUM_SUBSEQUENT_FEATURES" PARM_VALUE="&lt;Unused&gt;"/>
#!     <XFORM_PARM PARM_NAME="TRANSFORMER_GROUP" PARM_VALUE=""/>
#!     <XFORM_PARM PARM_NAME="XFORMER_NAME" PARM_VALUE="AttributeManager"/>
#! </TRANSFORMER>
#! </TRANSFORMERS>
#! <FEAT_LINKS>
#! <FEAT_LINK
#!   IDENTIFIER="152"
#!   SOURCE_NODE="2"
#!   TARGET_NODE="79"
#!   SOURCE_PORT_DESC="fo 0 CREATED"
#!   TARGET_PORT_DESC="fi 0 INITIATOR"
#!   ENABLED="true"
#!   EXECUTION_IDX="0"
#!   HIDDEN="false"
#!   EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#!   IDENTIFIER="30"
#!   SOURCE_NODE="3"
#!   TARGET_NODE="4"
#!   SOURCE_PORT_DESC="fo 0 SUCCEEDED"
#!   TARGET_PORT_DESC="fi 0 "
#!   ENABLED="true"
#!   EXECUTION_IDX="0"
#!   HIDDEN="false"
#!   EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#!   IDENTIFIER="31"
#!   SOURCE_NODE="4"
#!   TARGET_NODE="5"
#!   SOURCE_PORT_DESC="fo 0 SUCCEEDED"
#!   TARGET_PORT_DESC="fi 0 "
#!   ENABLED="true"
#!   EXECUTION_IDX="0"
#!   HIDDEN="false"
#!   EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#!   IDENTIFIER="32"
#!   SOURCE_NODE="5"
#!   TARGET_NODE="6"
#!   SOURCE_PORT_DESC="fo 0 SUCCEEDED"
#!   TARGET_PORT_DESC="fi 0 "
#!   ENABLED="true"
#!   EXECUTION_IDX="0"
#!   HIDDEN="false"
#!   EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#!   IDENTIFIER="33"
#!   SOURCE_NODE="6"
#!   TARGET_NODE="7"
#!   SOURCE_PORT_DESC="fo 0 SUCCEEDED"
#!   TARGET_PORT_DESC="fi 0 "
#!   ENABLED="true"
#!   EXECUTION_IDX="0"
#!   HIDDEN="false"
#!   EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#!   IDENTIFIER="34"
#!   SOURCE_NODE="7"
#!   TARGET_NODE="8"
#!   SOURCE_PORT_DESC="fo 0 SUCCEEDED"
#!   TARGET_PORT_DESC="fi 0 "
#!   ENABLED="true"
#!   EXECUTION_IDX="0"
#!   HIDDEN="false"
#!   EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#!   IDENTIFIER="35"
#!   SOURCE_NODE="8"
#!   TARGET_NODE="9"
#!   SOURCE_PORT_DESC="fo 0 SUCCEEDED"
#!   TARGET_PORT_DESC="fi 0 "
#!   ENABLED="true"
#!   EXECUTION_IDX="0"
#!   HIDDEN="false"
#!   EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#!   IDENTIFIER="36"
#!   SOURCE_NODE="9"
#!   TARGET_NODE="10"
#!   SOURCE_PORT_DESC="fo 0 SUCCEEDED"
#!   TARGET_PORT_DESC="fi 0 "
#!   ENABLED="true"
#!   EXECUTION_IDX="0"
#!   HIDDEN="false"
#!   EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#!   IDENTIFIER="37"
#!   SOURCE_NODE="10"
#!   TARGET_NODE="11"
#!   SOURCE_PORT_DESC="fo 0 SUCCEEDED"
#!   TARGET_PORT_DESC="fi 0 "
#!   ENABLED="true"
#!   EXECUTION_IDX="0"
#!   HIDDEN="false"
#!   EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#!   IDENTIFIER="38"
#!   SOURCE_NODE="11"
#!   TARGET_NODE="18"
#!   SOURCE_PORT_DESC="fo 0 SUCCEEDED"
#!   TARGET_PORT_DESC="fi 0 "
#!   ENABLED="true"
#!   EXECUTION_IDX="0"
#!   HIDDEN="false"
#!   EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#!   IDENTIFIER="134"
#!   SOURCE_NODE="12"
#!   TARGET_NODE="22"
#!   SOURCE_PORT_DESC="fo 0 SUCCEEDED"
#!   TARGET_PORT_DESC="fi 0 "
#!   ENABLED="true"
#!   EXECUTION_IDX="0"
#!   HIDDEN="false"
#!   EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#!   IDENTIFIER="44"
#!   SOURCE_NODE="18"
#!   TARGET_NODE="19"
#!   SOURCE_PORT_DESC="fo 0 SUCCEEDED"
#!   TARGET_PORT_DESC="fi 0 "
#!   ENABLED="true"
#!   EXECUTION_IDX="0"
#!   HIDDEN="false"
#!   EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#!   IDENTIFIER="132"
#!   SOURCE_NODE="19"
#!   TARGET_NODE="20"
#!   SOURCE_PORT_DESC="fo 0 SUCCEEDED"
#!   TARGET_PORT_DESC="fi 0 "
#!   ENABLED="true"
#!   EXECUTION_IDX="0"
#!   HIDDEN="false"
#!   EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#!   IDENTIFIER="46"
#!   SOURCE_NODE="20"
#!   TARGET_NODE="21"
#!   SOURCE_PORT_DESC="fo 0 SUCCEEDED"
#!   TARGET_PORT_DESC="fi 0 "
#!   ENABLED="true"
#!   EXECUTION_IDX="0"
#!   HIDDEN="false"
#!   EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#!   IDENTIFIER="47"
#!   SOURCE_NODE="21"
#!   TARGET_NODE="12"
#!   SOURCE_PORT_DESC="fo 0 SUCCEEDED"
#!   TARGET_PORT_DESC="fi 0 "
#!   ENABLED="true"
#!   EXECUTION_IDX="0"
#!   HIDDEN="false"
#!   EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#!   IDENTIFIER="48"
#!   SOURCE_NODE="22"
#!   TARGET_NODE="23"
#!   SOURCE_PORT_DESC="fo 0 SUCCEEDED"
#!   TARGET_PORT_DESC="fi 0 "
#!   ENABLED="true"
#!   EXECUTION_IDX="0"
#!   HIDDEN="false"
#!   EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#!   IDENTIFIER="49"
#!   SOURCE_NODE="23"
#!   TARGET_NODE="26"
#!   SOURCE_PORT_DESC="fo 0 SUCCEEDED"
#!   TARGET_PORT_DESC="fi 0 "
#!   ENABLED="true"
#!   EXECUTION_IDX="0"
#!   HIDDEN="false"
#!   EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#!   IDENTIFIER="29"
#!   SOURCE_NODE="24"
#!   TARGET_NODE="3"
#!   SOURCE_PORT_DESC="fo 0 SUCCEEDED"
#!   TARGET_PORT_DESC="fi 0 "
#!   ENABLED="true"
#!   EXECUTION_IDX="0"
#!   HIDDEN="false"
#!   EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#!   IDENTIFIER="50"
#!   SOURCE_NODE="25"
#!   TARGET_NODE="88"
#!   SOURCE_PORT_DESC="fo 0 SUCCEEDED"
#!   TARGET_PORT_DESC="fi 0 "
#!   ENABLED="true"
#!   EXECUTION_IDX="0"
#!   HIDDEN="false"
#!   EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#!   IDENTIFIER="51"
#!   SOURCE_NODE="26"
#!   TARGET_NODE="27"
#!   SOURCE_PORT_DESC="fo 0 SUCCEEDED"
#!   TARGET_PORT_DESC="fi 0 "
#!   ENABLED="true"
#!   EXECUTION_IDX="0"
#!   HIDDEN="false"
#!   EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#!   IDENTIFIER="52"
#!   SOURCE_NODE="27"
#!   TARGET_NODE="25"
#!   SOURCE_PORT_DESC="fo 0 SUCCEEDED"
#!   TARGET_PORT_DESC="fi 0 "
#!   ENABLED="true"
#!   EXECUTION_IDX="0"
#!   HIDDEN="false"
#!   EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#!   IDENTIFIER="82"
#!   SOURCE_NODE="77"
#!   TARGET_NODE="78"
#!   SOURCE_PORT_DESC="fo 0 SUCCEEDED"
#!   TARGET_PORT_DESC="fi 0 "
#!   ENABLED="true"
#!   EXECUTION_IDX="0"
#!   HIDDEN="false"
#!   EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#!   IDENTIFIER="83"
#!   SOURCE_NODE="78"
#!   TARGET_NODE="80"
#!   SOURCE_PORT_DESC="fo 0 SUCCEEDED"
#!   TARGET_PORT_DESC="fi 0 "
#!   ENABLED="true"
#!   EXECUTION_IDX="0"
#!   HIDDEN="false"
#!   EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#!   IDENTIFIER="92"
#!   SOURCE_NODE="81"
#!   TARGET_NODE="24"
#!   SOURCE_PORT_DESC="fo 0 SUMMARY"
#!   TARGET_PORT_DESC="fi 0 "
#!   ENABLED="true"
#!   EXECUTION_IDX="0"
#!   HIDDEN="false"
#!   EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#!   IDENTIFIER="89"
#!   SOURCE_NODE="84"
#!   TARGET_NODE="81"
#!   SOURCE_PORT_DESC="fo 0 OUTPUT"
#!   TARGET_PORT_DESC="fi 0 filecopy"
#!   ENABLED="true"
#!   EXECUTION_IDX="0"
#!   HIDDEN="false"
#!   EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#!   IDENTIFIER="93"
#!   SOURCE_NODE="88"
#!   TARGET_NODE="91"
#!   SOURCE_PORT_DESC="fo 0 SUCCEEDED"
#!   TARGET_PORT_DESC="fi 0 "
#!   ENABLED="true"
#!   EXECUTION_IDX="0"
#!   HIDDEN="false"
#!   EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#!   IDENTIFIER="95"
#!   SOURCE_NODE="91"
#!   TARGET_NODE="77"
#!   SOURCE_PORT_DESC="fo 0 SUCCEEDED"
#!   TARGET_PORT_DESC="fi 0 "
#!   ENABLED="true"
#!   EXECUTION_IDX="0"
#!   HIDDEN="false"
#!   EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#!   IDENTIFIER="54"
#!   SOURCE_NODE="3"
#!   TARGET_NODE="4"
#!   SOURCE_PORT_DESC="fo 1 FAILED"
#!   TARGET_PORT_DESC="fi 0 "
#!   ENABLED="true"
#!   EXECUTION_IDX="0"
#!   HIDDEN="false"
#!   EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#!   IDENTIFIER="55"
#!   SOURCE_NODE="4"
#!   TARGET_NODE="5"
#!   SOURCE_PORT_DESC="fo 1 FAILED"
#!   TARGET_PORT_DESC="fi 0 "
#!   ENABLED="true"
#!   EXECUTION_IDX="0"
#!   HIDDEN="false"
#!   EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#!   IDENTIFIER="56"
#!   SOURCE_NODE="5"
#!   TARGET_NODE="6"
#!   SOURCE_PORT_DESC="fo 1 FAILED"
#!   TARGET_PORT_DESC="fi 0 "
#!   ENABLED="true"
#!   EXECUTION_IDX="0"
#!   HIDDEN="false"
#!   EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#!   IDENTIFIER="57"
#!   SOURCE_NODE="6"
#!   TARGET_NODE="7"
#!   SOURCE_PORT_DESC="fo 1 FAILED"
#!   TARGET_PORT_DESC="fi 0 "
#!   ENABLED="true"
#!   EXECUTION_IDX="0"
#!   HIDDEN="false"
#!   EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#!   IDENTIFIER="58"
#!   SOURCE_NODE="7"
#!   TARGET_NODE="8"
#!   SOURCE_PORT_DESC="fo 1 FAILED"
#!   TARGET_PORT_DESC="fi 0 "
#!   ENABLED="true"
#!   EXECUTION_IDX="0"
#!   HIDDEN="false"
#!   EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#!   IDENTIFIER="59"
#!   SOURCE_NODE="8"
#!   TARGET_NODE="9"
#!   SOURCE_PORT_DESC="fo 1 FAILED"
#!   TARGET_PORT_DESC="fi 0 "
#!   ENABLED="true"
#!   EXECUTION_IDX="0"
#!   HIDDEN="false"
#!   EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#!   IDENTIFIER="60"
#!   SOURCE_NODE="9"
#!   TARGET_NODE="10"
#!   SOURCE_PORT_DESC="fo 1 FAILED"
#!   TARGET_PORT_DESC="fi 0 "
#!   ENABLED="true"
#!   EXECUTION_IDX="0"
#!   HIDDEN="false"
#!   EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#!   IDENTIFIER="61"
#!   SOURCE_NODE="10"
#!   TARGET_NODE="11"
#!   SOURCE_PORT_DESC="fo 1 FAILED"
#!   TARGET_PORT_DESC="fi 0 "
#!   ENABLED="true"
#!   EXECUTION_IDX="0"
#!   HIDDEN="false"
#!   EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#!   IDENTIFIER="62"
#!   SOURCE_NODE="11"
#!   TARGET_NODE="18"
#!   SOURCE_PORT_DESC="fo 1 FAILED"
#!   TARGET_PORT_DESC="fi 0 "
#!   ENABLED="true"
#!   EXECUTION_IDX="0"
#!   HIDDEN="false"
#!   EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#!   IDENTIFIER="135"
#!   SOURCE_NODE="12"
#!   TARGET_NODE="22"
#!   SOURCE_PORT_DESC="fo 1 FAILED"
#!   TARGET_PORT_DESC="fi 0 "
#!   ENABLED="true"
#!   EXECUTION_IDX="0"
#!   HIDDEN="false"
#!   EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#!   IDENTIFIER="68"
#!   SOURCE_NODE="18"
#!   TARGET_NODE="19"
#!   SOURCE_PORT_DESC="fo 1 FAILED"
#!   TARGET_PORT_DESC="fi 0 "
#!   ENABLED="true"
#!   EXECUTION_IDX="0"
#!   HIDDEN="false"
#!   EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#!   IDENTIFIER="133"
#!   SOURCE_NODE="19"
#!   TARGET_NODE="20"
#!   SOURCE_PORT_DESC="fo 1 FAILED"
#!   TARGET_PORT_DESC="fi 0 "
#!   ENABLED="true"
#!   EXECUTION_IDX="0"
#!   HIDDEN="false"
#!   EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#!   IDENTIFIER="70"
#!   SOURCE_NODE="20"
#!   TARGET_NODE="21"
#!   SOURCE_PORT_DESC="fo 1 FAILED"
#!   TARGET_PORT_DESC="fi 0 "
#!   ENABLED="true"
#!   EXECUTION_IDX="0"
#!   HIDDEN="false"
#!   EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#!   IDENTIFIER="131"
#!   SOURCE_NODE="21"
#!   TARGET_NODE="12"
#!   SOURCE_PORT_DESC="fo 1 FAILED"
#!   TARGET_PORT_DESC="fi 0 "
#!   ENABLED="true"
#!   EXECUTION_IDX="0"
#!   HIDDEN="false"
#!   EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#!   IDENTIFIER="71"
#!   SOURCE_NODE="22"
#!   TARGET_NODE="23"
#!   SOURCE_PORT_DESC="fo 1 FAILED"
#!   TARGET_PORT_DESC="fi 0 "
#!   ENABLED="true"
#!   EXECUTION_IDX="0"
#!   HIDDEN="false"
#!   EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#!   IDENTIFIER="72"
#!   SOURCE_NODE="23"
#!   TARGET_NODE="26"
#!   SOURCE_PORT_DESC="fo 1 FAILED"
#!   TARGET_PORT_DESC="fi 0 "
#!   ENABLED="true"
#!   EXECUTION_IDX="0"
#!   HIDDEN="false"
#!   EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#!   IDENTIFIER="53"
#!   SOURCE_NODE="24"
#!   TARGET_NODE="3"
#!   SOURCE_PORT_DESC="fo 1 FAILED"
#!   TARGET_PORT_DESC="fi 0 "
#!   ENABLED="true"
#!   EXECUTION_IDX="0"
#!   HIDDEN="false"
#!   EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#!   IDENTIFIER="90"
#!   SOURCE_NODE="25"
#!   TARGET_NODE="88"
#!   SOURCE_PORT_DESC="fo 1 FAILED"
#!   TARGET_PORT_DESC="fi 0 "
#!   ENABLED="true"
#!   EXECUTION_IDX="0"
#!   HIDDEN="false"
#!   EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#!   IDENTIFIER="74"
#!   SOURCE_NODE="26"
#!   TARGET_NODE="27"
#!   SOURCE_PORT_DESC="fo 1 FAILED"
#!   TARGET_PORT_DESC="fi 0 "
#!   ENABLED="true"
#!   EXECUTION_IDX="0"
#!   HIDDEN="false"
#!   EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#!   IDENTIFIER="75"
#!   SOURCE_NODE="27"
#!   TARGET_NODE="25"
#!   SOURCE_PORT_DESC="fo 1 FAILED"
#!   TARGET_PORT_DESC="fi 0 "
#!   ENABLED="true"
#!   EXECUTION_IDX="0"
#!   HIDDEN="false"
#!   EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#!   IDENTIFIER="86"
#!   SOURCE_NODE="77"
#!   TARGET_NODE="78"
#!   SOURCE_PORT_DESC="fo 1 FAILED"
#!   TARGET_PORT_DESC="fi 0 "
#!   ENABLED="true"
#!   EXECUTION_IDX="0"
#!   HIDDEN="false"
#!   EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#!   IDENTIFIER="87"
#!   SOURCE_NODE="78"
#!   TARGET_NODE="80"
#!   SOURCE_PORT_DESC="fo 1 FAILED"
#!   TARGET_PORT_DESC="fi 0 "
#!   ENABLED="true"
#!   EXECUTION_IDX="0"
#!   HIDDEN="false"
#!   EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#!   IDENTIFIER="85"
#!   SOURCE_NODE="79"
#!   TARGET_NODE="84"
#!   SOURCE_PORT_DESC="fo 1 PATH"
#!   TARGET_PORT_DESC="fi 0 "
#!   ENABLED="true"
#!   EXECUTION_IDX="0"
#!   HIDDEN="false"
#!   EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#!   IDENTIFIER="94"
#!   SOURCE_NODE="88"
#!   TARGET_NODE="91"
#!   SOURCE_PORT_DESC="fo 1 FAILED"
#!   TARGET_PORT_DESC="fi 0 "
#!   ENABLED="true"
#!   EXECUTION_IDX="0"
#!   HIDDEN="false"
#!   EXTRA_POINTS=""
#! />
#! <FEAT_LINK
#!   IDENTIFIER="96"
#!   SOURCE_NODE="91"
#!   TARGET_NODE="77"
#!   SOURCE_PORT_DESC="fo 1 FAILED"
#!   TARGET_PORT_DESC="fi 0 "
#!   ENABLED="true"
#!   EXECUTION_IDX="0"
#!   HIDDEN="false"
#!   EXTRA_POINTS=""
#! />
#! </FEAT_LINKS>
#! <BREAKPOINTS>
#! </BREAKPOINTS>
#! <ATTR_LINKS>
#! </ATTR_LINKS>
#! <SUBDOCUMENTS>
#! </SUBDOCUMENTS>
#! <LOOKUP_TABLES>
#! </LOOKUP_TABLES>
#! </WORKSPACE>

FME_PYTHON_VERSION 27
DEFAULT_MACRO MASTER_FILES 
GUI OPTIONAL DIRNAME_SRC MASTER_FILES Supplied folder called EmptyMasterFiles:
DEFAULT_MACRO ROADS_INPUT 
GUI OPTIONAL DIRNAME_SRC ROADS_INPUT Folder containing Rrami*.gz raw data files:
DEFAULT_MACRO PATHS_INPUT 
GUI OPTIONAL DIRNAME_SRC PATHS_INPUT Folder containing Paths*.gz raw data files:
DEFAULT_MACRO DEST_FOLDER 
GUI OPTIONAL DIRNAME DEST_FOLDER Destination folder to contain all output files:
#! START_HEADER
#! START_WB_HEADER
READER_TYPE MULTI_READER
WRITER_TYPE NULL
WRITER_KEYWORD NULL_DEST
NULL_DEST_DATASET null
#! END_WB_HEADER
#! START_WB_HEADER
#! END_WB_HEADER
#! END_HEADER

LOG_FILENAME "$(FME_MF_DIR)_OSHighwaysNetwork.log"
LOG_APPEND NO
LOG_TIMINGS YES
LOG_FILTER_MASK -1
LOG_MAX_FEATURES 200
LOG_MAX_RECORDED_FEATURES 200
FME_REPROJECTION_ENGINE FME
FME_IMPLICIT_CSMAP_REPROJECTION_MODE Auto
FME_GEOMETRY_HANDLING Enhanced
FME_STROKE_MAX_DEVIATION 0
# -------------------------------------------------------------------------

MULTI_READER_CONTINUE_ON_READER_FAILURE No

# -------------------------------------------------------------------------

MACRO WORKSPACE_NAME _OSHighwaysNetwork
MACRO FME_VIEWER_APP fmedatainspector
DEFAULT_MACRO WB_CURRENT_CONTEXT
# -------------------------------------------------------------------------
Tcl2 proc Creator_CoordSysRemover {} {   global FME_CoordSys;   set FME_CoordSys {}; }
MACRO Creator_XML     NOT_ACTIVATED
MACRO Creator_CLASSIC NOT_ACTIVATED
MACRO Creator_2D3D    2D_GEOMETRY
MACRO Creator_COORDS  <Unused>
INCLUDE [ if { {Geometry Object} == {Geometry Object} } {            puts {MACRO Creator_XML *} } ]
INCLUDE [ if { {Geometry Object} == {2D Coordinate List} } {            puts {MACRO Creator_2D3D 2D_GEOMETRY};            puts {MACRO Creator_CLASSIC *} } ]
INCLUDE [ if { {Geometry Object} == {3D Coordinate List} } {            puts {MACRO Creator_2D3D 3D_GEOMETRY};            puts {MACRO Creator_CLASSIC *} } ]
INCLUDE [ if { {Geometry Object} == {2D Min/Max Box} } {            set comment {                We need to turn the COORDS which are                    minX minY maxX maxY                into a full polygon list of coordinates            };            set splitCoords [split [string trim {<Unused>}]];            if { [llength $splitCoords] > 4} {               set trimmedCoords {};               foreach item $splitCoords { if { $item != {} } {lappend trimmedCoords $item} };               set splitCoords $trimmedCoords;            };            if { [llength $splitCoords] != 4 } {                error {Creator: Coordinate list is expected to be a space delimited list of four numbers as 'minx miny maxx maxy' - `<Unused>' is invalid};            };            set minX [lindex $splitCoords 0];            set minY [lindex $splitCoords 1];            set maxX [lindex $splitCoords 2];            set maxY [lindex $splitCoords 3];            puts "MACRO Creator_COORDS $minX $minY $minX $maxY $maxX $maxY $maxX $minY $minX $minY";            puts {MACRO Creator_2D3D 2D_GEOMETRY};            puts {MACRO Creator_CLASSIC *} } ]
FACTORY_DEF $(Creator_XML) CreationFactory    FACTORY_NAME Creator_XML_Creator    CREATE_AT_END no    OUTPUT FEATURE_TYPE _____CREATED______        @Geometry(FROM_ENCODED_STRING,<lt>?xml<space>version=<quote>1.0<quote><space>encoding=<quote>US_ASCII<quote><space>standalone=<quote>no<quote><space>?<gt><lt>geometry<gt><lt>point<gt><lt>coord<space>x=<quote>0<quote><space>y=<quote>0<quote><solidus><gt><lt><solidus>point<gt><lt><solidus>geometry<gt>)
FACTORY_DEF $(Creator_CLASSIC) CreationFactory    FACTORY_NAME Creator_CLASSIC_Creator    $(Creator_2D3D) $(Creator_COORDS)    CREATE_AT_END no    OUTPUT FEATURE_TYPE _____CREATED______
FACTORY_DEF * TeeFactory    FACTORY_NAME Creator_Cloner    INPUT FEATURE_TYPE _____CREATED______        @Tcl2(Creator_CoordSysRemover)        @CoordSys(OSGB-GPS-2015)    NUMBER_OF_COPIES 1    OUTPUT FEATURE_TYPE Creator_CREATED        fme_feature_type Creator
FACTORY_DEF * BranchingFactory   FACTORY_NAME "Creator_CREATED Brancher -1 152"   INPUT FEATURE_TYPE Creator_CREATED   TARGET_FACTORY "$(WB_CURRENT_CONTEXT)_CREATOR_BRANCH_TARGET"   MAXIMUM_COUNT None   OUTPUT PASSED FEATURE_TYPE *
# -------------------------------------------------------------------------
FACTORY_DEF * TeeFactory   FACTORY_NAME "$(WB_CURRENT_CONTEXT)_CREATOR_BRANCH_TARGET"   INPUT FEATURE_TYPE *  OUTPUT FEATURE_TYPE *
# -------------------------------------------------------------------------
MACRO FeatureReader_OUTPUT_PORTS_ENCODED PATH
MACRO FeatureReader_DIRECTIVES EXPOSE_ATTRS_GROUP,FME_DISCLOSURE_OPEN,RECURSE_DIRECTORIES,NO,TYPE,ANY,GLOB_PATTERN,*,RETRIEVE_FILE_PROPERTIES,NO,PATH_EXPOSE_FORMAT_ATTRS,fme_basename<comma>char<openparen>50<closeparen><space>fme_dataset<comma>char<openparen>50<closeparen>
# Always provide an INTERACTION, otherwise the factory defaults to ENVELOPE_INTERSECTS
INCLUDE [if { ( {<Unused>} == {<Unused>} ) || ( {($INTERACT_OPTIONS)} == {} ) } {             puts {MACRO FCTQUERY_INTERACTION_LINE FCTQUERY_INTERACTION NONE};          } else {             puts {MACRO FCTQUERY_INTERACTION_LINE FCTQUERY_INTERACTION "<Unused>"};          }         ]
# Consolidate the attribute merge options to what the factory expects
DEFAULT_MACRO FeatureReader_COMBINE_ATTRS
INCLUDE [       if { {RESULT_ONLY} == {MERGE} } {          puts "MACRO FeatureReader_COMBINE_ATTRS <Unused>";       } else {          puts "MACRO FeatureReader_COMBINE_ATTRS RESULT_ONLY";       };    ]
INCLUDE [    puts {DEFAULT_MACRO FeatureReaderDataset_FeatureReader @EvaluateExpression(FDIV,STRING_ENCODED,$(MASTER_FILES$encode),FeatureReader)}; ]
FACTORY_DEF * QueryFactory    FACTORY_NAME FeatureReader    INPUT  FEATURE_TYPE Creator_CREATED    $(FCTQUERY_INTERACTION_LINE)    COMBINE_ATTRIBUTES  $(FeatureReader_COMBINE_ATTRS)    QUERYFCT_ATTRIBUTE_PREFIX <Unused>    COMBINE_GEOMETRY    RESULT_ONLY    ENABLE_CACHE        NO    QUERYFCT_TABLE_SEPARATOR SPACE    READER_TYPE         PATH    READER_DATASET      "$(FeatureReaderDataset_FeatureReader)"    QUERYFCT_IDS        "PATH"    READER_DIRECTIVES META_MACROS,SourceOFFSET_DATETIME<comma><comma>SourceGLOB_PATTERN<comma>*<comma>SourceRECURSE_DIRECTORIES<comma>NO<comma>SourceTYPE<comma>ANY<comma>SourceRETRIEVE_FILE_PROPERTIES<comma>NO<comma>SourceEXPOSE_ATTRS_GROUP<comma>FME_DISCLOSURE_OPEN<comma>SourcePATH_EXPOSE_FORMAT_ATTRS<comma><quote>fme_basename<comma>char<openparen>50<closeparen><space>fme_dataset<comma>char<openparen>50<closeparen><quote>,METAFILE,PATH    QUERYFCT_OUTPUT     "BASED_ON_CONNECTIONS"    CONTINUE_ON_READER_ERROR YES    QUERYFCT_RESULT_TAGS $(FeatureReader_OUTPUT_PORTS_ENCODED)    QUERYFCT_SET_FME_FEATURE_TYPE YES    READER_PARAMS_WWJD     $(FeatureReader_DIRECTIVES)    TREAT_READER_PARAM_AMPERSANDS_AS_LITERALS YES    OUTPUT PATH FEATURE_TYPE FeatureReader_PATH
# -------------------------------------------------------------------------
FACTORY_DEF {*} AttrSetFactory    COMMAND_PARM_EVALUATION SINGLE_PASS    FACTORY_NAME AttributeManager    INPUT  FEATURE_TYPE FeatureReader_PATH    MULTI_FEATURE_MODE NO     NULL_ATTR_MODE NO_OP     ATTRSET_CREATE_DIRECTIVES _PROPAGATE_MISSING_FDIV    ACTION_COLUMN 3    DEF_VAL_COLUMN 2    ATTR_ACTION { "path_unix" "path_unix" "" "REMOVE" }      ATTR_ACTION { "path_windows" "filecopy_source_dataset" "" "RENAME_SET_VALUE" }      ATTR_ACTION { "path_rootname" "path_rootname" "" "REMOVE" }      ATTR_ACTION { "path_filename" "filecopy_dest_filename" "" "RENAME_SET_VALUE" }      ATTR_ACTION { "path_extension" "path_extension" "" "REMOVE" }      ATTR_ACTION { "path_filesize" "path_filesize" "" "REMOVE" }      ATTR_ACTION { "path_ownername" "path_ownername" "" "REMOVE" }      ATTR_ACTION { "path_readonly" "path_readonly" "" "REMOVE" }      ATTR_ACTION { "path_modified_date" "path_modified_date" "" "REMOVE" }      ATTR_ACTION { "path_created_date" "path_created_date" "" "REMOVE" }      ATTR_ACTION { "path_accessed_date" "path_accessed_date" "" "REMOVE" }      ATTR_ACTION { "path_directory_unix" "path_directory_unix" "" "REMOVE" }      ATTR_ACTION { "path_directory_windows" "path_directory_windows" "" "REMOVE" }      ATTR_ACTION { "path_type" "path_type" "" "REMOVE" }      ATTR_ACTION { "fme_geometry<opencurly>0<closecurly>" "fme_geometry<opencurly>0<closecurly>" "" "REMOVE" }      ATTR_ACTION { "fme_basename" "fme_basename" "" "REMOVE" }      ATTR_ACTION { "fme_dataset" "fme_dataset" "" "REMOVE" }      ATTR_ACTION { "fme_geometry<opencurly><closecurly>" "fme_geometry<opencurly><closecurly>" "" "REMOVE" }      ATTR_ACTION { "" "filecopy_dest_dataset" "$(DEST_FOLDER$encode)<backslash>" "SET_TO" }    OUTPUT OUTPUT FEATURE_TYPE AttributeManager_OUTPUT
# -------------------------------------------------------------------------
INCLUDE [    puts {DEFAULT_MACRO FeatureWriterDataset_FeatureWriter @EvaluateExpression(FDIV,STRING_ENCODED,$(DEST_FOLDER$encode),FeatureWriter)}; ]
FACTORY_DEF * WriterFactory    FACTORY_NAME FeatureWriter    WRITER_TYPE FILECOPY    WRITER_DATASET "$(FeatureWriterDataset_FeatureWriter)"    WRITER_SETTINGS RUNTIME_MACROS,FILE_OPERATION<comma>COPY<comma>OVERWRITE_FILE<comma>YES<comma>COPY_SOURCE_DIRECTORY<comma>NO<comma>COPY_SUBDIRECTORIES<comma>YES<comma>FAIL_NONEXISTENT_SOURCE<comma>NO<comma>FAIL_INVALID_DESTINATION<comma>NO<comma>MIME_TYPE<comma>text<solidus>plain<comma>DESTINATION_DATASETTYPE_VALIDATION<comma>Yes<comma>COORDINATE_SYSTEM_GRANULARITY<comma>FEATURE,METAFILE,FILECOPY    WRITER_METAFILE ATTRIBUTE_CASE,ANY,ATTRIBUTE_INVALID_CHARS,,ATTRIBUTE_LENGTH,512,ATTR_TYPE_MAP,char<openparen>width<closeparen><comma>fme_varchar<openparen>width<closeparen><comma>char<openparen>width<closeparen><comma>fme_varbinary<openparen>width<closeparen><comma>char<openparen>width<closeparen><comma>fme_char<openparen>width<closeparen><comma>char<openparen>width<closeparen><comma>fme_binary<openparen>width<closeparen><comma>string<comma>fme_buffer<comma>string<comma>fme_binarybuffer<comma>string<comma>fme_xml<comma>string<comma>fme_json<comma>datetime<comma>fme_datetime<comma>time<comma>fme_time<comma>date<comma>fme_date<comma>real64<comma>fme_real64<comma>real32<comma>fme_real32<comma><quote>number<openparen>width<comma>decimal<closeparen><quote><comma><quote>fme_decimal<openparen>width<comma>decimal<closeparen><quote><comma>int32<comma>fme_int32<comma><quote>number<openparen>11<comma>0<closeparen><quote><comma>fme_uint32<comma><quote>number<openparen>20<comma>0<closeparen><quote><comma>fme_int64<comma><quote>number<openparen>20<comma>0<closeparen><quote><comma>fme_uint64<comma>logical<comma>fme_boolean<comma>int16<comma>fme_int16<comma>int32<comma>fme_uint16<comma>int16<comma>fme_int8<comma>int16<comma>fme_uint8,DEST_ILLEGAL_ATTR_LIST,,FEATURE_TYPE_CASE,ANY,FEATURE_TYPE_INVALID_CHARS,,FEATURE_TYPE_LENGTH,0,FEATURE_TYPE_LENGTH_INCLUDES_PREFIX,false,FEATURE_TYPE_RESERVED_WORDS,,FORMAT_METAFILE,$(FME_HOME_ENCODED)metafile<backslash>FILECOPY.fmf,FORMAT_NAME,FILECOPY,GEOM_MAP,filecopy_none<comma>fme_no_geom<comma>filecopy_none<comma>fme_point<comma>filecopy_none<comma>fme_line<comma>filecopy_none<comma>fme_polygon<comma>filecopy_none<comma>fme_arc<comma>filecopy_none<comma>fme_text<comma>filecopy_none<comma>fme_ellipse<comma>filecopy_none<comma>fme_rectangle<comma>filecopy_none<comma>fme_rounded_rectangle<comma>filecopy_none<comma>fme_collection<comma>filecopy_none<comma>fme_surface<comma>filecopy_none<comma>fme_solid<comma>filecopy_none<comma>fme_raster<comma>filecopy_none<comma>fme_point_cloud<comma>filecopy_none<comma>fme_feature_table,READER_ATTR_INDEX_TYPES,,SOURCE,no,SUPPORTS_FEAT_TYPE_FANOUT,no,SUPPORTS_MULTI_GEOM,yes,WORKBENCH_CANNED_SCHEMA,filecopy.sch,WRITER,FILECOPY,WRITER_ATTR_INDEX_TYPES,,WRITER_DEFLINE_PARMS,,WRITER_DEF_LINE_TEMPLATE,<opencurly>FME_GEN_GROUP_NAME<closecurly>,WRITER_FORMAT_PARAMETER,WRITER_FEATURE_TYPE_EDITING<comma>NO<comma>MIME_TYPE<comma>text<solidus>plain<comma>READER_FEATURE_TYPE_EDITING<comma>NO<comma>FEATURE_TYPE_NAME<comma>FILECOPY<comma>FEATURE_TYPE_DEFAULT_NAME<comma>File1<comma>WRITER_DATASET_HINT<comma><quote>Specify<space>a<space>folder<space>for<space>the<space>File<space>Copy<quote>,WRITER_HAS_DEFLINE_ATTRS,yes    WRITER_FEATURE_TYPES filecopy:filecopy,ftp_feature_type_name,filecopy,ftp_writer,FILECOPY,ftp_dynamic_schema,no,ftp_dynamic_feature_type_name_type,DYN_SCHEMA_PROP_AUTO,ftp_dynamic_geometry_type,DYN_SCHEMA_PROP_AUTO,ftp_dynamic_schema_def_name_type,DYN_SCHEMA_PROP_AUTO,ftp_dynamic_schema_sources,<lt>lt<gt>Unused<lt>gt<gt>,ftp_attribute_source,1,ftp_user_attributes,filecopy_source_dataset<comma>char<lt>openparen<gt>512<lt>closeparen<gt><comma>filecopy_dest_dataset<comma>char<lt>openparen<gt>512<lt>closeparen<gt><comma>filecopy_dest_filename<comma>char<lt>openparen<gt>128<lt>closeparen<gt>,ftp_user_attribute_values,<comma><comma>    WRITER_PARAMS FAIL_INVALID_DESTINATION,NO,MIME_TYPE,text<solidus>plain,COPY_SUBDIRECTORIES,YES,FAIL_NONEXISTENT_SOURCE,NO,COORDINATE_SYSTEM_GRANULARITY,FEATURE,OVERWRITE_FILE,YES,FILE_OPERATION,COPY,DESTINATION_DATASETTYPE_VALIDATION,Yes,COPY_SOURCE_DIRECTORY,NO    DATASET_ATTR _dataset    FEATURE_TYPE_LIST_ATTR _feature_type    TOTAL_FEATURES_WRITTEN_ATTR _total_features_written    OUTPUT_PORTS ""    INPUT filecopy FEATURE_TYPE AttributeManager_OUTPUT  @FeatureType(ENCODED,filecopy)    OUTPUT SUMMARY FEATURE_TYPE FeatureWriter_SUMMARY
# -------------------------------------------------------------------------
# Convert the workspace name to one containing only / -- Tcl likes this better
# (and so do I)
# And determine the "NULL" device so we can ensure we don't get stray output
# messing up our stdout if we are running workspaces in the background
# See http://wiki.tcl.tk/1649 for a description of the tcl_platform
# variable, the "platform" part seems to have valid values windows, unix, and
# macintosh (the latter of which is actually pre-OS X)
Tcl2 if { $tcl_platform(platform) == {windows} } {         set ::null_device {NUL:};         set ::__WR_ENV_HELPER__ {};      } else {         set ::null_device {/dev/null};         set ::__WR_ENV_HELPER__ {/usr/bin/env FME_SUBPROCESS_RUN_DETACHED=1}      };
Tcl2 proc RoadLink_764df992_881d_4209_8126_0765270a0d200_runner { parmListString workspaceFile } {    set workspaceFileUnix [regsub -all {\\} $workspaceFile {/}];    set parmListString [string range $parmListString 1 end-1];    set comment {        Build up the command line in a list, which we'll "eval" to get        at its pieces when we actually execute the "exec".    };    lappend commandArguments {*}$::__WR_ENV_HELPER__ {$(FME_HOME_UNIX)/fme}                             $workspaceFileUnix;    set parmList [split $parmListString {,}];    set comment {        At the same time, remember the TYPES for each of the parameters so        we can avoid logging any passwords in plain text (PR 64546)    };    set parmTypes [split {MULTIFILE,FILENAME} {,}];    set comment {        Note that foreach can walk thorugh more than one list at a time.        If the lists were ever out of sync (had different #s of entries, which should be impossible)        the iteration continues with the shorter list return an empty string. So we should be okay    };    set commandArgumentsToLog $commandArguments;    foreach {parmName encodedValue} $parmList parmType $parmTypes {       set comment {           Decode the parameter value which we now know is very encoded to guard           it from the parser and append them each to a new list which will be passed           as the arguments to the exec function.  Note that the           parameter names need to be turned into macro settings by           prepending them with --           Note also that the WorkspaceRunner sometimes encodes attribute           dereferences by placing <amp> at the beginning rather than using @Value.           Further note that string range forgives if the ending index is > the length of           the string, so we can just ask for the first 5 characters           when we're checking for <amp>.       };       if {[string length $parmName] == 0} { continue; };       lappend commandArguments \"--$parmName\";       lappend commandArgumentsToLog \"--$parmName\";       set comment {           for backwards compatibility, replace first <amp>       };       if { [string range $encodedValue 0 4] == {<amp>} &&            [string length $encodedValue] > 5 } {           set encodedValue [string replace $encodedValue 0 4 {<at>Value<openparen>}]];           append encodedValue "<closeparen>";       };       set comment { We used to call FME_DecodeTextOrAttr here. After changes to                     the code that writes out the mapping file section, we don't                     need to do this any more because the value would be in the                     correct state of encoding as required by the child workspace       };       set comment { parameter values starting with '<' causes tcl exec to fail so                     we escape leading '<' with backslash and then do the reverse                     when parsing command line arguments       };       if { [string index $encodedValue 0] == {<} } {          set encodedValue "\\$encodedValue";       };       lappend commandArguments $encodedValue;       set comment {           Ensure that passwords are not added into the logmessage (PR 64546)           We'll guard against both PASSWORD and PASSWORD_CONFIRM GUI types           by checking if the word PASSWORD is in the GUI TYPE at all       };       if { [string first {PASSWORD} $parmType] != -1 } {           lappend commandArgumentsToLog {***};       } else {           lappend commandArgumentsToLog $encodedValue;       };    };    set comment {        Now optionally run this in a detached way if we were not supposed        to wait by adding & on the end to put it in the background.  And        at the same time, ensure that any stray stdout/stderr is routed to        null.    };    if { {Yes} == {No} } {        lappend commandArguments \">$::null_device\";        lappend commandArgumentsToLog \">$::null_device\";        lappend commandArguments \"<$::null_device\";        lappend commandArgumentsToLog \"<$::null_device\";        FME_LogMessage fme_inform \"RoadLink: Initiating run of FME Workspace $workspaceFile with command line:\";    } else {        FME_LogMessage fme_inform \"RoadLink: Running FME Workspace $workspaceFile with command line:\";    };    set comment {        The below 2>@1 forces any standard error output to go into the msg variable        or to NULL if we're running in the background.    };    lappend commandArguments {2>@1};    lappend commandArgumentsToLog {2>@1};    if { {Yes} == {No} } {        lappend commandArguments {&};        lappend commandArgumentsToLog {&};    };    FME_LogMessage fme_inform [concat RoadLink: $commandArgumentsToLog];    if { {Yes} == {No} } {       after 1000;       while { [FME_CanSpawnFme <Unused>] == {0} } {             after 2000;       };    };    if {[catch {eval [concat exec $commandArguments] } msg ]} {       set msg [regsub {\015*\012child[^\012]*$} $msg {}];       FME_LogMessage fme_warn \"RoadLink: Failed to run workspace $workspaceFileUnix -- Trace was:\n\n$msg\n\";       FME_SetAttribute _failure_message $msg;       return FAILURE;    } else {       global RoadLink_764df992_881d_4209_8126_0765270a0d200_process_count;       incr RoadLink_764df992_881d_4209_8126_0765270a0d200_process_count;       if { {Yes} == {No} } {           FME_LogMessage fme_inform \"RoadLink: Successfully initiated run of workspace $workspaceFile\";           global RoadLink_764df992_881d_4209_8126_0765270a0d200_all_processes;           lappend RoadLink_764df992_881d_4209_8126_0765270a0d200_all_processes $msg;       } else {           FME_LogMessage fme_inform \"RoadLink: Successfully ran workspace $workspaceFile\";       };       return SUCCESS;    }; }
FACTORY_DEF * TestFactory    FACTORY_NAME RoadLink_ExecutorAndRouter    INPUT  FEATURE_TYPE FeatureWriter_SUMMARY    TEST @Tcl2("RoadLink_764df992_881d_4209_8126_0765270a0d200_runner {(SourceDataset_GML,@EvaluateExpression(FDIV,STRING,$(ROADS_INPUT$encode)<backslash>Highways_Rrami_RoadLink_*.gml.gz,RoadLink),DestDataset_GEOPACKAGE,@EvaluateExpression(FDIV,STRING,$(DEST_FOLDER$encode)<backslash>RoadLink.gpkg,RoadLink))} {RoadLink.fmw}") == SUCCESS    OUTPUT PASSED FEATURE_TYPE RoadLink_SUCCEEDED    OUTPUT FAILED FEATURE_TYPE RoadLink_FAILED
Tcl2 proc RoadLink_764df992_881d_4209_8126_0765270a0d200_summarizer { } {     global RoadLink_764df992_881d_4209_8126_0765270a0d200_process_count;     set comment { incr 0 creates the variable if it wasn't present };     incr RoadLink_764df992_881d_4209_8126_0765270a0d200_process_count 0;     FME_SetAttribute _proc_count [set RoadLink_764df992_881d_4209_8126_0765270a0d200_process_count];     global RoadLink_764df992_881d_4209_8126_0765270a0d200_all_processes;     if {[info exists RoadLink_764df992_881d_4209_8126_0765270a0d200_all_processes]} {         set index 0;         foreach pid [set RoadLink_764df992_881d_4209_8126_0765270a0d200_all_processes] {             FME_SetAttribute \"_processes{$index}\" $pid;             incr index;         }     } }
FACTORY_DEF * CreationFactory    FACTORY_NAME RoadLink_SummaryMaker    CREATE_AT_END yes
# -------------------------------------------------------------------------
# Convert the workspace name to one containing only / -- Tcl likes this better
# (and so do I)
# And determine the "NULL" device so we can ensure we don't get stray output
# messing up our stdout if we are running workspaces in the background
# See http://wiki.tcl.tk/1649 for a description of the tcl_platform
# variable, the "platform" part seems to have valid values windows, unix, and
# macintosh (the latter of which is actually pre-OS X)
Tcl2 if { $tcl_platform(platform) == {windows} } {         set ::null_device {NUL:};         set ::__WR_ENV_HELPER__ {};      } else {         set ::null_device {/dev/null};         set ::__WR_ENV_HELPER__ {/usr/bin/env FME_SUBPROCESS_RUN_DETACHED=1}      };
Tcl2 proc PathLink_ef53c085_afec_4e1b_a17e_4c1953760e820_runner { parmListString workspaceFile } {    set workspaceFileUnix [regsub -all {\\} $workspaceFile {/}];    set parmListString [string range $parmListString 1 end-1];    set comment {        Build up the command line in a list, which we'll "eval" to get        at its pieces when we actually execute the "exec".    };    lappend commandArguments {*}$::__WR_ENV_HELPER__ {$(FME_HOME_UNIX)/fme}                             $workspaceFileUnix;    set parmList [split $parmListString {,}];    set comment {        At the same time, remember the TYPES for each of the parameters so        we can avoid logging any passwords in plain text (PR 64546)    };    set parmTypes [split {MULTIFILE,FILENAME} {,}];    set comment {        Note that foreach can walk thorugh more than one list at a time.        If the lists were ever out of sync (had different #s of entries, which should be impossible)        the iteration continues with the shorter list return an empty string. So we should be okay    };    set commandArgumentsToLog $commandArguments;    foreach {parmName encodedValue} $parmList parmType $parmTypes {       set comment {           Decode the parameter value which we now know is very encoded to guard           it from the parser and append them each to a new list which will be passed           as the arguments to the exec function.  Note that the           parameter names need to be turned into macro settings by           prepending them with --           Note also that the WorkspaceRunner sometimes encodes attribute           dereferences by placing <amp> at the beginning rather than using @Value.           Further note that string range forgives if the ending index is > the length of           the string, so we can just ask for the first 5 characters           when we're checking for <amp>.       };       if {[string length $parmName] == 0} { continue; };       lappend commandArguments \"--$parmName\";       lappend commandArgumentsToLog \"--$parmName\";       set comment {           for backwards compatibility, replace first <amp>       };       if { [string range $encodedValue 0 4] == {<amp>} &&            [string length $encodedValue] > 5 } {           set encodedValue [string replace $encodedValue 0 4 {<at>Value<openparen>}]];           append encodedValue "<closeparen>";       };       set comment { We used to call FME_DecodeTextOrAttr here. After changes to                     the code that writes out the mapping file section, we don't                     need to do this any more because the value would be in the                     correct state of encoding as required by the child workspace       };       set comment { parameter values starting with '<' causes tcl exec to fail so                     we escape leading '<' with backslash and then do the reverse                     when parsing command line arguments       };       if { [string index $encodedValue 0] == {<} } {          set encodedValue "\\$encodedValue";       };       lappend commandArguments $encodedValue;       set comment {           Ensure that passwords are not added into the logmessage (PR 64546)           We'll guard against both PASSWORD and PASSWORD_CONFIRM GUI types           by checking if the word PASSWORD is in the GUI TYPE at all       };       if { [string first {PASSWORD} $parmType] != -1 } {           lappend commandArgumentsToLog {***};       } else {           lappend commandArgumentsToLog $encodedValue;       };    };    set comment {        Now optionally run this in a detached way if we were not supposed        to wait by adding & on the end to put it in the background.  And        at the same time, ensure that any stray stdout/stderr is routed to        null.    };    if { {Yes} == {No} } {        lappend commandArguments \">$::null_device\";        lappend commandArgumentsToLog \">$::null_device\";        lappend commandArguments \"<$::null_device\";        lappend commandArgumentsToLog \"<$::null_device\";        FME_LogMessage fme_inform \"PathLink: Initiating run of FME Workspace $workspaceFile with command line:\";    } else {        FME_LogMessage fme_inform \"PathLink: Running FME Workspace $workspaceFile with command line:\";    };    set comment {        The below 2>@1 forces any standard error output to go into the msg variable        or to NULL if we're running in the background.    };    lappend commandArguments {2>@1};    lappend commandArgumentsToLog {2>@1};    if { {Yes} == {No} } {        lappend commandArguments {&};        lappend commandArgumentsToLog {&};    };    FME_LogMessage fme_inform [concat PathLink: $commandArgumentsToLog];    if { {Yes} == {No} } {       after 1000;       while { [FME_CanSpawnFme <Unused>] == {0} } {             after 2000;       };    };    if {[catch {eval [concat exec $commandArguments] } msg ]} {       set msg [regsub {\015*\012child[^\012]*$} $msg {}];       FME_LogMessage fme_warn \"PathLink: Failed to run workspace $workspaceFileUnix -- Trace was:\n\n$msg\n\";       FME_SetAttribute _failure_message $msg;       return FAILURE;    } else {       global PathLink_ef53c085_afec_4e1b_a17e_4c1953760e820_process_count;       incr PathLink_ef53c085_afec_4e1b_a17e_4c1953760e820_process_count;       if { {Yes} == {No} } {           FME_LogMessage fme_inform \"PathLink: Successfully initiated run of workspace $workspaceFile\";           global PathLink_ef53c085_afec_4e1b_a17e_4c1953760e820_all_processes;           lappend PathLink_ef53c085_afec_4e1b_a17e_4c1953760e820_all_processes $msg;       } else {           FME_LogMessage fme_inform \"PathLink: Successfully ran workspace $workspaceFile\";       };       return SUCCESS;    }; }
FACTORY_DEF * TestFactory    FACTORY_NAME PathLink_ExecutorAndRouter    INPUT  FEATURE_TYPE RoadLink_SUCCEEDED    INPUT  FEATURE_TYPE RoadLink_FAILED    TEST @Tcl2("PathLink_ef53c085_afec_4e1b_a17e_4c1953760e820_runner {(SourceDataset_GML,@EvaluateExpression(FDIV,STRING,$(PATHS_INPUT$encode)<backslash>Highways_Paths_PathLink_*.gml.gz,PathLink),DestDataset_GEOPACKAGE,@EvaluateExpression(FDIV,STRING,$(DEST_FOLDER$encode)<backslash>PathLink.gpkg,PathLink))} {PathLink.fmw}") == SUCCESS    OUTPUT PASSED FEATURE_TYPE PathLink_SUCCEEDED    OUTPUT FAILED FEATURE_TYPE PathLink_FAILED
Tcl2 proc PathLink_ef53c085_afec_4e1b_a17e_4c1953760e820_summarizer { } {     global PathLink_ef53c085_afec_4e1b_a17e_4c1953760e820_process_count;     set comment { incr 0 creates the variable if it wasn't present };     incr PathLink_ef53c085_afec_4e1b_a17e_4c1953760e820_process_count 0;     FME_SetAttribute _proc_count [set PathLink_ef53c085_afec_4e1b_a17e_4c1953760e820_process_count];     global PathLink_ef53c085_afec_4e1b_a17e_4c1953760e820_all_processes;     if {[info exists PathLink_ef53c085_afec_4e1b_a17e_4c1953760e820_all_processes]} {         set index 0;         foreach pid [set PathLink_ef53c085_afec_4e1b_a17e_4c1953760e820_all_processes] {             FME_SetAttribute \"_processes{$index}\" $pid;             incr index;         }     } }
FACTORY_DEF * CreationFactory    FACTORY_NAME PathLink_SummaryMaker    CREATE_AT_END yes
# -------------------------------------------------------------------------
# Convert the workspace name to one containing only / -- Tcl likes this better
# (and so do I)
# And determine the "NULL" device so we can ensure we don't get stray output
# messing up our stdout if we are running workspaces in the background
# See http://wiki.tcl.tk/1649 for a description of the tcl_platform
# variable, the "platform" part seems to have valid values windows, unix, and
# macintosh (the latter of which is actually pre-OS X)
Tcl2 if { $tcl_platform(platform) == {windows} } {         set ::null_device {NUL:};         set ::__WR_ENV_HELPER__ {};      } else {         set ::null_device {/dev/null};         set ::__WR_ENV_HELPER__ {/usr/bin/env FME_SUBPROCESS_RUN_DETACHED=1}      };
Tcl2 proc ConnectingLink_9bef01ac_910f_424c_b7be_a27cb50ecf3d0_runner { parmListString workspaceFile } {    set workspaceFileUnix [regsub -all {\\} $workspaceFile {/}];    set parmListString [string range $parmListString 1 end-1];    set comment {        Build up the command line in a list, which we'll "eval" to get        at its pieces when we actually execute the "exec".    };    lappend commandArguments {*}$::__WR_ENV_HELPER__ {$(FME_HOME_UNIX)/fme}                             $workspaceFileUnix;    set parmList [split $parmListString {,}];    set comment {        At the same time, remember the TYPES for each of the parameters so        we can avoid logging any passwords in plain text (PR 64546)    };    set parmTypes [split {MULTIFILE,FILENAME} {,}];    set comment {        Note that foreach can walk thorugh more than one list at a time.        If the lists were ever out of sync (had different #s of entries, which should be impossible)        the iteration continues with the shorter list return an empty string. So we should be okay    };    set commandArgumentsToLog $commandArguments;    foreach {parmName encodedValue} $parmList parmType $parmTypes {       set comment {           Decode the parameter value which we now know is very encoded to guard           it from the parser and append them each to a new list which will be passed           as the arguments to the exec function.  Note that the           parameter names need to be turned into macro settings by           prepending them with --           Note also that the WorkspaceRunner sometimes encodes attribute           dereferences by placing <amp> at the beginning rather than using @Value.           Further note that string range forgives if the ending index is > the length of           the string, so we can just ask for the first 5 characters           when we're checking for <amp>.       };       if {[string length $parmName] == 0} { continue; };       lappend commandArguments \"--$parmName\";       lappend commandArgumentsToLog \"--$parmName\";       set comment {           for backwards compatibility, replace first <amp>       };       if { [string range $encodedValue 0 4] == {<amp>} &&            [string length $encodedValue] > 5 } {           set encodedValue [string replace $encodedValue 0 4 {<at>Value<openparen>}]];           append encodedValue "<closeparen>";       };       set comment { We used to call FME_DecodeTextOrAttr here. After changes to                     the code that writes out the mapping file section, we don't                     need to do this any more because the value would be in the                     correct state of encoding as required by the child workspace       };       set comment { parameter values starting with '<' causes tcl exec to fail so                     we escape leading '<' with backslash and then do the reverse                     when parsing command line arguments       };       if { [string index $encodedValue 0] == {<} } {          set encodedValue "\\$encodedValue";       };       lappend commandArguments $encodedValue;       set comment {           Ensure that passwords are not added into the logmessage (PR 64546)           We'll guard against both PASSWORD and PASSWORD_CONFIRM GUI types           by checking if the word PASSWORD is in the GUI TYPE at all       };       if { [string first {PASSWORD} $parmType] != -1 } {           lappend commandArgumentsToLog {***};       } else {           lappend commandArgumentsToLog $encodedValue;       };    };    set comment {        Now optionally run this in a detached way if we were not supposed        to wait by adding & on the end to put it in the background.  And        at the same time, ensure that any stray stdout/stderr is routed to        null.    };    if { {Yes} == {No} } {        lappend commandArguments \">$::null_device\";        lappend commandArgumentsToLog \">$::null_device\";        lappend commandArguments \"<$::null_device\";        lappend commandArgumentsToLog \"<$::null_device\";        FME_LogMessage fme_inform \"ConnectingLink: Initiating run of FME Workspace $workspaceFile with command line:\";    } else {        FME_LogMessage fme_inform \"ConnectingLink: Running FME Workspace $workspaceFile with command line:\";    };    set comment {        The below 2>@1 forces any standard error output to go into the msg variable        or to NULL if we're running in the background.    };    lappend commandArguments {2>@1};    lappend commandArgumentsToLog {2>@1};    if { {Yes} == {No} } {        lappend commandArguments {&};        lappend commandArgumentsToLog {&};    };    FME_LogMessage fme_inform [concat ConnectingLink: $commandArgumentsToLog];    if { {Yes} == {No} } {       after 1000;       while { [FME_CanSpawnFme <Unused>] == {0} } {             after 2000;       };    };    if {[catch {eval [concat exec $commandArguments] } msg ]} {       set msg [regsub {\015*\012child[^\012]*$} $msg {}];       FME_LogMessage fme_warn \"ConnectingLink: Failed to run workspace $workspaceFileUnix -- Trace was:\n\n$msg\n\";       FME_SetAttribute _failure_message $msg;       return FAILURE;    } else {       global ConnectingLink_9bef01ac_910f_424c_b7be_a27cb50ecf3d0_process_count;       incr ConnectingLink_9bef01ac_910f_424c_b7be_a27cb50ecf3d0_process_count;       if { {Yes} == {No} } {           FME_LogMessage fme_inform \"ConnectingLink: Successfully initiated run of workspace $workspaceFile\";           global ConnectingLink_9bef01ac_910f_424c_b7be_a27cb50ecf3d0_all_processes;           lappend ConnectingLink_9bef01ac_910f_424c_b7be_a27cb50ecf3d0_all_processes $msg;       } else {           FME_LogMessage fme_inform \"ConnectingLink: Successfully ran workspace $workspaceFile\";       };       return SUCCESS;    }; }
FACTORY_DEF * TestFactory    FACTORY_NAME ConnectingLink_ExecutorAndRouter    INPUT  FEATURE_TYPE PathLink_SUCCEEDED    INPUT  FEATURE_TYPE PathLink_FAILED    TEST @Tcl2("ConnectingLink_9bef01ac_910f_424c_b7be_a27cb50ecf3d0_runner {(SourceDataset_GML,@EvaluateExpression(FDIV,STRING,$(PATHS_INPUT$encode)<backslash>Highways_Paths_ConnectingLink_*.gml.gz,ConnectingLink),DestDataset_GEOPACKAGE,@EvaluateExpression(FDIV,STRING,$(DEST_FOLDER$encode)<backslash>ConnectingLink.gpkg,ConnectingLink))} {ConnectingLink.fmw}") == SUCCESS    OUTPUT PASSED FEATURE_TYPE ConnectingLink_SUCCEEDED    OUTPUT FAILED FEATURE_TYPE ConnectingLink_FAILED
Tcl2 proc ConnectingLink_9bef01ac_910f_424c_b7be_a27cb50ecf3d0_summarizer { } {     global ConnectingLink_9bef01ac_910f_424c_b7be_a27cb50ecf3d0_process_count;     set comment { incr 0 creates the variable if it wasn't present };     incr ConnectingLink_9bef01ac_910f_424c_b7be_a27cb50ecf3d0_process_count 0;     FME_SetAttribute _proc_count [set ConnectingLink_9bef01ac_910f_424c_b7be_a27cb50ecf3d0_process_count];     global ConnectingLink_9bef01ac_910f_424c_b7be_a27cb50ecf3d0_all_processes;     if {[info exists ConnectingLink_9bef01ac_910f_424c_b7be_a27cb50ecf3d0_all_processes]} {         set index 0;         foreach pid [set ConnectingLink_9bef01ac_910f_424c_b7be_a27cb50ecf3d0_all_processes] {             FME_SetAttribute \"_processes{$index}\" $pid;             incr index;         }     } }
FACTORY_DEF * CreationFactory    FACTORY_NAME ConnectingLink_SummaryMaker    CREATE_AT_END yes
# -------------------------------------------------------------------------
# Convert the workspace name to one containing only / -- Tcl likes this better
# (and so do I)
# And determine the "NULL" device so we can ensure we don't get stray output
# messing up our stdout if we are running workspaces in the background
# See http://wiki.tcl.tk/1649 for a description of the tcl_platform
# variable, the "platform" part seems to have valid values windows, unix, and
# macintosh (the latter of which is actually pre-OS X)
Tcl2 if { $tcl_platform(platform) == {windows} } {         set ::null_device {NUL:};         set ::__WR_ENV_HELPER__ {};      } else {         set ::null_device {/dev/null};         set ::__WR_ENV_HELPER__ {/usr/bin/env FME_SUBPROCESS_RUN_DETACHED=1}      };
Tcl2 proc FerryLink_Roads_7565a140_b492_4eb1_b72c_90e500be7e880_runner { parmListString workspaceFile } {    set workspaceFileUnix [regsub -all {\\} $workspaceFile {/}];    set parmListString [string range $parmListString 1 end-1];    set comment {        Build up the command line in a list, which we'll "eval" to get        at its pieces when we actually execute the "exec".    };    lappend commandArguments {*}$::__WR_ENV_HELPER__ {$(FME_HOME_UNIX)/fme}                             $workspaceFileUnix;    set parmList [split $parmListString {,}];    set comment {        At the same time, remember the TYPES for each of the parameters so        we can avoid logging any passwords in plain text (PR 64546)    };    set parmTypes [split {MULTIFILE,FILENAME} {,}];    set comment {        Note that foreach can walk thorugh more than one list at a time.        If the lists were ever out of sync (had different #s of entries, which should be impossible)        the iteration continues with the shorter list return an empty string. So we should be okay    };    set commandArgumentsToLog $commandArguments;    foreach {parmName encodedValue} $parmList parmType $parmTypes {       set comment {           Decode the parameter value which we now know is very encoded to guard           it from the parser and append them each to a new list which will be passed           as the arguments to the exec function.  Note that the           parameter names need to be turned into macro settings by           prepending them with --           Note also that the WorkspaceRunner sometimes encodes attribute           dereferences by placing <amp> at the beginning rather than using @Value.           Further note that string range forgives if the ending index is > the length of           the string, so we can just ask for the first 5 characters           when we're checking for <amp>.       };       if {[string length $parmName] == 0} { continue; };       lappend commandArguments \"--$parmName\";       lappend commandArgumentsToLog \"--$parmName\";       set comment {           for backwards compatibility, replace first <amp>       };       if { [string range $encodedValue 0 4] == {<amp>} &&            [string length $encodedValue] > 5 } {           set encodedValue [string replace $encodedValue 0 4 {<at>Value<openparen>}]];           append encodedValue "<closeparen>";       };       set comment { We used to call FME_DecodeTextOrAttr here. After changes to                     the code that writes out the mapping file section, we don't                     need to do this any more because the value would be in the                     correct state of encoding as required by the child workspace       };       set comment { parameter values starting with '<' causes tcl exec to fail so                     we escape leading '<' with backslash and then do the reverse                     when parsing command line arguments       };       if { [string index $encodedValue 0] == {<} } {          set encodedValue "\\$encodedValue";       };       lappend commandArguments $encodedValue;       set comment {           Ensure that passwords are not added into the logmessage (PR 64546)           We'll guard against both PASSWORD and PASSWORD_CONFIRM GUI types           by checking if the word PASSWORD is in the GUI TYPE at all       };       if { [string first {PASSWORD} $parmType] != -1 } {           lappend commandArgumentsToLog {***};       } else {           lappend commandArgumentsToLog $encodedValue;       };    };    set comment {        Now optionally run this in a detached way if we were not supposed        to wait by adding & on the end to put it in the background.  And        at the same time, ensure that any stray stdout/stderr is routed to        null.    };    if { {Yes} == {No} } {        lappend commandArguments \">$::null_device\";        lappend commandArgumentsToLog \">$::null_device\";        lappend commandArguments \"<$::null_device\";        lappend commandArgumentsToLog \"<$::null_device\";        FME_LogMessage fme_inform \"FerryLink_Roads: Initiating run of FME Workspace $workspaceFile with command line:\";    } else {        FME_LogMessage fme_inform \"FerryLink_Roads: Running FME Workspace $workspaceFile with command line:\";    };    set comment {        The below 2>@1 forces any standard error output to go into the msg variable        or to NULL if we're running in the background.    };    lappend commandArguments {2>@1};    lappend commandArgumentsToLog {2>@1};    if { {Yes} == {No} } {        lappend commandArguments {&};        lappend commandArgumentsToLog {&};    };    FME_LogMessage fme_inform [concat FerryLink_Roads: $commandArgumentsToLog];    if { {Yes} == {No} } {       after 1000;       while { [FME_CanSpawnFme <Unused>] == {0} } {             after 2000;       };    };    if {[catch {eval [concat exec $commandArguments] } msg ]} {       set msg [regsub {\015*\012child[^\012]*$} $msg {}];       FME_LogMessage fme_warn \"FerryLink_Roads: Failed to run workspace $workspaceFileUnix -- Trace was:\n\n$msg\n\";       FME_SetAttribute _failure_message $msg;       return FAILURE;    } else {       global FerryLink_Roads_7565a140_b492_4eb1_b72c_90e500be7e880_process_count;       incr FerryLink_Roads_7565a140_b492_4eb1_b72c_90e500be7e880_process_count;       if { {Yes} == {No} } {           FME_LogMessage fme_inform \"FerryLink_Roads: Successfully initiated run of workspace $workspaceFile\";           global FerryLink_Roads_7565a140_b492_4eb1_b72c_90e500be7e880_all_processes;           lappend FerryLink_Roads_7565a140_b492_4eb1_b72c_90e500be7e880_all_processes $msg;       } else {           FME_LogMessage fme_inform \"FerryLink_Roads: Successfully ran workspace $workspaceFile\";       };       return SUCCESS;    }; }
FACTORY_DEF * TestFactory    FACTORY_NAME FerryLink_Roads_ExecutorAndRouter    INPUT  FEATURE_TYPE ConnectingLink_SUCCEEDED    INPUT  FEATURE_TYPE ConnectingLink_FAILED    TEST @Tcl2("FerryLink_Roads_7565a140_b492_4eb1_b72c_90e500be7e880_runner {(SourceDataset_GML,@EvaluateExpression(FDIV,STRING,$(ROADS_INPUT$encode)<backslash>Highways_Rrami_FerryLink_*.gml.gz,FerryLink_Roads),DestDataset_GEOPACKAGE,@EvaluateExpression(FDIV,STRING,$(DEST_FOLDER$encode)<backslash>FerryLink_Roads.gpkg,FerryLink_Roads))} {FerryLink.fmw}") == SUCCESS    OUTPUT PASSED FEATURE_TYPE FerryLink_Roads_SUCCEEDED    OUTPUT FAILED FEATURE_TYPE FerryLink_Roads_FAILED
Tcl2 proc FerryLink_Roads_7565a140_b492_4eb1_b72c_90e500be7e880_summarizer { } {     global FerryLink_Roads_7565a140_b492_4eb1_b72c_90e500be7e880_process_count;     set comment { incr 0 creates the variable if it wasn't present };     incr FerryLink_Roads_7565a140_b492_4eb1_b72c_90e500be7e880_process_count 0;     FME_SetAttribute _proc_count [set FerryLink_Roads_7565a140_b492_4eb1_b72c_90e500be7e880_process_count];     global FerryLink_Roads_7565a140_b492_4eb1_b72c_90e500be7e880_all_processes;     if {[info exists FerryLink_Roads_7565a140_b492_4eb1_b72c_90e500be7e880_all_processes]} {         set index 0;         foreach pid [set FerryLink_Roads_7565a140_b492_4eb1_b72c_90e500be7e880_all_processes] {             FME_SetAttribute \"_processes{$index}\" $pid;             incr index;         }     } }
FACTORY_DEF * CreationFactory    FACTORY_NAME FerryLink_Roads_SummaryMaker    CREATE_AT_END yes
# -------------------------------------------------------------------------
# Convert the workspace name to one containing only / -- Tcl likes this better
# (and so do I)
# And determine the "NULL" device so we can ensure we don't get stray output
# messing up our stdout if we are running workspaces in the background
# See http://wiki.tcl.tk/1649 for a description of the tcl_platform
# variable, the "platform" part seems to have valid values windows, unix, and
# macintosh (the latter of which is actually pre-OS X)
Tcl2 if { $tcl_platform(platform) == {windows} } {         set ::null_device {NUL:};         set ::__WR_ENV_HELPER__ {};      } else {         set ::null_device {/dev/null};         set ::__WR_ENV_HELPER__ {/usr/bin/env FME_SUBPROCESS_RUN_DETACHED=1}      };
Tcl2 proc FerryLink_Paths_aa9e18e8_8a61_4c05_9e56_d06faa0eafcc0_runner { parmListString workspaceFile } {    set workspaceFileUnix [regsub -all {\\} $workspaceFile {/}];    set parmListString [string range $parmListString 1 end-1];    set comment {        Build up the command line in a list, which we'll "eval" to get        at its pieces when we actually execute the "exec".    };    lappend commandArguments {*}$::__WR_ENV_HELPER__ {$(FME_HOME_UNIX)/fme}                             $workspaceFileUnix;    set parmList [split $parmListString {,}];    set comment {        At the same time, remember the TYPES for each of the parameters so        we can avoid logging any passwords in plain text (PR 64546)    };    set parmTypes [split {MULTIFILE,FILENAME} {,}];    set comment {        Note that foreach can walk thorugh more than one list at a time.        If the lists were ever out of sync (had different #s of entries, which should be impossible)        the iteration continues with the shorter list return an empty string. So we should be okay    };    set commandArgumentsToLog $commandArguments;    foreach {parmName encodedValue} $parmList parmType $parmTypes {       set comment {           Decode the parameter value which we now know is very encoded to guard           it from the parser and append them each to a new list which will be passed           as the arguments to the exec function.  Note that the           parameter names need to be turned into macro settings by           prepending them with --           Note also that the WorkspaceRunner sometimes encodes attribute           dereferences by placing <amp> at the beginning rather than using @Value.           Further note that string range forgives if the ending index is > the length of           the string, so we can just ask for the first 5 characters           when we're checking for <amp>.       };       if {[string length $parmName] == 0} { continue; };       lappend commandArguments \"--$parmName\";       lappend commandArgumentsToLog \"--$parmName\";       set comment {           for backwards compatibility, replace first <amp>       };       if { [string range $encodedValue 0 4] == {<amp>} &&            [string length $encodedValue] > 5 } {           set encodedValue [string replace $encodedValue 0 4 {<at>Value<openparen>}]];           append encodedValue "<closeparen>";       };       set comment { We used to call FME_DecodeTextOrAttr here. After changes to                     the code that writes out the mapping file section, we don't                     need to do this any more because the value would be in the                     correct state of encoding as required by the child workspace       };       set comment { parameter values starting with '<' causes tcl exec to fail so                     we escape leading '<' with backslash and then do the reverse                     when parsing command line arguments       };       if { [string index $encodedValue 0] == {<} } {          set encodedValue "\\$encodedValue";       };       lappend commandArguments $encodedValue;       set comment {           Ensure that passwords are not added into the logmessage (PR 64546)           We'll guard against both PASSWORD and PASSWORD_CONFIRM GUI types           by checking if the word PASSWORD is in the GUI TYPE at all       };       if { [string first {PASSWORD} $parmType] != -1 } {           lappend commandArgumentsToLog {***};       } else {           lappend commandArgumentsToLog $encodedValue;       };    };    set comment {        Now optionally run this in a detached way if we were not supposed        to wait by adding & on the end to put it in the background.  And        at the same time, ensure that any stray stdout/stderr is routed to        null.    };    if { {Yes} == {No} } {        lappend commandArguments \">$::null_device\";        lappend commandArgumentsToLog \">$::null_device\";        lappend commandArguments \"<$::null_device\";        lappend commandArgumentsToLog \"<$::null_device\";        FME_LogMessage fme_inform \"FerryLink_Paths: Initiating run of FME Workspace $workspaceFile with command line:\";    } else {        FME_LogMessage fme_inform \"FerryLink_Paths: Running FME Workspace $workspaceFile with command line:\";    };    set comment {        The below 2>@1 forces any standard error output to go into the msg variable        or to NULL if we're running in the background.    };    lappend commandArguments {2>@1};    lappend commandArgumentsToLog {2>@1};    if { {Yes} == {No} } {        lappend commandArguments {&};        lappend commandArgumentsToLog {&};    };    FME_LogMessage fme_inform [concat FerryLink_Paths: $commandArgumentsToLog];    if { {Yes} == {No} } {       after 1000;       while { [FME_CanSpawnFme <Unused>] == {0} } {             after 2000;       };    };    if {[catch {eval [concat exec $commandArguments] } msg ]} {       set msg [regsub {\015*\012child[^\012]*$} $msg {}];       FME_LogMessage fme_warn \"FerryLink_Paths: Failed to run workspace $workspaceFileUnix -- Trace was:\n\n$msg\n\";       FME_SetAttribute _failure_message $msg;       return FAILURE;    } else {       global FerryLink_Paths_aa9e18e8_8a61_4c05_9e56_d06faa0eafcc0_process_count;       incr FerryLink_Paths_aa9e18e8_8a61_4c05_9e56_d06faa0eafcc0_process_count;       if { {Yes} == {No} } {           FME_LogMessage fme_inform \"FerryLink_Paths: Successfully initiated run of workspace $workspaceFile\";           global FerryLink_Paths_aa9e18e8_8a61_4c05_9e56_d06faa0eafcc0_all_processes;           lappend FerryLink_Paths_aa9e18e8_8a61_4c05_9e56_d06faa0eafcc0_all_processes $msg;       } else {           FME_LogMessage fme_inform \"FerryLink_Paths: Successfully ran workspace $workspaceFile\";       };       return SUCCESS;    }; }
FACTORY_DEF * TestFactory    FACTORY_NAME FerryLink_Paths_ExecutorAndRouter    INPUT  FEATURE_TYPE FerryLink_Roads_SUCCEEDED    INPUT  FEATURE_TYPE FerryLink_Roads_FAILED    TEST @Tcl2("FerryLink_Paths_aa9e18e8_8a61_4c05_9e56_d06faa0eafcc0_runner {(SourceDataset_GML,@EvaluateExpression(FDIV,STRING,$(PATHS_INPUT$encode)<backslash>Highways_Paths_FerryLink_*.gml.gz,FerryLink_Paths),DestDataset_GEOPACKAGE,@EvaluateExpression(FDIV,STRING,$(DEST_FOLDER$encode)<backslash>FerryLink_Paths.gpkg,FerryLink_Paths))} {FerryLink.fmw}") == SUCCESS    OUTPUT PASSED FEATURE_TYPE FerryLink_Paths_SUCCEEDED    OUTPUT FAILED FEATURE_TYPE FerryLink_Paths_FAILED
Tcl2 proc FerryLink_Paths_aa9e18e8_8a61_4c05_9e56_d06faa0eafcc0_summarizer { } {     global FerryLink_Paths_aa9e18e8_8a61_4c05_9e56_d06faa0eafcc0_process_count;     set comment { incr 0 creates the variable if it wasn't present };     incr FerryLink_Paths_aa9e18e8_8a61_4c05_9e56_d06faa0eafcc0_process_count 0;     FME_SetAttribute _proc_count [set FerryLink_Paths_aa9e18e8_8a61_4c05_9e56_d06faa0eafcc0_process_count];     global FerryLink_Paths_aa9e18e8_8a61_4c05_9e56_d06faa0eafcc0_all_processes;     if {[info exists FerryLink_Paths_aa9e18e8_8a61_4c05_9e56_d06faa0eafcc0_all_processes]} {         set index 0;         foreach pid [set FerryLink_Paths_aa9e18e8_8a61_4c05_9e56_d06faa0eafcc0_all_processes] {             FME_SetAttribute \"_processes{$index}\" $pid;             incr index;         }     } }
FACTORY_DEF * CreationFactory    FACTORY_NAME FerryLink_Paths_SummaryMaker    CREATE_AT_END yes
# -------------------------------------------------------------------------
# Convert the workspace name to one containing only / -- Tcl likes this better
# (and so do I)
# And determine the "NULL" device so we can ensure we don't get stray output
# messing up our stdout if we are running workspaces in the background
# See http://wiki.tcl.tk/1649 for a description of the tcl_platform
# variable, the "platform" part seems to have valid values windows, unix, and
# macintosh (the latter of which is actually pre-OS X)
Tcl2 if { $tcl_platform(platform) == {windows} } {         set ::null_device {NUL:};         set ::__WR_ENV_HELPER__ {};      } else {         set ::null_device {/dev/null};         set ::__WR_ENV_HELPER__ {/usr/bin/env FME_SUBPROCESS_RUN_DETACHED=1}      };
Tcl2 proc RoadNode_d0fbfa2c_074c_4b63_bba8_1d644ce0467a0_runner { parmListString workspaceFile } {    set workspaceFileUnix [regsub -all {\\} $workspaceFile {/}];    set parmListString [string range $parmListString 1 end-1];    set comment {        Build up the command line in a list, which we'll "eval" to get        at its pieces when we actually execute the "exec".    };    lappend commandArguments {*}$::__WR_ENV_HELPER__ {$(FME_HOME_UNIX)/fme}                             $workspaceFileUnix;    set parmList [split $parmListString {,}];    set comment {        At the same time, remember the TYPES for each of the parameters so        we can avoid logging any passwords in plain text (PR 64546)    };    set parmTypes [split {MULTIFILE,FILENAME} {,}];    set comment {        Note that foreach can walk thorugh more than one list at a time.        If the lists were ever out of sync (had different #s of entries, which should be impossible)        the iteration continues with the shorter list return an empty string. So we should be okay    };    set commandArgumentsToLog $commandArguments;    foreach {parmName encodedValue} $parmList parmType $parmTypes {       set comment {           Decode the parameter value which we now know is very encoded to guard           it from the parser and append them each to a new list which will be passed           as the arguments to the exec function.  Note that the           parameter names need to be turned into macro settings by           prepending them with --           Note also that the WorkspaceRunner sometimes encodes attribute           dereferences by placing <amp> at the beginning rather than using @Value.           Further note that string range forgives if the ending index is > the length of           the string, so we can just ask for the first 5 characters           when we're checking for <amp>.       };       if {[string length $parmName] == 0} { continue; };       lappend commandArguments \"--$parmName\";       lappend commandArgumentsToLog \"--$parmName\";       set comment {           for backwards compatibility, replace first <amp>       };       if { [string range $encodedValue 0 4] == {<amp>} &&            [string length $encodedValue] > 5 } {           set encodedValue [string replace $encodedValue 0 4 {<at>Value<openparen>}]];           append encodedValue "<closeparen>";       };       set comment { We used to call FME_DecodeTextOrAttr here. After changes to                     the code that writes out the mapping file section, we don't                     need to do this any more because the value would be in the                     correct state of encoding as required by the child workspace       };       set comment { parameter values starting with '<' causes tcl exec to fail so                     we escape leading '<' with backslash and then do the reverse                     when parsing command line arguments       };       if { [string index $encodedValue 0] == {<} } {          set encodedValue "\\$encodedValue";       };       lappend commandArguments $encodedValue;       set comment {           Ensure that passwords are not added into the logmessage (PR 64546)           We'll guard against both PASSWORD and PASSWORD_CONFIRM GUI types           by checking if the word PASSWORD is in the GUI TYPE at all       };       if { [string first {PASSWORD} $parmType] != -1 } {           lappend commandArgumentsToLog {***};       } else {           lappend commandArgumentsToLog $encodedValue;       };    };    set comment {        Now optionally run this in a detached way if we were not supposed        to wait by adding & on the end to put it in the background.  And        at the same time, ensure that any stray stdout/stderr is routed to        null.    };    if { {Yes} == {No} } {        lappend commandArguments \">$::null_device\";        lappend commandArgumentsToLog \">$::null_device\";        lappend commandArguments \"<$::null_device\";        lappend commandArgumentsToLog \"<$::null_device\";        FME_LogMessage fme_inform \"RoadNode: Initiating run of FME Workspace $workspaceFile with command line:\";    } else {        FME_LogMessage fme_inform \"RoadNode: Running FME Workspace $workspaceFile with command line:\";    };    set comment {        The below 2>@1 forces any standard error output to go into the msg variable        or to NULL if we're running in the background.    };    lappend commandArguments {2>@1};    lappend commandArgumentsToLog {2>@1};    if { {Yes} == {No} } {        lappend commandArguments {&};        lappend commandArgumentsToLog {&};    };    FME_LogMessage fme_inform [concat RoadNode: $commandArgumentsToLog];    if { {Yes} == {No} } {       after 1000;       while { [FME_CanSpawnFme <Unused>] == {0} } {             after 2000;       };    };    if {[catch {eval [concat exec $commandArguments] } msg ]} {       set msg [regsub {\015*\012child[^\012]*$} $msg {}];       FME_LogMessage fme_warn \"RoadNode: Failed to run workspace $workspaceFileUnix -- Trace was:\n\n$msg\n\";       FME_SetAttribute _failure_message $msg;       return FAILURE;    } else {       global RoadNode_d0fbfa2c_074c_4b63_bba8_1d644ce0467a0_process_count;       incr RoadNode_d0fbfa2c_074c_4b63_bba8_1d644ce0467a0_process_count;       if { {Yes} == {No} } {           FME_LogMessage fme_inform \"RoadNode: Successfully initiated run of workspace $workspaceFile\";           global RoadNode_d0fbfa2c_074c_4b63_bba8_1d644ce0467a0_all_processes;           lappend RoadNode_d0fbfa2c_074c_4b63_bba8_1d644ce0467a0_all_processes $msg;       } else {           FME_LogMessage fme_inform \"RoadNode: Successfully ran workspace $workspaceFile\";       };       return SUCCESS;    }; }
FACTORY_DEF * TestFactory    FACTORY_NAME RoadNode_ExecutorAndRouter    INPUT  FEATURE_TYPE FerryLink_Paths_SUCCEEDED    INPUT  FEATURE_TYPE FerryLink_Paths_FAILED    TEST @Tcl2("RoadNode_d0fbfa2c_074c_4b63_bba8_1d644ce0467a0_runner {(SourceDataset_GML,@EvaluateExpression(FDIV,STRING,$(ROADS_INPUT$encode)<backslash>Highways_Rrami_RoadNode_*.gml.gz,RoadNode),DestDataset_GEOPACKAGE,@EvaluateExpression(FDIV,STRING,$(DEST_FOLDER$encode)<backslash>RoadNode.gpkg,RoadNode))} {RoadNode.fmw}") == SUCCESS    OUTPUT PASSED FEATURE_TYPE RoadNode_SUCCEEDED    OUTPUT FAILED FEATURE_TYPE RoadNode_FAILED
Tcl2 proc RoadNode_d0fbfa2c_074c_4b63_bba8_1d644ce0467a0_summarizer { } {     global RoadNode_d0fbfa2c_074c_4b63_bba8_1d644ce0467a0_process_count;     set comment { incr 0 creates the variable if it wasn't present };     incr RoadNode_d0fbfa2c_074c_4b63_bba8_1d644ce0467a0_process_count 0;     FME_SetAttribute _proc_count [set RoadNode_d0fbfa2c_074c_4b63_bba8_1d644ce0467a0_process_count];     global RoadNode_d0fbfa2c_074c_4b63_bba8_1d644ce0467a0_all_processes;     if {[info exists RoadNode_d0fbfa2c_074c_4b63_bba8_1d644ce0467a0_all_processes]} {         set index 0;         foreach pid [set RoadNode_d0fbfa2c_074c_4b63_bba8_1d644ce0467a0_all_processes] {             FME_SetAttribute \"_processes{$index}\" $pid;             incr index;         }     } }
FACTORY_DEF * CreationFactory    FACTORY_NAME RoadNode_SummaryMaker    CREATE_AT_END yes
# -------------------------------------------------------------------------
# Convert the workspace name to one containing only / -- Tcl likes this better
# (and so do I)
# And determine the "NULL" device so we can ensure we don't get stray output
# messing up our stdout if we are running workspaces in the background
# See http://wiki.tcl.tk/1649 for a description of the tcl_platform
# variable, the "platform" part seems to have valid values windows, unix, and
# macintosh (the latter of which is actually pre-OS X)
Tcl2 if { $tcl_platform(platform) == {windows} } {         set ::null_device {NUL:};         set ::__WR_ENV_HELPER__ {};      } else {         set ::null_device {/dev/null};         set ::__WR_ENV_HELPER__ {/usr/bin/env FME_SUBPROCESS_RUN_DETACHED=1}      };
Tcl2 proc PathNode_93bb0541_14ed_48e8_9cab_1e50d7b3af220_runner { parmListString workspaceFile } {    set workspaceFileUnix [regsub -all {\\} $workspaceFile {/}];    set parmListString [string range $parmListString 1 end-1];    set comment {        Build up the command line in a list, which we'll "eval" to get        at its pieces when we actually execute the "exec".    };    lappend commandArguments {*}$::__WR_ENV_HELPER__ {$(FME_HOME_UNIX)/fme}                             $workspaceFileUnix;    set parmList [split $parmListString {,}];    set comment {        At the same time, remember the TYPES for each of the parameters so        we can avoid logging any passwords in plain text (PR 64546)    };    set parmTypes [split {MULTIFILE,FILENAME} {,}];    set comment {        Note that foreach can walk thorugh more than one list at a time.        If the lists were ever out of sync (had different #s of entries, which should be impossible)        the iteration continues with the shorter list return an empty string. So we should be okay    };    set commandArgumentsToLog $commandArguments;    foreach {parmName encodedValue} $parmList parmType $parmTypes {       set comment {           Decode the parameter value which we now know is very encoded to guard           it from the parser and append them each to a new list which will be passed           as the arguments to the exec function.  Note that the           parameter names need to be turned into macro settings by           prepending them with --           Note also that the WorkspaceRunner sometimes encodes attribute           dereferences by placing <amp> at the beginning rather than using @Value.           Further note that string range forgives if the ending index is > the length of           the string, so we can just ask for the first 5 characters           when we're checking for <amp>.       };       if {[string length $parmName] == 0} { continue; };       lappend commandArguments \"--$parmName\";       lappend commandArgumentsToLog \"--$parmName\";       set comment {           for backwards compatibility, replace first <amp>       };       if { [string range $encodedValue 0 4] == {<amp>} &&            [string length $encodedValue] > 5 } {           set encodedValue [string replace $encodedValue 0 4 {<at>Value<openparen>}]];           append encodedValue "<closeparen>";       };       set comment { We used to call FME_DecodeTextOrAttr here. After changes to                     the code that writes out the mapping file section, we don't                     need to do this any more because the value would be in the                     correct state of encoding as required by the child workspace       };       set comment { parameter values starting with '<' causes tcl exec to fail so                     we escape leading '<' with backslash and then do the reverse                     when parsing command line arguments       };       if { [string index $encodedValue 0] == {<} } {          set encodedValue "\\$encodedValue";       };       lappend commandArguments $encodedValue;       set comment {           Ensure that passwords are not added into the logmessage (PR 64546)           We'll guard against both PASSWORD and PASSWORD_CONFIRM GUI types           by checking if the word PASSWORD is in the GUI TYPE at all       };       if { [string first {PASSWORD} $parmType] != -1 } {           lappend commandArgumentsToLog {***};       } else {           lappend commandArgumentsToLog $encodedValue;       };    };    set comment {        Now optionally run this in a detached way if we were not supposed        to wait by adding & on the end to put it in the background.  And        at the same time, ensure that any stray stdout/stderr is routed to        null.    };    if { {Yes} == {No} } {        lappend commandArguments \">$::null_device\";        lappend commandArgumentsToLog \">$::null_device\";        lappend commandArguments \"<$::null_device\";        lappend commandArgumentsToLog \"<$::null_device\";        FME_LogMessage fme_inform \"PathNode: Initiating run of FME Workspace $workspaceFile with command line:\";    } else {        FME_LogMessage fme_inform \"PathNode: Running FME Workspace $workspaceFile with command line:\";    };    set comment {        The below 2>@1 forces any standard error output to go into the msg variable        or to NULL if we're running in the background.    };    lappend commandArguments {2>@1};    lappend commandArgumentsToLog {2>@1};    if { {Yes} == {No} } {        lappend commandArguments {&};        lappend commandArgumentsToLog {&};    };    FME_LogMessage fme_inform [concat PathNode: $commandArgumentsToLog];    if { {Yes} == {No} } {       after 1000;       while { [FME_CanSpawnFme <Unused>] == {0} } {             after 2000;       };    };    if {[catch {eval [concat exec $commandArguments] } msg ]} {       set msg [regsub {\015*\012child[^\012]*$} $msg {}];       FME_LogMessage fme_warn \"PathNode: Failed to run workspace $workspaceFileUnix -- Trace was:\n\n$msg\n\";       FME_SetAttribute _failure_message $msg;       return FAILURE;    } else {       global PathNode_93bb0541_14ed_48e8_9cab_1e50d7b3af220_process_count;       incr PathNode_93bb0541_14ed_48e8_9cab_1e50d7b3af220_process_count;       if { {Yes} == {No} } {           FME_LogMessage fme_inform \"PathNode: Successfully initiated run of workspace $workspaceFile\";           global PathNode_93bb0541_14ed_48e8_9cab_1e50d7b3af220_all_processes;           lappend PathNode_93bb0541_14ed_48e8_9cab_1e50d7b3af220_all_processes $msg;       } else {           FME_LogMessage fme_inform \"PathNode: Successfully ran workspace $workspaceFile\";       };       return SUCCESS;    }; }
FACTORY_DEF * TestFactory    FACTORY_NAME PathNode_ExecutorAndRouter    INPUT  FEATURE_TYPE RoadNode_SUCCEEDED    INPUT  FEATURE_TYPE RoadNode_FAILED    TEST @Tcl2("PathNode_93bb0541_14ed_48e8_9cab_1e50d7b3af220_runner {(SourceDataset_GML,@EvaluateExpression(FDIV,STRING,$(PATHS_INPUT$encode)<backslash>Highways_Paths_PathNode_*.gml.gz,PathNode),DestDataset_GEOPACKAGE,@EvaluateExpression(FDIV,STRING,$(DEST_FOLDER$encode)<backslash>PathNode.gpkg,PathNode))} {PathNode.fmw}") == SUCCESS    OUTPUT PASSED FEATURE_TYPE PathNode_SUCCEEDED    OUTPUT FAILED FEATURE_TYPE PathNode_FAILED
Tcl2 proc PathNode_93bb0541_14ed_48e8_9cab_1e50d7b3af220_summarizer { } {     global PathNode_93bb0541_14ed_48e8_9cab_1e50d7b3af220_process_count;     set comment { incr 0 creates the variable if it wasn't present };     incr PathNode_93bb0541_14ed_48e8_9cab_1e50d7b3af220_process_count 0;     FME_SetAttribute _proc_count [set PathNode_93bb0541_14ed_48e8_9cab_1e50d7b3af220_process_count];     global PathNode_93bb0541_14ed_48e8_9cab_1e50d7b3af220_all_processes;     if {[info exists PathNode_93bb0541_14ed_48e8_9cab_1e50d7b3af220_all_processes]} {         set index 0;         foreach pid [set PathNode_93bb0541_14ed_48e8_9cab_1e50d7b3af220_all_processes] {             FME_SetAttribute \"_processes{$index}\" $pid;             incr index;         }     } }
FACTORY_DEF * CreationFactory    FACTORY_NAME PathNode_SummaryMaker    CREATE_AT_END yes
# -------------------------------------------------------------------------
# Convert the workspace name to one containing only / -- Tcl likes this better
# (and so do I)
# And determine the "NULL" device so we can ensure we don't get stray output
# messing up our stdout if we are running workspaces in the background
# See http://wiki.tcl.tk/1649 for a description of the tcl_platform
# variable, the "platform" part seems to have valid values windows, unix, and
# macintosh (the latter of which is actually pre-OS X)
Tcl2 if { $tcl_platform(platform) == {windows} } {         set ::null_device {NUL:};         set ::__WR_ENV_HELPER__ {};      } else {         set ::null_device {/dev/null};         set ::__WR_ENV_HELPER__ {/usr/bin/env FME_SUBPROCESS_RUN_DETACHED=1}      };
Tcl2 proc ConnectingNode_3aa67452_625d_4ff4_9b53_4a8e04cba9750_runner { parmListString workspaceFile } {    set workspaceFileUnix [regsub -all {\\} $workspaceFile {/}];    set parmListString [string range $parmListString 1 end-1];    set comment {        Build up the command line in a list, which we'll "eval" to get        at its pieces when we actually execute the "exec".    };    lappend commandArguments {*}$::__WR_ENV_HELPER__ {$(FME_HOME_UNIX)/fme}                             $workspaceFileUnix;    set parmList [split $parmListString {,}];    set comment {        At the same time, remember the TYPES for each of the parameters so        we can avoid logging any passwords in plain text (PR 64546)    };    set parmTypes [split {MULTIFILE,FILENAME} {,}];    set comment {        Note that foreach can walk thorugh more than one list at a time.        If the lists were ever out of sync (had different #s of entries, which should be impossible)        the iteration continues with the shorter list return an empty string. So we should be okay    };    set commandArgumentsToLog $commandArguments;    foreach {parmName encodedValue} $parmList parmType $parmTypes {       set comment {           Decode the parameter value which we now know is very encoded to guard           it from the parser and append them each to a new list which will be passed           as the arguments to the exec function.  Note that the           parameter names need to be turned into macro settings by           prepending them with --           Note also that the WorkspaceRunner sometimes encodes attribute           dereferences by placing <amp> at the beginning rather than using @Value.           Further note that string range forgives if the ending index is > the length of           the string, so we can just ask for the first 5 characters           when we're checking for <amp>.       };       if {[string length $parmName] == 0} { continue; };       lappend commandArguments \"--$parmName\";       lappend commandArgumentsToLog \"--$parmName\";       set comment {           for backwards compatibility, replace first <amp>       };       if { [string range $encodedValue 0 4] == {<amp>} &&            [string length $encodedValue] > 5 } {           set encodedValue [string replace $encodedValue 0 4 {<at>Value<openparen>}]];           append encodedValue "<closeparen>";       };       set comment { We used to call FME_DecodeTextOrAttr here. After changes to                     the code that writes out the mapping file section, we don't                     need to do this any more because the value would be in the                     correct state of encoding as required by the child workspace       };       set comment { parameter values starting with '<' causes tcl exec to fail so                     we escape leading '<' with backslash and then do the reverse                     when parsing command line arguments       };       if { [string index $encodedValue 0] == {<} } {          set encodedValue "\\$encodedValue";       };       lappend commandArguments $encodedValue;       set comment {           Ensure that passwords are not added into the logmessage (PR 64546)           We'll guard against both PASSWORD and PASSWORD_CONFIRM GUI types           by checking if the word PASSWORD is in the GUI TYPE at all       };       if { [string first {PASSWORD} $parmType] != -1 } {           lappend commandArgumentsToLog {***};       } else {           lappend commandArgumentsToLog $encodedValue;       };    };    set comment {        Now optionally run this in a detached way if we were not supposed        to wait by adding & on the end to put it in the background.  And        at the same time, ensure that any stray stdout/stderr is routed to        null.    };    if { {Yes} == {No} } {        lappend commandArguments \">$::null_device\";        lappend commandArgumentsToLog \">$::null_device\";        lappend commandArguments \"<$::null_device\";        lappend commandArgumentsToLog \"<$::null_device\";        FME_LogMessage fme_inform \"ConnectingNode: Initiating run of FME Workspace $workspaceFile with command line:\";    } else {        FME_LogMessage fme_inform \"ConnectingNode: Running FME Workspace $workspaceFile with command line:\";    };    set comment {        The below 2>@1 forces any standard error output to go into the msg variable        or to NULL if we're running in the background.    };    lappend commandArguments {2>@1};    lappend commandArgumentsToLog {2>@1};    if { {Yes} == {No} } {        lappend commandArguments {&};        lappend commandArgumentsToLog {&};    };    FME_LogMessage fme_inform [concat ConnectingNode: $commandArgumentsToLog];    if { {Yes} == {No} } {       after 1000;       while { [FME_CanSpawnFme <Unused>] == {0} } {             after 2000;       };    };    if {[catch {eval [concat exec $commandArguments] } msg ]} {       set msg [regsub {\015*\012child[^\012]*$} $msg {}];       FME_LogMessage fme_warn \"ConnectingNode: Failed to run workspace $workspaceFileUnix -- Trace was:\n\n$msg\n\";       FME_SetAttribute _failure_message $msg;       return FAILURE;    } else {       global ConnectingNode_3aa67452_625d_4ff4_9b53_4a8e04cba9750_process_count;       incr ConnectingNode_3aa67452_625d_4ff4_9b53_4a8e04cba9750_process_count;       if { {Yes} == {No} } {           FME_LogMessage fme_inform \"ConnectingNode: Successfully initiated run of workspace $workspaceFile\";           global ConnectingNode_3aa67452_625d_4ff4_9b53_4a8e04cba9750_all_processes;           lappend ConnectingNode_3aa67452_625d_4ff4_9b53_4a8e04cba9750_all_processes $msg;       } else {           FME_LogMessage fme_inform \"ConnectingNode: Successfully ran workspace $workspaceFile\";       };       return SUCCESS;    }; }
FACTORY_DEF * TestFactory    FACTORY_NAME ConnectingNode_ExecutorAndRouter    INPUT  FEATURE_TYPE PathNode_SUCCEEDED    INPUT  FEATURE_TYPE PathNode_FAILED    TEST @Tcl2("ConnectingNode_3aa67452_625d_4ff4_9b53_4a8e04cba9750_runner {(SourceDataset_GML,@EvaluateExpression(FDIV,STRING,$(PATHS_INPUT$encode)<backslash>Highways_Paths_ConnectingNode_*.gml.gz,ConnectingNode),DestDataset_GEOPACKAGE,@EvaluateExpression(FDIV,STRING,$(DEST_FOLDER$encode)<backslash>ConnectingNode.gpkg,ConnectingNode))} {ConnectingNode.fmw}") == SUCCESS    OUTPUT PASSED FEATURE_TYPE ConnectingNode_SUCCEEDED    OUTPUT FAILED FEATURE_TYPE ConnectingNode_FAILED
Tcl2 proc ConnectingNode_3aa67452_625d_4ff4_9b53_4a8e04cba9750_summarizer { } {     global ConnectingNode_3aa67452_625d_4ff4_9b53_4a8e04cba9750_process_count;     set comment { incr 0 creates the variable if it wasn't present };     incr ConnectingNode_3aa67452_625d_4ff4_9b53_4a8e04cba9750_process_count 0;     FME_SetAttribute _proc_count [set ConnectingNode_3aa67452_625d_4ff4_9b53_4a8e04cba9750_process_count];     global ConnectingNode_3aa67452_625d_4ff4_9b53_4a8e04cba9750_all_processes;     if {[info exists ConnectingNode_3aa67452_625d_4ff4_9b53_4a8e04cba9750_all_processes]} {         set index 0;         foreach pid [set ConnectingNode_3aa67452_625d_4ff4_9b53_4a8e04cba9750_all_processes] {             FME_SetAttribute \"_processes{$index}\" $pid;             incr index;         }     } }
FACTORY_DEF * CreationFactory    FACTORY_NAME ConnectingNode_SummaryMaker    CREATE_AT_END yes
# -------------------------------------------------------------------------
# Convert the workspace name to one containing only / -- Tcl likes this better
# (and so do I)
# And determine the "NULL" device so we can ensure we don't get stray output
# messing up our stdout if we are running workspaces in the background
# See http://wiki.tcl.tk/1649 for a description of the tcl_platform
# variable, the "platform" part seems to have valid values windows, unix, and
# macintosh (the latter of which is actually pre-OS X)
Tcl2 if { $tcl_platform(platform) == {windows} } {         set ::null_device {NUL:};         set ::__WR_ENV_HELPER__ {};      } else {         set ::null_device {/dev/null};         set ::__WR_ENV_HELPER__ {/usr/bin/env FME_SUBPROCESS_RUN_DETACHED=1}      };
Tcl2 proc FerryNode_Roads_df4297bf_58e3_405d_8370_f81e2ed97a750_runner { parmListString workspaceFile } {    set workspaceFileUnix [regsub -all {\\} $workspaceFile {/}];    set parmListString [string range $parmListString 1 end-1];    set comment {        Build up the command line in a list, which we'll "eval" to get        at its pieces when we actually execute the "exec".    };    lappend commandArguments {*}$::__WR_ENV_HELPER__ {$(FME_HOME_UNIX)/fme}                             $workspaceFileUnix;    set parmList [split $parmListString {,}];    set comment {        At the same time, remember the TYPES for each of the parameters so        we can avoid logging any passwords in plain text (PR 64546)    };    set parmTypes [split {MULTIFILE,FILENAME} {,}];    set comment {        Note that foreach can walk thorugh more than one list at a time.        If the lists were ever out of sync (had different #s of entries, which should be impossible)        the iteration continues with the shorter list return an empty string. So we should be okay    };    set commandArgumentsToLog $commandArguments;    foreach {parmName encodedValue} $parmList parmType $parmTypes {       set comment {           Decode the parameter value which we now know is very encoded to guard           it from the parser and append them each to a new list which will be passed           as the arguments to the exec function.  Note that the           parameter names need to be turned into macro settings by           prepending them with --           Note also that the WorkspaceRunner sometimes encodes attribute           dereferences by placing <amp> at the beginning rather than using @Value.           Further note that string range forgives if the ending index is > the length of           the string, so we can just ask for the first 5 characters           when we're checking for <amp>.       };       if {[string length $parmName] == 0} { continue; };       lappend commandArguments \"--$parmName\";       lappend commandArgumentsToLog \"--$parmName\";       set comment {           for backwards compatibility, replace first <amp>       };       if { [string range $encodedValue 0 4] == {<amp>} &&            [string length $encodedValue] > 5 } {           set encodedValue [string replace $encodedValue 0 4 {<at>Value<openparen>}]];           append encodedValue "<closeparen>";       };       set comment { We used to call FME_DecodeTextOrAttr here. After changes to                     the code that writes out the mapping file section, we don't                     need to do this any more because the value would be in the                     correct state of encoding as required by the child workspace       };       set comment { parameter values starting with '<' causes tcl exec to fail so                     we escape leading '<' with backslash and then do the reverse                     when parsing command line arguments       };       if { [string index $encodedValue 0] == {<} } {          set encodedValue "\\$encodedValue";       };       lappend commandArguments $encodedValue;       set comment {           Ensure that passwords are not added into the logmessage (PR 64546)           We'll guard against both PASSWORD and PASSWORD_CONFIRM GUI types           by checking if the word PASSWORD is in the GUI TYPE at all       };       if { [string first {PASSWORD} $parmType] != -1 } {           lappend commandArgumentsToLog {***};       } else {           lappend commandArgumentsToLog $encodedValue;       };    };    set comment {        Now optionally run this in a detached way if we were not supposed        to wait by adding & on the end to put it in the background.  And        at the same time, ensure that any stray stdout/stderr is routed to        null.    };    if { {Yes} == {No} } {        lappend commandArguments \">$::null_device\";        lappend commandArgumentsToLog \">$::null_device\";        lappend commandArguments \"<$::null_device\";        lappend commandArgumentsToLog \"<$::null_device\";        FME_LogMessage fme_inform \"FerryNode_Roads: Initiating run of FME Workspace $workspaceFile with command line:\";    } else {        FME_LogMessage fme_inform \"FerryNode_Roads: Running FME Workspace $workspaceFile with command line:\";    };    set comment {        The below 2>@1 forces any standard error output to go into the msg variable        or to NULL if we're running in the background.    };    lappend commandArguments {2>@1};    lappend commandArgumentsToLog {2>@1};    if { {Yes} == {No} } {        lappend commandArguments {&};        lappend commandArgumentsToLog {&};    };    FME_LogMessage fme_inform [concat FerryNode_Roads: $commandArgumentsToLog];    if { {Yes} == {No} } {       after 1000;       while { [FME_CanSpawnFme <Unused>] == {0} } {             after 2000;       };    };    if {[catch {eval [concat exec $commandArguments] } msg ]} {       set msg [regsub {\015*\012child[^\012]*$} $msg {}];       FME_LogMessage fme_warn \"FerryNode_Roads: Failed to run workspace $workspaceFileUnix -- Trace was:\n\n$msg\n\";       FME_SetAttribute _failure_message $msg;       return FAILURE;    } else {       global FerryNode_Roads_df4297bf_58e3_405d_8370_f81e2ed97a750_process_count;       incr FerryNode_Roads_df4297bf_58e3_405d_8370_f81e2ed97a750_process_count;       if { {Yes} == {No} } {           FME_LogMessage fme_inform \"FerryNode_Roads: Successfully initiated run of workspace $workspaceFile\";           global FerryNode_Roads_df4297bf_58e3_405d_8370_f81e2ed97a750_all_processes;           lappend FerryNode_Roads_df4297bf_58e3_405d_8370_f81e2ed97a750_all_processes $msg;       } else {           FME_LogMessage fme_inform \"FerryNode_Roads: Successfully ran workspace $workspaceFile\";       };       return SUCCESS;    }; }
FACTORY_DEF * TestFactory    FACTORY_NAME FerryNode_Roads_ExecutorAndRouter    INPUT  FEATURE_TYPE ConnectingNode_SUCCEEDED    INPUT  FEATURE_TYPE ConnectingNode_FAILED    TEST @Tcl2("FerryNode_Roads_df4297bf_58e3_405d_8370_f81e2ed97a750_runner {(SourceDataset_GML,@EvaluateExpression(FDIV,STRING,$(ROADS_INPUT$encode)<backslash>Highways_Rrami_FerryNode_*.gml.gz,FerryNode_Roads),DestDataset_GEOPACKAGE,@EvaluateExpression(FDIV,STRING,$(DEST_FOLDER$encode)<backslash>FerryNode_Roads.gpkg,FerryNode_Roads))} {FerryNode.fmw}") == SUCCESS    OUTPUT PASSED FEATURE_TYPE FerryNode_Roads_SUCCEEDED    OUTPUT FAILED FEATURE_TYPE FerryNode_Roads_FAILED
Tcl2 proc FerryNode_Roads_df4297bf_58e3_405d_8370_f81e2ed97a750_summarizer { } {     global FerryNode_Roads_df4297bf_58e3_405d_8370_f81e2ed97a750_process_count;     set comment { incr 0 creates the variable if it wasn't present };     incr FerryNode_Roads_df4297bf_58e3_405d_8370_f81e2ed97a750_process_count 0;     FME_SetAttribute _proc_count [set FerryNode_Roads_df4297bf_58e3_405d_8370_f81e2ed97a750_process_count];     global FerryNode_Roads_df4297bf_58e3_405d_8370_f81e2ed97a750_all_processes;     if {[info exists FerryNode_Roads_df4297bf_58e3_405d_8370_f81e2ed97a750_all_processes]} {         set index 0;         foreach pid [set FerryNode_Roads_df4297bf_58e3_405d_8370_f81e2ed97a750_all_processes] {             FME_SetAttribute \"_processes{$index}\" $pid;             incr index;         }     } }
FACTORY_DEF * CreationFactory    FACTORY_NAME FerryNode_Roads_SummaryMaker    CREATE_AT_END yes
# -------------------------------------------------------------------------
# Convert the workspace name to one containing only / -- Tcl likes this better
# (and so do I)
# And determine the "NULL" device so we can ensure we don't get stray output
# messing up our stdout if we are running workspaces in the background
# See http://wiki.tcl.tk/1649 for a description of the tcl_platform
# variable, the "platform" part seems to have valid values windows, unix, and
# macintosh (the latter of which is actually pre-OS X)
Tcl2 if { $tcl_platform(platform) == {windows} } {         set ::null_device {NUL:};         set ::__WR_ENV_HELPER__ {};      } else {         set ::null_device {/dev/null};         set ::__WR_ENV_HELPER__ {/usr/bin/env FME_SUBPROCESS_RUN_DETACHED=1}      };
Tcl2 proc FerryNode_Paths_5874c05b_19e6_4b43_beeb_fa105448554e0_runner { parmListString workspaceFile } {    set workspaceFileUnix [regsub -all {\\} $workspaceFile {/}];    set parmListString [string range $parmListString 1 end-1];    set comment {        Build up the command line in a list, which we'll "eval" to get        at its pieces when we actually execute the "exec".    };    lappend commandArguments {*}$::__WR_ENV_HELPER__ {$(FME_HOME_UNIX)/fme}                             $workspaceFileUnix;    set parmList [split $parmListString {,}];    set comment {        At the same time, remember the TYPES for each of the parameters so        we can avoid logging any passwords in plain text (PR 64546)    };    set parmTypes [split {MULTIFILE,FILENAME} {,}];    set comment {        Note that foreach can walk thorugh more than one list at a time.        If the lists were ever out of sync (had different #s of entries, which should be impossible)        the iteration continues with the shorter list return an empty string. So we should be okay    };    set commandArgumentsToLog $commandArguments;    foreach {parmName encodedValue} $parmList parmType $parmTypes {       set comment {           Decode the parameter value which we now know is very encoded to guard           it from the parser and append them each to a new list which will be passed           as the arguments to the exec function.  Note that the           parameter names need to be turned into macro settings by           prepending them with --           Note also that the WorkspaceRunner sometimes encodes attribute           dereferences by placing <amp> at the beginning rather than using @Value.           Further note that string range forgives if the ending index is > the length of           the string, so we can just ask for the first 5 characters           when we're checking for <amp>.       };       if {[string length $parmName] == 0} { continue; };       lappend commandArguments \"--$parmName\";       lappend commandArgumentsToLog \"--$parmName\";       set comment {           for backwards compatibility, replace first <amp>       };       if { [string range $encodedValue 0 4] == {<amp>} &&            [string length $encodedValue] > 5 } {           set encodedValue [string replace $encodedValue 0 4 {<at>Value<openparen>}]];           append encodedValue "<closeparen>";       };       set comment { We used to call FME_DecodeTextOrAttr here. After changes to                     the code that writes out the mapping file section, we don't                     need to do this any more because the value would be in the                     correct state of encoding as required by the child workspace       };       set comment { parameter values starting with '<' causes tcl exec to fail so                     we escape leading '<' with backslash and then do the reverse                     when parsing command line arguments       };       if { [string index $encodedValue 0] == {<} } {          set encodedValue "\\$encodedValue";       };       lappend commandArguments $encodedValue;       set comment {           Ensure that passwords are not added into the logmessage (PR 64546)           We'll guard against both PASSWORD and PASSWORD_CONFIRM GUI types           by checking if the word PASSWORD is in the GUI TYPE at all       };       if { [string first {PASSWORD} $parmType] != -1 } {           lappend commandArgumentsToLog {***};       } else {           lappend commandArgumentsToLog $encodedValue;       };    };    set comment {        Now optionally run this in a detached way if we were not supposed        to wait by adding & on the end to put it in the background.  And        at the same time, ensure that any stray stdout/stderr is routed to        null.    };    if { {Yes} == {No} } {        lappend commandArguments \">$::null_device\";        lappend commandArgumentsToLog \">$::null_device\";        lappend commandArguments \"<$::null_device\";        lappend commandArgumentsToLog \"<$::null_device\";        FME_LogMessage fme_inform \"FerryNode_Paths: Initiating run of FME Workspace $workspaceFile with command line:\";    } else {        FME_LogMessage fme_inform \"FerryNode_Paths: Running FME Workspace $workspaceFile with command line:\";    };    set comment {        The below 2>@1 forces any standard error output to go into the msg variable        or to NULL if we're running in the background.    };    lappend commandArguments {2>@1};    lappend commandArgumentsToLog {2>@1};    if { {Yes} == {No} } {        lappend commandArguments {&};        lappend commandArgumentsToLog {&};    };    FME_LogMessage fme_inform [concat FerryNode_Paths: $commandArgumentsToLog];    if { {Yes} == {No} } {       after 1000;       while { [FME_CanSpawnFme <Unused>] == {0} } {             after 2000;       };    };    if {[catch {eval [concat exec $commandArguments] } msg ]} {       set msg [regsub {\015*\012child[^\012]*$} $msg {}];       FME_LogMessage fme_warn \"FerryNode_Paths: Failed to run workspace $workspaceFileUnix -- Trace was:\n\n$msg\n\";       FME_SetAttribute _failure_message $msg;       return FAILURE;    } else {       global FerryNode_Paths_5874c05b_19e6_4b43_beeb_fa105448554e0_process_count;       incr FerryNode_Paths_5874c05b_19e6_4b43_beeb_fa105448554e0_process_count;       if { {Yes} == {No} } {           FME_LogMessage fme_inform \"FerryNode_Paths: Successfully initiated run of workspace $workspaceFile\";           global FerryNode_Paths_5874c05b_19e6_4b43_beeb_fa105448554e0_all_processes;           lappend FerryNode_Paths_5874c05b_19e6_4b43_beeb_fa105448554e0_all_processes $msg;       } else {           FME_LogMessage fme_inform \"FerryNode_Paths: Successfully ran workspace $workspaceFile\";       };       return SUCCESS;    }; }
FACTORY_DEF * TestFactory    FACTORY_NAME FerryNode_Paths_ExecutorAndRouter    INPUT  FEATURE_TYPE FerryNode_Roads_SUCCEEDED    INPUT  FEATURE_TYPE FerryNode_Roads_FAILED    TEST @Tcl2("FerryNode_Paths_5874c05b_19e6_4b43_beeb_fa105448554e0_runner {(SourceDataset_GML,@EvaluateExpression(FDIV,STRING,$(PATHS_INPUT$encode)<backslash>Highways_Paths_FerryNode_*.gml.gz,FerryNode_Paths),DestDataset_GEOPACKAGE,@EvaluateExpression(FDIV,STRING,$(DEST_FOLDER$encode)<backslash>FerryNode_Paths.gpkg,FerryNode_Paths))} {FerryNode.fmw}") == SUCCESS    OUTPUT PASSED FEATURE_TYPE FerryNode_Paths_SUCCEEDED    OUTPUT FAILED FEATURE_TYPE FerryNode_Paths_FAILED
Tcl2 proc FerryNode_Paths_5874c05b_19e6_4b43_beeb_fa105448554e0_summarizer { } {     global FerryNode_Paths_5874c05b_19e6_4b43_beeb_fa105448554e0_process_count;     set comment { incr 0 creates the variable if it wasn't present };     incr FerryNode_Paths_5874c05b_19e6_4b43_beeb_fa105448554e0_process_count 0;     FME_SetAttribute _proc_count [set FerryNode_Paths_5874c05b_19e6_4b43_beeb_fa105448554e0_process_count];     global FerryNode_Paths_5874c05b_19e6_4b43_beeb_fa105448554e0_all_processes;     if {[info exists FerryNode_Paths_5874c05b_19e6_4b43_beeb_fa105448554e0_all_processes]} {         set index 0;         foreach pid [set FerryNode_Paths_5874c05b_19e6_4b43_beeb_fa105448554e0_all_processes] {             FME_SetAttribute \"_processes{$index}\" $pid;             incr index;         }     } }
FACTORY_DEF * CreationFactory    FACTORY_NAME FerryNode_Paths_SummaryMaker    CREATE_AT_END yes
# -------------------------------------------------------------------------
# Convert the workspace name to one containing only / -- Tcl likes this better
# (and so do I)
# And determine the "NULL" device so we can ensure we don't get stray output
# messing up our stdout if we are running workspaces in the background
# See http://wiki.tcl.tk/1649 for a description of the tcl_platform
# variable, the "platform" part seems to have valid values windows, unix, and
# macintosh (the latter of which is actually pre-OS X)
Tcl2 if { $tcl_platform(platform) == {windows} } {         set ::null_device {NUL:};         set ::__WR_ENV_HELPER__ {};      } else {         set ::null_device {/dev/null};         set ::__WR_ENV_HELPER__ {/usr/bin/env FME_SUBPROCESS_RUN_DETACHED=1}      };
Tcl2 proc Street_Roads_12e8775c_2c06_468f_b7e3_b3a742174ba60_runner { parmListString workspaceFile } {    set workspaceFileUnix [regsub -all {\\} $workspaceFile {/}];    set parmListString [string range $parmListString 1 end-1];    set comment {        Build up the command line in a list, which we'll "eval" to get        at its pieces when we actually execute the "exec".    };    lappend commandArguments {*}$::__WR_ENV_HELPER__ {$(FME_HOME_UNIX)/fme}                             $workspaceFileUnix;    set parmList [split $parmListString {,}];    set comment {        At the same time, remember the TYPES for each of the parameters so        we can avoid logging any passwords in plain text (PR 64546)    };    set parmTypes [split {MULTIFILE,FILENAME} {,}];    set comment {        Note that foreach can walk thorugh more than one list at a time.        If the lists were ever out of sync (had different #s of entries, which should be impossible)        the iteration continues with the shorter list return an empty string. So we should be okay    };    set commandArgumentsToLog $commandArguments;    foreach {parmName encodedValue} $parmList parmType $parmTypes {       set comment {           Decode the parameter value which we now know is very encoded to guard           it from the parser and append them each to a new list which will be passed           as the arguments to the exec function.  Note that the           parameter names need to be turned into macro settings by           prepending them with --           Note also that the WorkspaceRunner sometimes encodes attribute           dereferences by placing <amp> at the beginning rather than using @Value.           Further note that string range forgives if the ending index is > the length of           the string, so we can just ask for the first 5 characters           when we're checking for <amp>.       };       if {[string length $parmName] == 0} { continue; };       lappend commandArguments \"--$parmName\";       lappend commandArgumentsToLog \"--$parmName\";       set comment {           for backwards compatibility, replace first <amp>       };       if { [string range $encodedValue 0 4] == {<amp>} &&            [string length $encodedValue] > 5 } {           set encodedValue [string replace $encodedValue 0 4 {<at>Value<openparen>}]];           append encodedValue "<closeparen>";       };       set comment { We used to call FME_DecodeTextOrAttr here. After changes to                     the code that writes out the mapping file section, we don't                     need to do this any more because the value would be in the                     correct state of encoding as required by the child workspace       };       set comment { parameter values starting with '<' causes tcl exec to fail so                     we escape leading '<' with backslash and then do the reverse                     when parsing command line arguments       };       if { [string index $encodedValue 0] == {<} } {          set encodedValue "\\$encodedValue";       };       lappend commandArguments $encodedValue;       set comment {           Ensure that passwords are not added into the logmessage (PR 64546)           We'll guard against both PASSWORD and PASSWORD_CONFIRM GUI types           by checking if the word PASSWORD is in the GUI TYPE at all       };       if { [string first {PASSWORD} $parmType] != -1 } {           lappend commandArgumentsToLog {***};       } else {           lappend commandArgumentsToLog $encodedValue;       };    };    set comment {        Now optionally run this in a detached way if we were not supposed        to wait by adding & on the end to put it in the background.  And        at the same time, ensure that any stray stdout/stderr is routed to        null.    };    if { {Yes} == {No} } {        lappend commandArguments \">$::null_device\";        lappend commandArgumentsToLog \">$::null_device\";        lappend commandArguments \"<$::null_device\";        lappend commandArgumentsToLog \"<$::null_device\";        FME_LogMessage fme_inform \"Street_Roads: Initiating run of FME Workspace $workspaceFile with command line:\";    } else {        FME_LogMessage fme_inform \"Street_Roads: Running FME Workspace $workspaceFile with command line:\";    };    set comment {        The below 2>@1 forces any standard error output to go into the msg variable        or to NULL if we're running in the background.    };    lappend commandArguments {2>@1};    lappend commandArgumentsToLog {2>@1};    if { {Yes} == {No} } {        lappend commandArguments {&};        lappend commandArgumentsToLog {&};    };    FME_LogMessage fme_inform [concat Street_Roads: $commandArgumentsToLog];    if { {Yes} == {No} } {       after 1000;       while { [FME_CanSpawnFme <Unused>] == {0} } {             after 2000;       };    };    if {[catch {eval [concat exec $commandArguments] } msg ]} {       set msg [regsub {\015*\012child[^\012]*$} $msg {}];       FME_LogMessage fme_warn \"Street_Roads: Failed to run workspace $workspaceFileUnix -- Trace was:\n\n$msg\n\";       FME_SetAttribute _failure_message $msg;       return FAILURE;    } else {       global Street_Roads_12e8775c_2c06_468f_b7e3_b3a742174ba60_process_count;       incr Street_Roads_12e8775c_2c06_468f_b7e3_b3a742174ba60_process_count;       if { {Yes} == {No} } {           FME_LogMessage fme_inform \"Street_Roads: Successfully initiated run of workspace $workspaceFile\";           global Street_Roads_12e8775c_2c06_468f_b7e3_b3a742174ba60_all_processes;           lappend Street_Roads_12e8775c_2c06_468f_b7e3_b3a742174ba60_all_processes $msg;       } else {           FME_LogMessage fme_inform \"Street_Roads: Successfully ran workspace $workspaceFile\";       };       return SUCCESS;    }; }
FACTORY_DEF * TestFactory    FACTORY_NAME Street_Roads_ExecutorAndRouter    INPUT  FEATURE_TYPE FerryNode_Paths_SUCCEEDED    INPUT  FEATURE_TYPE FerryNode_Paths_FAILED    TEST @Tcl2("Street_Roads_12e8775c_2c06_468f_b7e3_b3a742174ba60_runner {(SourceDataset_Street,@EvaluateExpression(FDIV,STRING,$(ROADS_INPUT$encode)<backslash>Highways_Rrami_Street_*.gml.gz,Street_Roads),DestDataset_Street,@EvaluateExpression(FDIV,STRING,$(DEST_FOLDER$encode)<backslash>Street_Roads.gpkg,Street_Roads))} {Street.fmw}") == SUCCESS    OUTPUT PASSED FEATURE_TYPE Street_Roads_SUCCEEDED    OUTPUT FAILED FEATURE_TYPE Street_Roads_FAILED
Tcl2 proc Street_Roads_12e8775c_2c06_468f_b7e3_b3a742174ba60_summarizer { } {     global Street_Roads_12e8775c_2c06_468f_b7e3_b3a742174ba60_process_count;     set comment { incr 0 creates the variable if it wasn't present };     incr Street_Roads_12e8775c_2c06_468f_b7e3_b3a742174ba60_process_count 0;     FME_SetAttribute _proc_count [set Street_Roads_12e8775c_2c06_468f_b7e3_b3a742174ba60_process_count];     global Street_Roads_12e8775c_2c06_468f_b7e3_b3a742174ba60_all_processes;     if {[info exists Street_Roads_12e8775c_2c06_468f_b7e3_b3a742174ba60_all_processes]} {         set index 0;         foreach pid [set Street_Roads_12e8775c_2c06_468f_b7e3_b3a742174ba60_all_processes] {             FME_SetAttribute \"_processes{$index}\" $pid;             incr index;         }     } }
FACTORY_DEF * CreationFactory    FACTORY_NAME Street_Roads_SummaryMaker    CREATE_AT_END yes
# -------------------------------------------------------------------------
# Convert the workspace name to one containing only / -- Tcl likes this better
# (and so do I)
# And determine the "NULL" device so we can ensure we don't get stray output
# messing up our stdout if we are running workspaces in the background
# See http://wiki.tcl.tk/1649 for a description of the tcl_platform
# variable, the "platform" part seems to have valid values windows, unix, and
# macintosh (the latter of which is actually pre-OS X)
Tcl2 if { $tcl_platform(platform) == {windows} } {         set ::null_device {NUL:};         set ::__WR_ENV_HELPER__ {};      } else {         set ::null_device {/dev/null};         set ::__WR_ENV_HELPER__ {/usr/bin/env FME_SUBPROCESS_RUN_DETACHED=1}      };
Tcl2 proc Street_Paths_6e303618_98ce_4207_a3d4_182db2bde1ad0_runner { parmListString workspaceFile } {    set workspaceFileUnix [regsub -all {\\} $workspaceFile {/}];    set parmListString [string range $parmListString 1 end-1];    set comment {        Build up the command line in a list, which we'll "eval" to get        at its pieces when we actually execute the "exec".    };    lappend commandArguments {*}$::__WR_ENV_HELPER__ {$(FME_HOME_UNIX)/fme}                             $workspaceFileUnix;    set parmList [split $parmListString {,}];    set comment {        At the same time, remember the TYPES for each of the parameters so        we can avoid logging any passwords in plain text (PR 64546)    };    set parmTypes [split {MULTIFILE,FILENAME} {,}];    set comment {        Note that foreach can walk thorugh more than one list at a time.        If the lists were ever out of sync (had different #s of entries, which should be impossible)        the iteration continues with the shorter list return an empty string. So we should be okay    };    set commandArgumentsToLog $commandArguments;    foreach {parmName encodedValue} $parmList parmType $parmTypes {       set comment {           Decode the parameter value which we now know is very encoded to guard           it from the parser and append them each to a new list which will be passed           as the arguments to the exec function.  Note that the           parameter names need to be turned into macro settings by           prepending them with --           Note also that the WorkspaceRunner sometimes encodes attribute           dereferences by placing <amp> at the beginning rather than using @Value.           Further note that string range forgives if the ending index is > the length of           the string, so we can just ask for the first 5 characters           when we're checking for <amp>.       };       if {[string length $parmName] == 0} { continue; };       lappend commandArguments \"--$parmName\";       lappend commandArgumentsToLog \"--$parmName\";       set comment {           for backwards compatibility, replace first <amp>       };       if { [string range $encodedValue 0 4] == {<amp>} &&            [string length $encodedValue] > 5 } {           set encodedValue [string replace $encodedValue 0 4 {<at>Value<openparen>}]];           append encodedValue "<closeparen>";       };       set comment { We used to call FME_DecodeTextOrAttr here. After changes to                     the code that writes out the mapping file section, we don't                     need to do this any more because the value would be in the                     correct state of encoding as required by the child workspace       };       set comment { parameter values starting with '<' causes tcl exec to fail so                     we escape leading '<' with backslash and then do the reverse                     when parsing command line arguments       };       if { [string index $encodedValue 0] == {<} } {          set encodedValue "\\$encodedValue";       };       lappend commandArguments $encodedValue;       set comment {           Ensure that passwords are not added into the logmessage (PR 64546)           We'll guard against both PASSWORD and PASSWORD_CONFIRM GUI types           by checking if the word PASSWORD is in the GUI TYPE at all       };       if { [string first {PASSWORD} $parmType] != -1 } {           lappend commandArgumentsToLog {***};       } else {           lappend commandArgumentsToLog $encodedValue;       };    };    set comment {        Now optionally run this in a detached way if we were not supposed        to wait by adding & on the end to put it in the background.  And        at the same time, ensure that any stray stdout/stderr is routed to        null.    };    if { {Yes} == {No} } {        lappend commandArguments \">$::null_device\";        lappend commandArgumentsToLog \">$::null_device\";        lappend commandArguments \"<$::null_device\";        lappend commandArgumentsToLog \"<$::null_device\";        FME_LogMessage fme_inform \"Street_Paths: Initiating run of FME Workspace $workspaceFile with command line:\";    } else {        FME_LogMessage fme_inform \"Street_Paths: Running FME Workspace $workspaceFile with command line:\";    };    set comment {        The below 2>@1 forces any standard error output to go into the msg variable        or to NULL if we're running in the background.    };    lappend commandArguments {2>@1};    lappend commandArgumentsToLog {2>@1};    if { {Yes} == {No} } {        lappend commandArguments {&};        lappend commandArgumentsToLog {&};    };    FME_LogMessage fme_inform [concat Street_Paths: $commandArgumentsToLog];    if { {Yes} == {No} } {       after 1000;       while { [FME_CanSpawnFme <Unused>] == {0} } {             after 2000;       };    };    if {[catch {eval [concat exec $commandArguments] } msg ]} {       set msg [regsub {\015*\012child[^\012]*$} $msg {}];       FME_LogMessage fme_warn \"Street_Paths: Failed to run workspace $workspaceFileUnix -- Trace was:\n\n$msg\n\";       FME_SetAttribute _failure_message $msg;       return FAILURE;    } else {       global Street_Paths_6e303618_98ce_4207_a3d4_182db2bde1ad0_process_count;       incr Street_Paths_6e303618_98ce_4207_a3d4_182db2bde1ad0_process_count;       if { {Yes} == {No} } {           FME_LogMessage fme_inform \"Street_Paths: Successfully initiated run of workspace $workspaceFile\";           global Street_Paths_6e303618_98ce_4207_a3d4_182db2bde1ad0_all_processes;           lappend Street_Paths_6e303618_98ce_4207_a3d4_182db2bde1ad0_all_processes $msg;       } else {           FME_LogMessage fme_inform \"Street_Paths: Successfully ran workspace $workspaceFile\";       };       return SUCCESS;    }; }
FACTORY_DEF * TestFactory    FACTORY_NAME Street_Paths_ExecutorAndRouter    INPUT  FEATURE_TYPE Street_Roads_SUCCEEDED    INPUT  FEATURE_TYPE Street_Roads_FAILED    TEST @Tcl2("Street_Paths_6e303618_98ce_4207_a3d4_182db2bde1ad0_runner {(SourceDataset_Street,@EvaluateExpression(FDIV,STRING,$(PATHS_INPUT$encode)<backslash>Highways_Paths_Street_*.gml.gz,Street_Paths),DestDataset_Street,@EvaluateExpression(FDIV,STRING,$(DEST_FOLDER$encode)<backslash>Street_Paths.gpkg,Street_Paths))} {Street.fmw}") == SUCCESS    OUTPUT PASSED FEATURE_TYPE Street_Paths_SUCCEEDED    OUTPUT FAILED FEATURE_TYPE Street_Paths_FAILED
Tcl2 proc Street_Paths_6e303618_98ce_4207_a3d4_182db2bde1ad0_summarizer { } {     global Street_Paths_6e303618_98ce_4207_a3d4_182db2bde1ad0_process_count;     set comment { incr 0 creates the variable if it wasn't present };     incr Street_Paths_6e303618_98ce_4207_a3d4_182db2bde1ad0_process_count 0;     FME_SetAttribute _proc_count [set Street_Paths_6e303618_98ce_4207_a3d4_182db2bde1ad0_process_count];     global Street_Paths_6e303618_98ce_4207_a3d4_182db2bde1ad0_all_processes;     if {[info exists Street_Paths_6e303618_98ce_4207_a3d4_182db2bde1ad0_all_processes]} {         set index 0;         foreach pid [set Street_Paths_6e303618_98ce_4207_a3d4_182db2bde1ad0_all_processes] {             FME_SetAttribute \"_processes{$index}\" $pid;             incr index;         }     } }
FACTORY_DEF * CreationFactory    FACTORY_NAME Street_Paths_SummaryMaker    CREATE_AT_END yes
# -------------------------------------------------------------------------
# Convert the workspace name to one containing only / -- Tcl likes this better
# (and so do I)
# And determine the "NULL" device so we can ensure we don't get stray output
# messing up our stdout if we are running workspaces in the background
# See http://wiki.tcl.tk/1649 for a description of the tcl_platform
# variable, the "platform" part seems to have valid values windows, unix, and
# macintosh (the latter of which is actually pre-OS X)
Tcl2 if { $tcl_platform(platform) == {windows} } {         set ::null_device {NUL:};         set ::__WR_ENV_HELPER__ {};      } else {         set ::null_device {/dev/null};         set ::__WR_ENV_HELPER__ {/usr/bin/env FME_SUBPROCESS_RUN_DETACHED=1}      };
Tcl2 proc Dedication_Roads_479b5549_6d61_464e_bbb4_709486fa95c40_runner { parmListString workspaceFile } {    set workspaceFileUnix [regsub -all {\\} $workspaceFile {/}];    set parmListString [string range $parmListString 1 end-1];    set comment {        Build up the command line in a list, which we'll "eval" to get        at its pieces when we actually execute the "exec".    };    lappend commandArguments {*}$::__WR_ENV_HELPER__ {$(FME_HOME_UNIX)/fme}                             $workspaceFileUnix;    set parmList [split $parmListString {,}];    set comment {        At the same time, remember the TYPES for each of the parameters so        we can avoid logging any passwords in plain text (PR 64546)    };    set parmTypes [split {MULTIFILE,FILENAME} {,}];    set comment {        Note that foreach can walk thorugh more than one list at a time.        If the lists were ever out of sync (had different #s of entries, which should be impossible)        the iteration continues with the shorter list return an empty string. So we should be okay    };    set commandArgumentsToLog $commandArguments;    foreach {parmName encodedValue} $parmList parmType $parmTypes {       set comment {           Decode the parameter value which we now know is very encoded to guard           it from the parser and append them each to a new list which will be passed           as the arguments to the exec function.  Note that the           parameter names need to be turned into macro settings by           prepending them with --           Note also that the WorkspaceRunner sometimes encodes attribute           dereferences by placing <amp> at the beginning rather than using @Value.           Further note that string range forgives if the ending index is > the length of           the string, so we can just ask for the first 5 characters           when we're checking for <amp>.       };       if {[string length $parmName] == 0} { continue; };       lappend commandArguments \"--$parmName\";       lappend commandArgumentsToLog \"--$parmName\";       set comment {           for backwards compatibility, replace first <amp>       };       if { [string range $encodedValue 0 4] == {<amp>} &&            [string length $encodedValue] > 5 } {           set encodedValue [string replace $encodedValue 0 4 {<at>Value<openparen>}]];           append encodedValue "<closeparen>";       };       set comment { We used to call FME_DecodeTextOrAttr here. After changes to                     the code that writes out the mapping file section, we don't                     need to do this any more because the value would be in the                     correct state of encoding as required by the child workspace       };       set comment { parameter values starting with '<' causes tcl exec to fail so                     we escape leading '<' with backslash and then do the reverse                     when parsing command line arguments       };       if { [string index $encodedValue 0] == {<} } {          set encodedValue "\\$encodedValue";       };       lappend commandArguments $encodedValue;       set comment {           Ensure that passwords are not added into the logmessage (PR 64546)           We'll guard against both PASSWORD and PASSWORD_CONFIRM GUI types           by checking if the word PASSWORD is in the GUI TYPE at all       };       if { [string first {PASSWORD} $parmType] != -1 } {           lappend commandArgumentsToLog {***};       } else {           lappend commandArgumentsToLog $encodedValue;       };    };    set comment {        Now optionally run this in a detached way if we were not supposed        to wait by adding & on the end to put it in the background.  And        at the same time, ensure that any stray stdout/stderr is routed to        null.    };    if { {Yes} == {No} } {        lappend commandArguments \">$::null_device\";        lappend commandArgumentsToLog \">$::null_device\";        lappend commandArguments \"<$::null_device\";        lappend commandArgumentsToLog \"<$::null_device\";        FME_LogMessage fme_inform \"Dedication_Roads: Initiating run of FME Workspace $workspaceFile with command line:\";    } else {        FME_LogMessage fme_inform \"Dedication_Roads: Running FME Workspace $workspaceFile with command line:\";    };    set comment {        The below 2>@1 forces any standard error output to go into the msg variable        or to NULL if we're running in the background.    };    lappend commandArguments {2>@1};    lappend commandArgumentsToLog {2>@1};    if { {Yes} == {No} } {        lappend commandArguments {&};        lappend commandArgumentsToLog {&};    };    FME_LogMessage fme_inform [concat Dedication_Roads: $commandArgumentsToLog];    if { {Yes} == {No} } {       after 1000;       while { [FME_CanSpawnFme <Unused>] == {0} } {             after 2000;       };    };    if {[catch {eval [concat exec $commandArguments] } msg ]} {       set msg [regsub {\015*\012child[^\012]*$} $msg {}];       FME_LogMessage fme_warn \"Dedication_Roads: Failed to run workspace $workspaceFileUnix -- Trace was:\n\n$msg\n\";       FME_SetAttribute _failure_message $msg;       return FAILURE;    } else {       global Dedication_Roads_479b5549_6d61_464e_bbb4_709486fa95c40_process_count;       incr Dedication_Roads_479b5549_6d61_464e_bbb4_709486fa95c40_process_count;       if { {Yes} == {No} } {           FME_LogMessage fme_inform \"Dedication_Roads: Successfully initiated run of workspace $workspaceFile\";           global Dedication_Roads_479b5549_6d61_464e_bbb4_709486fa95c40_all_processes;           lappend Dedication_Roads_479b5549_6d61_464e_bbb4_709486fa95c40_all_processes $msg;       } else {           FME_LogMessage fme_inform \"Dedication_Roads: Successfully ran workspace $workspaceFile\";       };       return SUCCESS;    }; }
FACTORY_DEF * TestFactory    FACTORY_NAME Dedication_Roads_ExecutorAndRouter    INPUT  FEATURE_TYPE Street_Paths_SUCCEEDED    INPUT  FEATURE_TYPE Street_Paths_FAILED    TEST @Tcl2("Dedication_Roads_479b5549_6d61_464e_bbb4_709486fa95c40_runner {(SourceDataset_GML,@EvaluateExpression(FDIV,STRING,$(ROADS_INPUT$encode)<backslash>Highways_Rrami_Dedication_*.gml.gz,Dedication_Roads),DestDataset_GEOPACKAGE,@EvaluateExpression(FDIV,STRING,$(DEST_FOLDER$encode)<backslash>Dedication_Roads.gpkg,Dedication_Roads))} {HighwayDedication.fmw}") == SUCCESS    OUTPUT PASSED FEATURE_TYPE Dedication_Roads_SUCCEEDED    OUTPUT FAILED FEATURE_TYPE Dedication_Roads_FAILED
Tcl2 proc Dedication_Roads_479b5549_6d61_464e_bbb4_709486fa95c40_summarizer { } {     global Dedication_Roads_479b5549_6d61_464e_bbb4_709486fa95c40_process_count;     set comment { incr 0 creates the variable if it wasn't present };     incr Dedication_Roads_479b5549_6d61_464e_bbb4_709486fa95c40_process_count 0;     FME_SetAttribute _proc_count [set Dedication_Roads_479b5549_6d61_464e_bbb4_709486fa95c40_process_count];     global Dedication_Roads_479b5549_6d61_464e_bbb4_709486fa95c40_all_processes;     if {[info exists Dedication_Roads_479b5549_6d61_464e_bbb4_709486fa95c40_all_processes]} {         set index 0;         foreach pid [set Dedication_Roads_479b5549_6d61_464e_bbb4_709486fa95c40_all_processes] {             FME_SetAttribute \"_processes{$index}\" $pid;             incr index;         }     } }
FACTORY_DEF * CreationFactory    FACTORY_NAME Dedication_Roads_SummaryMaker    CREATE_AT_END yes
# -------------------------------------------------------------------------
# Convert the workspace name to one containing only / -- Tcl likes this better
# (and so do I)
# And determine the "NULL" device so we can ensure we don't get stray output
# messing up our stdout if we are running workspaces in the background
# See http://wiki.tcl.tk/1649 for a description of the tcl_platform
# variable, the "platform" part seems to have valid values windows, unix, and
# macintosh (the latter of which is actually pre-OS X)
Tcl2 if { $tcl_platform(platform) == {windows} } {         set ::null_device {NUL:};         set ::__WR_ENV_HELPER__ {};      } else {         set ::null_device {/dev/null};         set ::__WR_ENV_HELPER__ {/usr/bin/env FME_SUBPROCESS_RUN_DETACHED=1}      };
Tcl2 proc Dedication_Paths_aef2ade4_a93f_423c_8ed5_f5c8455e1a6e0_runner { parmListString workspaceFile } {    set workspaceFileUnix [regsub -all {\\} $workspaceFile {/}];    set parmListString [string range $parmListString 1 end-1];    set comment {        Build up the command line in a list, which we'll "eval" to get        at its pieces when we actually execute the "exec".    };    lappend commandArguments {*}$::__WR_ENV_HELPER__ {$(FME_HOME_UNIX)/fme}                             $workspaceFileUnix;    set parmList [split $parmListString {,}];    set comment {        At the same time, remember the TYPES for each of the parameters so        we can avoid logging any passwords in plain text (PR 64546)    };    set parmTypes [split {MULTIFILE,FILENAME} {,}];    set comment {        Note that foreach can walk thorugh more than one list at a time.        If the lists were ever out of sync (had different #s of entries, which should be impossible)        the iteration continues with the shorter list return an empty string. So we should be okay    };    set commandArgumentsToLog $commandArguments;    foreach {parmName encodedValue} $parmList parmType $parmTypes {       set comment {           Decode the parameter value which we now know is very encoded to guard           it from the parser and append them each to a new list which will be passed           as the arguments to the exec function.  Note that the           parameter names need to be turned into macro settings by           prepending them with --           Note also that the WorkspaceRunner sometimes encodes attribute           dereferences by placing <amp> at the beginning rather than using @Value.           Further note that string range forgives if the ending index is > the length of           the string, so we can just ask for the first 5 characters           when we're checking for <amp>.       };       if {[string length $parmName] == 0} { continue; };       lappend commandArguments \"--$parmName\";       lappend commandArgumentsToLog \"--$parmName\";       set comment {           for backwards compatibility, replace first <amp>       };       if { [string range $encodedValue 0 4] == {<amp>} &&            [string length $encodedValue] > 5 } {           set encodedValue [string replace $encodedValue 0 4 {<at>Value<openparen>}]];           append encodedValue "<closeparen>";       };       set comment { We used to call FME_DecodeTextOrAttr here. After changes to                     the code that writes out the mapping file section, we don't                     need to do this any more because the value would be in the                     correct state of encoding as required by the child workspace       };       set comment { parameter values starting with '<' causes tcl exec to fail so                     we escape leading '<' with backslash and then do the reverse                     when parsing command line arguments       };       if { [string index $encodedValue 0] == {<} } {          set encodedValue "\\$encodedValue";       };       lappend commandArguments $encodedValue;       set comment {           Ensure that passwords are not added into the logmessage (PR 64546)           We'll guard against both PASSWORD and PASSWORD_CONFIRM GUI types           by checking if the word PASSWORD is in the GUI TYPE at all       };       if { [string first {PASSWORD} $parmType] != -1 } {           lappend commandArgumentsToLog {***};       } else {           lappend commandArgumentsToLog $encodedValue;       };    };    set comment {        Now optionally run this in a detached way if we were not supposed        to wait by adding & on the end to put it in the background.  And        at the same time, ensure that any stray stdout/stderr is routed to        null.    };    if { {Yes} == {No} } {        lappend commandArguments \">$::null_device\";        lappend commandArgumentsToLog \">$::null_device\";        lappend commandArguments \"<$::null_device\";        lappend commandArgumentsToLog \"<$::null_device\";        FME_LogMessage fme_inform \"Dedication_Paths: Initiating run of FME Workspace $workspaceFile with command line:\";    } else {        FME_LogMessage fme_inform \"Dedication_Paths: Running FME Workspace $workspaceFile with command line:\";    };    set comment {        The below 2>@1 forces any standard error output to go into the msg variable        or to NULL if we're running in the background.    };    lappend commandArguments {2>@1};    lappend commandArgumentsToLog {2>@1};    if { {Yes} == {No} } {        lappend commandArguments {&};        lappend commandArgumentsToLog {&};    };    FME_LogMessage fme_inform [concat Dedication_Paths: $commandArgumentsToLog];    if { {Yes} == {No} } {       after 1000;       while { [FME_CanSpawnFme <Unused>] == {0} } {             after 2000;       };    };    if {[catch {eval [concat exec $commandArguments] } msg ]} {       set msg [regsub {\015*\012child[^\012]*$} $msg {}];       FME_LogMessage fme_warn \"Dedication_Paths: Failed to run workspace $workspaceFileUnix -- Trace was:\n\n$msg\n\";       FME_SetAttribute _failure_message $msg;       return FAILURE;    } else {       global Dedication_Paths_aef2ade4_a93f_423c_8ed5_f5c8455e1a6e0_process_count;       incr Dedication_Paths_aef2ade4_a93f_423c_8ed5_f5c8455e1a6e0_process_count;       if { {Yes} == {No} } {           FME_LogMessage fme_inform \"Dedication_Paths: Successfully initiated run of workspace $workspaceFile\";           global Dedication_Paths_aef2ade4_a93f_423c_8ed5_f5c8455e1a6e0_all_processes;           lappend Dedication_Paths_aef2ade4_a93f_423c_8ed5_f5c8455e1a6e0_all_processes $msg;       } else {           FME_LogMessage fme_inform \"Dedication_Paths: Successfully ran workspace $workspaceFile\";       };       return SUCCESS;    }; }
FACTORY_DEF * TestFactory    FACTORY_NAME Dedication_Paths_ExecutorAndRouter    INPUT  FEATURE_TYPE Dedication_Roads_SUCCEEDED    INPUT  FEATURE_TYPE Dedication_Roads_FAILED    TEST @Tcl2("Dedication_Paths_aef2ade4_a93f_423c_8ed5_f5c8455e1a6e0_runner {(SourceDataset_GML,@EvaluateExpression(FDIV,STRING,$(PATHS_INPUT$encode)<backslash>Highways_Paths_Dedication_*.gml.gz,Dedication_Paths),DestDataset_GEOPACKAGE,@EvaluateExpression(FDIV,STRING,$(DEST_FOLDER$encode)<backslash>Dedication_Paths.gpkg,Dedication_Paths))} {HighwayDedication.fmw}") == SUCCESS    OUTPUT PASSED FEATURE_TYPE Dedication_Paths_SUCCEEDED    OUTPUT FAILED FEATURE_TYPE Dedication_Paths_FAILED
Tcl2 proc Dedication_Paths_aef2ade4_a93f_423c_8ed5_f5c8455e1a6e0_summarizer { } {     global Dedication_Paths_aef2ade4_a93f_423c_8ed5_f5c8455e1a6e0_process_count;     set comment { incr 0 creates the variable if it wasn't present };     incr Dedication_Paths_aef2ade4_a93f_423c_8ed5_f5c8455e1a6e0_process_count 0;     FME_SetAttribute _proc_count [set Dedication_Paths_aef2ade4_a93f_423c_8ed5_f5c8455e1a6e0_process_count];     global Dedication_Paths_aef2ade4_a93f_423c_8ed5_f5c8455e1a6e0_all_processes;     if {[info exists Dedication_Paths_aef2ade4_a93f_423c_8ed5_f5c8455e1a6e0_all_processes]} {         set index 0;         foreach pid [set Dedication_Paths_aef2ade4_a93f_423c_8ed5_f5c8455e1a6e0_all_processes] {             FME_SetAttribute \"_processes{$index}\" $pid;             incr index;         }     } }
FACTORY_DEF * CreationFactory    FACTORY_NAME Dedication_Paths_SummaryMaker    CREATE_AT_END yes
# -------------------------------------------------------------------------
# Convert the workspace name to one containing only / -- Tcl likes this better
# (and so do I)
# And determine the "NULL" device so we can ensure we don't get stray output
# messing up our stdout if we are running workspaces in the background
# See http://wiki.tcl.tk/1649 for a description of the tcl_platform
# variable, the "platform" part seems to have valid values windows, unix, and
# macintosh (the latter of which is actually pre-OS X)
Tcl2 if { $tcl_platform(platform) == {windows} } {         set ::null_device {NUL:};         set ::__WR_ENV_HELPER__ {};      } else {         set ::null_device {/dev/null};         set ::__WR_ENV_HELPER__ {/usr/bin/env FME_SUBPROCESS_RUN_DETACHED=1}      };
Tcl2 proc HazardAndStructure_6de20af4_7e0b_48fc_845c_2dc7118c05450_runner { parmListString workspaceFile } {    set workspaceFileUnix [regsub -all {\\} $workspaceFile {/}];    set parmListString [string range $parmListString 1 end-1];    set comment {        Build up the command line in a list, which we'll "eval" to get        at its pieces when we actually execute the "exec".    };    lappend commandArguments {*}$::__WR_ENV_HELPER__ {$(FME_HOME_UNIX)/fme}                             $workspaceFileUnix;    set parmList [split $parmListString {,}];    set comment {        At the same time, remember the TYPES for each of the parameters so        we can avoid logging any passwords in plain text (PR 64546)    };    set parmTypes [split {MULTIFILE,MULTIFILE,MULTIFILE,FILENAME} {,}];    set comment {        Note that foreach can walk thorugh more than one list at a time.        If the lists were ever out of sync (had different #s of entries, which should be impossible)        the iteration continues with the shorter list return an empty string. So we should be okay    };    set commandArgumentsToLog $commandArguments;    foreach {parmName encodedValue} $parmList parmType $parmTypes {       set comment {           Decode the parameter value which we now know is very encoded to guard           it from the parser and append them each to a new list which will be passed           as the arguments to the exec function.  Note that the           parameter names need to be turned into macro settings by           prepending them with --           Note also that the WorkspaceRunner sometimes encodes attribute           dereferences by placing <amp> at the beginning rather than using @Value.           Further note that string range forgives if the ending index is > the length of           the string, so we can just ask for the first 5 characters           when we're checking for <amp>.       };       if {[string length $parmName] == 0} { continue; };       lappend commandArguments \"--$parmName\";       lappend commandArgumentsToLog \"--$parmName\";       set comment {           for backwards compatibility, replace first <amp>       };       if { [string range $encodedValue 0 4] == {<amp>} &&            [string length $encodedValue] > 5 } {           set encodedValue [string replace $encodedValue 0 4 {<at>Value<openparen>}]];           append encodedValue "<closeparen>";       };       set comment { We used to call FME_DecodeTextOrAttr here. After changes to                     the code that writes out the mapping file section, we don't                     need to do this any more because the value would be in the                     correct state of encoding as required by the child workspace       };       set comment { parameter values starting with '<' causes tcl exec to fail so                     we escape leading '<' with backslash and then do the reverse                     when parsing command line arguments       };       if { [string index $encodedValue 0] == {<} } {          set encodedValue "\\$encodedValue";       };       lappend commandArguments $encodedValue;       set comment {           Ensure that passwords are not added into the logmessage (PR 64546)           We'll guard against both PASSWORD and PASSWORD_CONFIRM GUI types           by checking if the word PASSWORD is in the GUI TYPE at all       };       if { [string first {PASSWORD} $parmType] != -1 } {           lappend commandArgumentsToLog {***};       } else {           lappend commandArgumentsToLog $encodedValue;       };    };    set comment {        Now optionally run this in a detached way if we were not supposed        to wait by adding & on the end to put it in the background.  And        at the same time, ensure that any stray stdout/stderr is routed to        null.    };    if { {Yes} == {No} } {        lappend commandArguments \">$::null_device\";        lappend commandArgumentsToLog \">$::null_device\";        lappend commandArguments \"<$::null_device\";        lappend commandArgumentsToLog \"<$::null_device\";        FME_LogMessage fme_inform \"HazardAndStructure: Initiating run of FME Workspace $workspaceFile with command line:\";    } else {        FME_LogMessage fme_inform \"HazardAndStructure: Running FME Workspace $workspaceFile with command line:\";    };    set comment {        The below 2>@1 forces any standard error output to go into the msg variable        or to NULL if we're running in the background.    };    lappend commandArguments {2>@1};    lappend commandArgumentsToLog {2>@1};    if { {Yes} == {No} } {        lappend commandArguments {&};        lappend commandArgumentsToLog {&};    };    FME_LogMessage fme_inform [concat HazardAndStructure: $commandArgumentsToLog];    if { {Yes} == {No} } {       after 1000;       while { [FME_CanSpawnFme <Unused>] == {0} } {             after 2000;       };    };    if {[catch {eval [concat exec $commandArguments] } msg ]} {       set msg [regsub {\015*\012child[^\012]*$} $msg {}];       FME_LogMessage fme_warn \"HazardAndStructure: Failed to run workspace $workspaceFileUnix -- Trace was:\n\n$msg\n\";       FME_SetAttribute _failure_message $msg;       return FAILURE;    } else {       global HazardAndStructure_6de20af4_7e0b_48fc_845c_2dc7118c05450_process_count;       incr HazardAndStructure_6de20af4_7e0b_48fc_845c_2dc7118c05450_process_count;       if { {Yes} == {No} } {           FME_LogMessage fme_inform \"HazardAndStructure: Successfully initiated run of workspace $workspaceFile\";           global HazardAndStructure_6de20af4_7e0b_48fc_845c_2dc7118c05450_all_processes;           lappend HazardAndStructure_6de20af4_7e0b_48fc_845c_2dc7118c05450_all_processes $msg;       } else {           FME_LogMessage fme_inform \"HazardAndStructure: Successfully ran workspace $workspaceFile\";       };       return SUCCESS;    }; }
FACTORY_DEF * TestFactory    FACTORY_NAME HazardAndStructure_ExecutorAndRouter    INPUT  FEATURE_TYPE Dedication_Paths_SUCCEEDED    INPUT  FEATURE_TYPE Dedication_Paths_FAILED    TEST @Tcl2("HazardAndStructure_6de20af4_7e0b_48fc_845c_2dc7118c05450_runner {(SourceDataset_Hazard,@EvaluateExpression(FDIV,STRING,$(ROADS_INPUT$encode)<backslash>Highways_Rrami_Hazard_*.gml.gz,HazardAndStructure),SourceDataset_Structure,@EvaluateExpression(FDIV,STRING,$(ROADS_INPUT$encode)<backslash>Highways_Rrami_Structure_*.gml.gz,HazardAndStructure),SourceDataset_RoadLink,@EvaluateExpression(FDIV,STRING,$(ROADS_INPUT$encode)<backslash>Highways_Rrami_RoadLink_*.gml.gz,HazardAndStructure),DestDataset_HazardAndStructure,@EvaluateExpression(FDIV,STRING,$(DEST_FOLDER$encode)<backslash>HazardAndStructure.gpkg,HazardAndStructure))} {HazardsAndStructures.fmw}") == SUCCESS    OUTPUT PASSED FEATURE_TYPE HazardAndStructure_SUCCEEDED    OUTPUT FAILED FEATURE_TYPE HazardAndStructure_FAILED
Tcl2 proc HazardAndStructure_6de20af4_7e0b_48fc_845c_2dc7118c05450_summarizer { } {     global HazardAndStructure_6de20af4_7e0b_48fc_845c_2dc7118c05450_process_count;     set comment { incr 0 creates the variable if it wasn't present };     incr HazardAndStructure_6de20af4_7e0b_48fc_845c_2dc7118c05450_process_count 0;     FME_SetAttribute _proc_count [set HazardAndStructure_6de20af4_7e0b_48fc_845c_2dc7118c05450_process_count];     global HazardAndStructure_6de20af4_7e0b_48fc_845c_2dc7118c05450_all_processes;     if {[info exists HazardAndStructure_6de20af4_7e0b_48fc_845c_2dc7118c05450_all_processes]} {         set index 0;         foreach pid [set HazardAndStructure_6de20af4_7e0b_48fc_845c_2dc7118c05450_all_processes] {             FME_SetAttribute \"_processes{$index}\" $pid;             incr index;         }     } }
FACTORY_DEF * CreationFactory    FACTORY_NAME HazardAndStructure_SummaryMaker    CREATE_AT_END yes
# -------------------------------------------------------------------------
# Convert the workspace name to one containing only / -- Tcl likes this better
# (and so do I)
# And determine the "NULL" device so we can ensure we don't get stray output
# messing up our stdout if we are running workspaces in the background
# See http://wiki.tcl.tk/1649 for a description of the tcl_platform
# variable, the "platform" part seems to have valid values windows, unix, and
# macintosh (the latter of which is actually pre-OS X)
Tcl2 if { $tcl_platform(platform) == {windows} } {         set ::null_device {NUL:};         set ::__WR_ENV_HELPER__ {};      } else {         set ::null_device {/dev/null};         set ::__WR_ENV_HELPER__ {/usr/bin/env FME_SUBPROCESS_RUN_DETACHED=1}      };
Tcl2 proc Road_7c5a1958_db22_4b69_9594_d71a9a635f1f0_runner { parmListString workspaceFile } {    set workspaceFileUnix [regsub -all {\\} $workspaceFile {/}];    set parmListString [string range $parmListString 1 end-1];    set comment {        Build up the command line in a list, which we'll "eval" to get        at its pieces when we actually execute the "exec".    };    lappend commandArguments {*}$::__WR_ENV_HELPER__ {$(FME_HOME_UNIX)/fme}                             $workspaceFileUnix;    set parmList [split $parmListString {,}];    set comment {        At the same time, remember the TYPES for each of the parameters so        we can avoid logging any passwords in plain text (PR 64546)    };    set parmTypes [split {MULTIFILE,FILENAME} {,}];    set comment {        Note that foreach can walk thorugh more than one list at a time.        If the lists were ever out of sync (had different #s of entries, which should be impossible)        the iteration continues with the shorter list return an empty string. So we should be okay    };    set commandArgumentsToLog $commandArguments;    foreach {parmName encodedValue} $parmList parmType $parmTypes {       set comment {           Decode the parameter value which we now know is very encoded to guard           it from the parser and append them each to a new list which will be passed           as the arguments to the exec function.  Note that the           parameter names need to be turned into macro settings by           prepending them with --           Note also that the WorkspaceRunner sometimes encodes attribute           dereferences by placing <amp> at the beginning rather than using @Value.           Further note that string range forgives if the ending index is > the length of           the string, so we can just ask for the first 5 characters           when we're checking for <amp>.       };       if {[string length $parmName] == 0} { continue; };       lappend commandArguments \"--$parmName\";       lappend commandArgumentsToLog \"--$parmName\";       set comment {           for backwards compatibility, replace first <amp>       };       if { [string range $encodedValue 0 4] == {<amp>} &&            [string length $encodedValue] > 5 } {           set encodedValue [string replace $encodedValue 0 4 {<at>Value<openparen>}]];           append encodedValue "<closeparen>";       };       set comment { We used to call FME_DecodeTextOrAttr here. After changes to                     the code that writes out the mapping file section, we don't                     need to do this any more because the value would be in the                     correct state of encoding as required by the child workspace       };       set comment { parameter values starting with '<' causes tcl exec to fail so                     we escape leading '<' with backslash and then do the reverse                     when parsing command line arguments       };       if { [string index $encodedValue 0] == {<} } {          set encodedValue "\\$encodedValue";       };       lappend commandArguments $encodedValue;       set comment {           Ensure that passwords are not added into the logmessage (PR 64546)           We'll guard against both PASSWORD and PASSWORD_CONFIRM GUI types           by checking if the word PASSWORD is in the GUI TYPE at all       };       if { [string first {PASSWORD} $parmType] != -1 } {           lappend commandArgumentsToLog {***};       } else {           lappend commandArgumentsToLog $encodedValue;       };    };    set comment {        Now optionally run this in a detached way if we were not supposed        to wait by adding & on the end to put it in the background.  And        at the same time, ensure that any stray stdout/stderr is routed to        null.    };    if { {Yes} == {No} } {        lappend commandArguments \">$::null_device\";        lappend commandArgumentsToLog \">$::null_device\";        lappend commandArguments \"<$::null_device\";        lappend commandArgumentsToLog \"<$::null_device\";        FME_LogMessage fme_inform \"Road: Initiating run of FME Workspace $workspaceFile with command line:\";    } else {        FME_LogMessage fme_inform \"Road: Running FME Workspace $workspaceFile with command line:\";    };    set comment {        The below 2>@1 forces any standard error output to go into the msg variable        or to NULL if we're running in the background.    };    lappend commandArguments {2>@1};    lappend commandArgumentsToLog {2>@1};    if { {Yes} == {No} } {        lappend commandArguments {&};        lappend commandArgumentsToLog {&};    };    FME_LogMessage fme_inform [concat Road: $commandArgumentsToLog];    if { {Yes} == {No} } {       after 1000;       while { [FME_CanSpawnFme <Unused>] == {0} } {             after 2000;       };    };    if {[catch {eval [concat exec $commandArguments] } msg ]} {       set msg [regsub {\015*\012child[^\012]*$} $msg {}];       FME_LogMessage fme_warn \"Road: Failed to run workspace $workspaceFileUnix -- Trace was:\n\n$msg\n\";       FME_SetAttribute _failure_message $msg;       return FAILURE;    } else {       global Road_7c5a1958_db22_4b69_9594_d71a9a635f1f0_process_count;       incr Road_7c5a1958_db22_4b69_9594_d71a9a635f1f0_process_count;       if { {Yes} == {No} } {           FME_LogMessage fme_inform \"Road: Successfully initiated run of workspace $workspaceFile\";           global Road_7c5a1958_db22_4b69_9594_d71a9a635f1f0_all_processes;           lappend Road_7c5a1958_db22_4b69_9594_d71a9a635f1f0_all_processes $msg;       } else {           FME_LogMessage fme_inform \"Road: Successfully ran workspace $workspaceFile\";       };       return SUCCESS;    }; }
FACTORY_DEF * TestFactory    FACTORY_NAME Road_ExecutorAndRouter    INPUT  FEATURE_TYPE HazardAndStructure_SUCCEEDED    INPUT  FEATURE_TYPE HazardAndStructure_FAILED    TEST @Tcl2("Road_7c5a1958_db22_4b69_9594_d71a9a635f1f0_runner {(SourceDataset_Road,@EvaluateExpression(FDIV,STRING,$(ROADS_INPUT$encode)<backslash>Highways_Rrami_Road_*.gml.gz,Road),DestDataset_GEOPACKAGE,@EvaluateExpression(FDIV,STRING,$(DEST_FOLDER$encode)<backslash>Road.gpkg,Road))} {Road.fmw}") == SUCCESS    OUTPUT PASSED FEATURE_TYPE Road_SUCCEEDED    OUTPUT FAILED FEATURE_TYPE Road_FAILED
Tcl2 proc Road_7c5a1958_db22_4b69_9594_d71a9a635f1f0_summarizer { } {     global Road_7c5a1958_db22_4b69_9594_d71a9a635f1f0_process_count;     set comment { incr 0 creates the variable if it wasn't present };     incr Road_7c5a1958_db22_4b69_9594_d71a9a635f1f0_process_count 0;     FME_SetAttribute _proc_count [set Road_7c5a1958_db22_4b69_9594_d71a9a635f1f0_process_count];     global Road_7c5a1958_db22_4b69_9594_d71a9a635f1f0_all_processes;     if {[info exists Road_7c5a1958_db22_4b69_9594_d71a9a635f1f0_all_processes]} {         set index 0;         foreach pid [set Road_7c5a1958_db22_4b69_9594_d71a9a635f1f0_all_processes] {             FME_SetAttribute \"_processes{$index}\" $pid;             incr index;         }     } }
FACTORY_DEF * CreationFactory    FACTORY_NAME Road_SummaryMaker    CREATE_AT_END yes
# -------------------------------------------------------------------------
# Convert the workspace name to one containing only / -- Tcl likes this better
# (and so do I)
# And determine the "NULL" device so we can ensure we don't get stray output
# messing up our stdout if we are running workspaces in the background
# See http://wiki.tcl.tk/1649 for a description of the tcl_platform
# variable, the "platform" part seems to have valid values windows, unix, and
# macintosh (the latter of which is actually pre-OS X)
Tcl2 if { $tcl_platform(platform) == {windows} } {         set ::null_device {NUL:};         set ::__WR_ENV_HELPER__ {};      } else {         set ::null_device {/dev/null};         set ::__WR_ENV_HELPER__ {/usr/bin/env FME_SUBPROCESS_RUN_DETACHED=1}      };
Tcl2 proc Path_1dca4e5e_9c56_433f_93d2_ae6d7a3a2d510_runner { parmListString workspaceFile } {    set workspaceFileUnix [regsub -all {\\} $workspaceFile {/}];    set parmListString [string range $parmListString 1 end-1];    set comment {        Build up the command line in a list, which we'll "eval" to get        at its pieces when we actually execute the "exec".    };    lappend commandArguments {*}$::__WR_ENV_HELPER__ {$(FME_HOME_UNIX)/fme}                             $workspaceFileUnix;    set parmList [split $parmListString {,}];    set comment {        At the same time, remember the TYPES for each of the parameters so        we can avoid logging any passwords in plain text (PR 64546)    };    set parmTypes [split {MULTIFILE,FILENAME} {,}];    set comment {        Note that foreach can walk thorugh more than one list at a time.        If the lists were ever out of sync (had different #s of entries, which should be impossible)        the iteration continues with the shorter list return an empty string. So we should be okay    };    set commandArgumentsToLog $commandArguments;    foreach {parmName encodedValue} $parmList parmType $parmTypes {       set comment {           Decode the parameter value which we now know is very encoded to guard           it from the parser and append them each to a new list which will be passed           as the arguments to the exec function.  Note that the           parameter names need to be turned into macro settings by           prepending them with --           Note also that the WorkspaceRunner sometimes encodes attribute           dereferences by placing <amp> at the beginning rather than using @Value.           Further note that string range forgives if the ending index is > the length of           the string, so we can just ask for the first 5 characters           when we're checking for <amp>.       };       if {[string length $parmName] == 0} { continue; };       lappend commandArguments \"--$parmName\";       lappend commandArgumentsToLog \"--$parmName\";       set comment {           for backwards compatibility, replace first <amp>       };       if { [string range $encodedValue 0 4] == {<amp>} &&            [string length $encodedValue] > 5 } {           set encodedValue [string replace $encodedValue 0 4 {<at>Value<openparen>}]];           append encodedValue "<closeparen>";       };       set comment { We used to call FME_DecodeTextOrAttr here. After changes to                     the code that writes out the mapping file section, we don't                     need to do this any more because the value would be in the                     correct state of encoding as required by the child workspace       };       set comment { parameter values starting with '<' causes tcl exec to fail so                     we escape leading '<' with backslash and then do the reverse                     when parsing command line arguments       };       if { [string index $encodedValue 0] == {<} } {          set encodedValue "\\$encodedValue";       };       lappend commandArguments $encodedValue;       set comment {           Ensure that passwords are not added into the logmessage (PR 64546)           We'll guard against both PASSWORD and PASSWORD_CONFIRM GUI types           by checking if the word PASSWORD is in the GUI TYPE at all       };       if { [string first {PASSWORD} $parmType] != -1 } {           lappend commandArgumentsToLog {***};       } else {           lappend commandArgumentsToLog $encodedValue;       };    };    set comment {        Now optionally run this in a detached way if we were not supposed        to wait by adding & on the end to put it in the background.  And        at the same time, ensure that any stray stdout/stderr is routed to        null.    };    if { {Yes} == {No} } {        lappend commandArguments \">$::null_device\";        lappend commandArgumentsToLog \">$::null_device\";        lappend commandArguments \"<$::null_device\";        lappend commandArgumentsToLog \"<$::null_device\";        FME_LogMessage fme_inform \"Path: Initiating run of FME Workspace $workspaceFile with command line:\";    } else {        FME_LogMessage fme_inform \"Path: Running FME Workspace $workspaceFile with command line:\";    };    set comment {        The below 2>@1 forces any standard error output to go into the msg variable        or to NULL if we're running in the background.    };    lappend commandArguments {2>@1};    lappend commandArgumentsToLog {2>@1};    if { {Yes} == {No} } {        lappend commandArguments {&};        lappend commandArgumentsToLog {&};    };    FME_LogMessage fme_inform [concat Path: $commandArgumentsToLog];    if { {Yes} == {No} } {       after 1000;       while { [FME_CanSpawnFme <Unused>] == {0} } {             after 2000;       };    };    if {[catch {eval [concat exec $commandArguments] } msg ]} {       set msg [regsub {\015*\012child[^\012]*$} $msg {}];       FME_LogMessage fme_warn \"Path: Failed to run workspace $workspaceFileUnix -- Trace was:\n\n$msg\n\";       FME_SetAttribute _failure_message $msg;       return FAILURE;    } else {       global Path_1dca4e5e_9c56_433f_93d2_ae6d7a3a2d510_process_count;       incr Path_1dca4e5e_9c56_433f_93d2_ae6d7a3a2d510_process_count;       if { {Yes} == {No} } {           FME_LogMessage fme_inform \"Path: Successfully initiated run of workspace $workspaceFile\";           global Path_1dca4e5e_9c56_433f_93d2_ae6d7a3a2d510_all_processes;           lappend Path_1dca4e5e_9c56_433f_93d2_ae6d7a3a2d510_all_processes $msg;       } else {           FME_LogMessage fme_inform \"Path: Successfully ran workspace $workspaceFile\";       };       return SUCCESS;    }; }
FACTORY_DEF * TestFactory    FACTORY_NAME Path_ExecutorAndRouter    INPUT  FEATURE_TYPE Road_SUCCEEDED    INPUT  FEATURE_TYPE Road_FAILED    TEST @Tcl2("Path_1dca4e5e_9c56_433f_93d2_ae6d7a3a2d510_runner {(SourceDataset_GML,@EvaluateExpression(FDIV,STRING,$(PATHS_INPUT$encode)<backslash>Highways_Paths_Path_*.gml.gz,Path),DestDataset_GEOPACKAGE,@EvaluateExpression(FDIV,STRING,$(DEST_FOLDER$encode)<backslash>Path.gpkg,Path))} {Path.fmw}") == SUCCESS    OUTPUT PASSED FEATURE_TYPE Path_SUCCEEDED    OUTPUT FAILED FEATURE_TYPE Path_FAILED
Tcl2 proc Path_1dca4e5e_9c56_433f_93d2_ae6d7a3a2d510_summarizer { } {     global Path_1dca4e5e_9c56_433f_93d2_ae6d7a3a2d510_process_count;     set comment { incr 0 creates the variable if it wasn't present };     incr Path_1dca4e5e_9c56_433f_93d2_ae6d7a3a2d510_process_count 0;     FME_SetAttribute _proc_count [set Path_1dca4e5e_9c56_433f_93d2_ae6d7a3a2d510_process_count];     global Path_1dca4e5e_9c56_433f_93d2_ae6d7a3a2d510_all_processes;     if {[info exists Path_1dca4e5e_9c56_433f_93d2_ae6d7a3a2d510_all_processes]} {         set index 0;         foreach pid [set Path_1dca4e5e_9c56_433f_93d2_ae6d7a3a2d510_all_processes] {             FME_SetAttribute \"_processes{$index}\" $pid;             incr index;         }     } }
FACTORY_DEF * CreationFactory    FACTORY_NAME Path_SummaryMaker    CREATE_AT_END yes
# -------------------------------------------------------------------------
# Convert the workspace name to one containing only / -- Tcl likes this better
# (and so do I)
# And determine the "NULL" device so we can ensure we don't get stray output
# messing up our stdout if we are running workspaces in the background
# See http://wiki.tcl.tk/1649 for a description of the tcl_platform
# variable, the "platform" part seems to have valid values windows, unix, and
# macintosh (the latter of which is actually pre-OS X)
Tcl2 if { $tcl_platform(platform) == {windows} } {         set ::null_device {NUL:};         set ::__WR_ENV_HELPER__ {};      } else {         set ::null_device {/dev/null};         set ::__WR_ENV_HELPER__ {/usr/bin/env FME_SUBPROCESS_RUN_DETACHED=1}      };
Tcl2 proc FerryTerminal_Roads_2e55e4cf_856b_4510_8e11_a79aa739440b0_runner { parmListString workspaceFile } {    set workspaceFileUnix [regsub -all {\\} $workspaceFile {/}];    set parmListString [string range $parmListString 1 end-1];    set comment {        Build up the command line in a list, which we'll "eval" to get        at its pieces when we actually execute the "exec".    };    lappend commandArguments {*}$::__WR_ENV_HELPER__ {$(FME_HOME_UNIX)/fme}                             $workspaceFileUnix;    set parmList [split $parmListString {,}];    set comment {        At the same time, remember the TYPES for each of the parameters so        we can avoid logging any passwords in plain text (PR 64546)    };    set parmTypes [split {MULTIFILE,FILENAME} {,}];    set comment {        Note that foreach can walk thorugh more than one list at a time.        If the lists were ever out of sync (had different #s of entries, which should be impossible)        the iteration continues with the shorter list return an empty string. So we should be okay    };    set commandArgumentsToLog $commandArguments;    foreach {parmName encodedValue} $parmList parmType $parmTypes {       set comment {           Decode the parameter value which we now know is very encoded to guard           it from the parser and append them each to a new list which will be passed           as the arguments to the exec function.  Note that the           parameter names need to be turned into macro settings by           prepending them with --           Note also that the WorkspaceRunner sometimes encodes attribute           dereferences by placing <amp> at the beginning rather than using @Value.           Further note that string range forgives if the ending index is > the length of           the string, so we can just ask for the first 5 characters           when we're checking for <amp>.       };       if {[string length $parmName] == 0} { continue; };       lappend commandArguments \"--$parmName\";       lappend commandArgumentsToLog \"--$parmName\";       set comment {           for backwards compatibility, replace first <amp>       };       if { [string range $encodedValue 0 4] == {<amp>} &&            [string length $encodedValue] > 5 } {           set encodedValue [string replace $encodedValue 0 4 {<at>Value<openparen>}]];           append encodedValue "<closeparen>";       };       set comment { We used to call FME_DecodeTextOrAttr here. After changes to                     the code that writes out the mapping file section, we don't                     need to do this any more because the value would be in the                     correct state of encoding as required by the child workspace       };       set comment { parameter values starting with '<' causes tcl exec to fail so                     we escape leading '<' with backslash and then do the reverse                     when parsing command line arguments       };       if { [string index $encodedValue 0] == {<} } {          set encodedValue "\\$encodedValue";       };       lappend commandArguments $encodedValue;       set comment {           Ensure that passwords are not added into the logmessage (PR 64546)           We'll guard against both PASSWORD and PASSWORD_CONFIRM GUI types           by checking if the word PASSWORD is in the GUI TYPE at all       };       if { [string first {PASSWORD} $parmType] != -1 } {           lappend commandArgumentsToLog {***};       } else {           lappend commandArgumentsToLog $encodedValue;       };    };    set comment {        Now optionally run this in a detached way if we were not supposed        to wait by adding & on the end to put it in the background.  And        at the same time, ensure that any stray stdout/stderr is routed to        null.    };    if { {Yes} == {No} } {        lappend commandArguments \">$::null_device\";        lappend commandArgumentsToLog \">$::null_device\";        lappend commandArguments \"<$::null_device\";        lappend commandArgumentsToLog \"<$::null_device\";        FME_LogMessage fme_inform \"FerryTerminal_Roads: Initiating run of FME Workspace $workspaceFile with command line:\";    } else {        FME_LogMessage fme_inform \"FerryTerminal_Roads: Running FME Workspace $workspaceFile with command line:\";    };    set comment {        The below 2>@1 forces any standard error output to go into the msg variable        or to NULL if we're running in the background.    };    lappend commandArguments {2>@1};    lappend commandArgumentsToLog {2>@1};    if { {Yes} == {No} } {        lappend commandArguments {&};        lappend commandArgumentsToLog {&};    };    FME_LogMessage fme_inform [concat FerryTerminal_Roads: $commandArgumentsToLog];    if { {Yes} == {No} } {       after 1000;       while { [FME_CanSpawnFme <Unused>] == {0} } {             after 2000;       };    };    if {[catch {eval [concat exec $commandArguments] } msg ]} {       set msg [regsub {\015*\012child[^\012]*$} $msg {}];       FME_LogMessage fme_warn \"FerryTerminal_Roads: Failed to run workspace $workspaceFileUnix -- Trace was:\n\n$msg\n\";       FME_SetAttribute _failure_message $msg;       return FAILURE;    } else {       global FerryTerminal_Roads_2e55e4cf_856b_4510_8e11_a79aa739440b0_process_count;       incr FerryTerminal_Roads_2e55e4cf_856b_4510_8e11_a79aa739440b0_process_count;       if { {Yes} == {No} } {           FME_LogMessage fme_inform \"FerryTerminal_Roads: Successfully initiated run of workspace $workspaceFile\";           global FerryTerminal_Roads_2e55e4cf_856b_4510_8e11_a79aa739440b0_all_processes;           lappend FerryTerminal_Roads_2e55e4cf_856b_4510_8e11_a79aa739440b0_all_processes $msg;       } else {           FME_LogMessage fme_inform \"FerryTerminal_Roads: Successfully ran workspace $workspaceFile\";       };       return SUCCESS;    }; }
FACTORY_DEF * TestFactory    FACTORY_NAME FerryTerminal_Roads_ExecutorAndRouter    INPUT  FEATURE_TYPE Path_SUCCEEDED    INPUT  FEATURE_TYPE Path_FAILED    TEST @Tcl2("FerryTerminal_Roads_2e55e4cf_856b_4510_8e11_a79aa739440b0_runner {(SourceDataset_GML_3,@EvaluateExpression(FDIV,STRING,$(ROADS_INPUT$encode)<backslash>Highways_Rrami_FerryTerminal_*.gml.gz,FerryTerminal_Roads),DestDataset_GEOPACKAGE,@EvaluateExpression(FDIV,STRING,$(DEST_FOLDER$encode)<backslash>FerryTerminal_Roads.gpkg,FerryTerminal_Roads))} {FerryTerminal.fmw}") == SUCCESS    OUTPUT PASSED FEATURE_TYPE FerryTerminal_Roads_SUCCEEDED    OUTPUT FAILED FEATURE_TYPE FerryTerminal_Roads_FAILED
Tcl2 proc FerryTerminal_Roads_2e55e4cf_856b_4510_8e11_a79aa739440b0_summarizer { } {     global FerryTerminal_Roads_2e55e4cf_856b_4510_8e11_a79aa739440b0_process_count;     set comment { incr 0 creates the variable if it wasn't present };     incr FerryTerminal_Roads_2e55e4cf_856b_4510_8e11_a79aa739440b0_process_count 0;     FME_SetAttribute _proc_count [set FerryTerminal_Roads_2e55e4cf_856b_4510_8e11_a79aa739440b0_process_count];     global FerryTerminal_Roads_2e55e4cf_856b_4510_8e11_a79aa739440b0_all_processes;     if {[info exists FerryTerminal_Roads_2e55e4cf_856b_4510_8e11_a79aa739440b0_all_processes]} {         set index 0;         foreach pid [set FerryTerminal_Roads_2e55e4cf_856b_4510_8e11_a79aa739440b0_all_processes] {             FME_SetAttribute \"_processes{$index}\" $pid;             incr index;         }     } }
FACTORY_DEF * CreationFactory    FACTORY_NAME FerryTerminal_Roads_SummaryMaker    CREATE_AT_END yes
# -------------------------------------------------------------------------
# Convert the workspace name to one containing only / -- Tcl likes this better
# (and so do I)
# And determine the "NULL" device so we can ensure we don't get stray output
# messing up our stdout if we are running workspaces in the background
# See http://wiki.tcl.tk/1649 for a description of the tcl_platform
# variable, the "platform" part seems to have valid values windows, unix, and
# macintosh (the latter of which is actually pre-OS X)
Tcl2 if { $tcl_platform(platform) == {windows} } {         set ::null_device {NUL:};         set ::__WR_ENV_HELPER__ {};      } else {         set ::null_device {/dev/null};         set ::__WR_ENV_HELPER__ {/usr/bin/env FME_SUBPROCESS_RUN_DETACHED=1}      };
Tcl2 proc FerryTerminal_Paths_4ab1e4f8_42a1_44f4_877c_13fe9635b0130_runner { parmListString workspaceFile } {    set workspaceFileUnix [regsub -all {\\} $workspaceFile {/}];    set parmListString [string range $parmListString 1 end-1];    set comment {        Build up the command line in a list, which we'll "eval" to get        at its pieces when we actually execute the "exec".    };    lappend commandArguments {*}$::__WR_ENV_HELPER__ {$(FME_HOME_UNIX)/fme}                             $workspaceFileUnix;    set parmList [split $parmListString {,}];    set comment {        At the same time, remember the TYPES for each of the parameters so        we can avoid logging any passwords in plain text (PR 64546)    };    set parmTypes [split {MULTIFILE,FILENAME} {,}];    set comment {        Note that foreach can walk thorugh more than one list at a time.        If the lists were ever out of sync (had different #s of entries, which should be impossible)        the iteration continues with the shorter list return an empty string. So we should be okay    };    set commandArgumentsToLog $commandArguments;    foreach {parmName encodedValue} $parmList parmType $parmTypes {       set comment {           Decode the parameter value which we now know is very encoded to guard           it from the parser and append them each to a new list which will be passed           as the arguments to the exec function.  Note that the           parameter names need to be turned into macro settings by           prepending them with --           Note also that the WorkspaceRunner sometimes encodes attribute           dereferences by placing <amp> at the beginning rather than using @Value.           Further note that string range forgives if the ending index is > the length of           the string, so we can just ask for the first 5 characters           when we're checking for <amp>.       };       if {[string length $parmName] == 0} { continue; };       lappend commandArguments \"--$parmName\";       lappend commandArgumentsToLog \"--$parmName\";       set comment {           for backwards compatibility, replace first <amp>       };       if { [string range $encodedValue 0 4] == {<amp>} &&            [string length $encodedValue] > 5 } {           set encodedValue [string replace $encodedValue 0 4 {<at>Value<openparen>}]];           append encodedValue "<closeparen>";       };       set comment { We used to call FME_DecodeTextOrAttr here. After changes to                     the code that writes out the mapping file section, we don't                     need to do this any more because the value would be in the                     correct state of encoding as required by the child workspace       };       set comment { parameter values starting with '<' causes tcl exec to fail so                     we escape leading '<' with backslash and then do the reverse                     when parsing command line arguments       };       if { [string index $encodedValue 0] == {<} } {          set encodedValue "\\$encodedValue";       };       lappend commandArguments $encodedValue;       set comment {           Ensure that passwords are not added into the logmessage (PR 64546)           We'll guard against both PASSWORD and PASSWORD_CONFIRM GUI types           by checking if the word PASSWORD is in the GUI TYPE at all       };       if { [string first {PASSWORD} $parmType] != -1 } {           lappend commandArgumentsToLog {***};       } else {           lappend commandArgumentsToLog $encodedValue;       };    };    set comment {        Now optionally run this in a detached way if we were not supposed        to wait by adding & on the end to put it in the background.  And        at the same time, ensure that any stray stdout/stderr is routed to        null.    };    if { {Yes} == {No} } {        lappend commandArguments \">$::null_device\";        lappend commandArgumentsToLog \">$::null_device\";        lappend commandArguments \"<$::null_device\";        lappend commandArgumentsToLog \"<$::null_device\";        FME_LogMessage fme_inform \"FerryTerminal_Paths: Initiating run of FME Workspace $workspaceFile with command line:\";    } else {        FME_LogMessage fme_inform \"FerryTerminal_Paths: Running FME Workspace $workspaceFile with command line:\";    };    set comment {        The below 2>@1 forces any standard error output to go into the msg variable        or to NULL if we're running in the background.    };    lappend commandArguments {2>@1};    lappend commandArgumentsToLog {2>@1};    if { {Yes} == {No} } {        lappend commandArguments {&};        lappend commandArgumentsToLog {&};    };    FME_LogMessage fme_inform [concat FerryTerminal_Paths: $commandArgumentsToLog];    if { {Yes} == {No} } {       after 1000;       while { [FME_CanSpawnFme <Unused>] == {0} } {             after 2000;       };    };    if {[catch {eval [concat exec $commandArguments] } msg ]} {       set msg [regsub {\015*\012child[^\012]*$} $msg {}];       FME_LogMessage fme_warn \"FerryTerminal_Paths: Failed to run workspace $workspaceFileUnix -- Trace was:\n\n$msg\n\";       FME_SetAttribute _failure_message $msg;       return FAILURE;    } else {       global FerryTerminal_Paths_4ab1e4f8_42a1_44f4_877c_13fe9635b0130_process_count;       incr FerryTerminal_Paths_4ab1e4f8_42a1_44f4_877c_13fe9635b0130_process_count;       if { {Yes} == {No} } {           FME_LogMessage fme_inform \"FerryTerminal_Paths: Successfully initiated run of workspace $workspaceFile\";           global FerryTerminal_Paths_4ab1e4f8_42a1_44f4_877c_13fe9635b0130_all_processes;           lappend FerryTerminal_Paths_4ab1e4f8_42a1_44f4_877c_13fe9635b0130_all_processes $msg;       } else {           FME_LogMessage fme_inform \"FerryTerminal_Paths: Successfully ran workspace $workspaceFile\";       };       return SUCCESS;    }; }
FACTORY_DEF * TestFactory    FACTORY_NAME FerryTerminal_Paths_ExecutorAndRouter    INPUT  FEATURE_TYPE FerryTerminal_Roads_SUCCEEDED    INPUT  FEATURE_TYPE FerryTerminal_Roads_FAILED    TEST @Tcl2("FerryTerminal_Paths_4ab1e4f8_42a1_44f4_877c_13fe9635b0130_runner {(SourceDataset_GML_3,@EvaluateExpression(FDIV,STRING,$(PATHS_INPUT$encode)<backslash>Highways_Paths_FerryTerminal_*.gml.gz,FerryTerminal_Paths),DestDataset_GEOPACKAGE,@EvaluateExpression(FDIV,STRING,$(DEST_FOLDER$encode)<backslash>FerryTerminal_Paths.gpkg,FerryTerminal_Paths))} {FerryTerminal.fmw}") == SUCCESS    OUTPUT PASSED FEATURE_TYPE FerryTerminal_Paths_SUCCEEDED    OUTPUT FAILED FEATURE_TYPE FerryTerminal_Paths_FAILED
Tcl2 proc FerryTerminal_Paths_4ab1e4f8_42a1_44f4_877c_13fe9635b0130_summarizer { } {     global FerryTerminal_Paths_4ab1e4f8_42a1_44f4_877c_13fe9635b0130_process_count;     set comment { incr 0 creates the variable if it wasn't present };     incr FerryTerminal_Paths_4ab1e4f8_42a1_44f4_877c_13fe9635b0130_process_count 0;     FME_SetAttribute _proc_count [set FerryTerminal_Paths_4ab1e4f8_42a1_44f4_877c_13fe9635b0130_process_count];     global FerryTerminal_Paths_4ab1e4f8_42a1_44f4_877c_13fe9635b0130_all_processes;     if {[info exists FerryTerminal_Paths_4ab1e4f8_42a1_44f4_877c_13fe9635b0130_all_processes]} {         set index 0;         foreach pid [set FerryTerminal_Paths_4ab1e4f8_42a1_44f4_877c_13fe9635b0130_all_processes] {             FME_SetAttribute \"_processes{$index}\" $pid;             incr index;         }     } }
FACTORY_DEF * CreationFactory    FACTORY_NAME FerryTerminal_Paths_SummaryMaker    CREATE_AT_END yes
# -------------------------------------------------------------------------
# Convert the workspace name to one containing only / -- Tcl likes this better
# (and so do I)
# And determine the "NULL" device so we can ensure we don't get stray output
# messing up our stdout if we are running workspaces in the background
# See http://wiki.tcl.tk/1649 for a description of the tcl_platform
# variable, the "platform" part seems to have valid values windows, unix, and
# macintosh (the latter of which is actually pre-OS X)
Tcl2 if { $tcl_platform(platform) == {windows} } {         set ::null_device {NUL:};         set ::__WR_ENV_HELPER__ {};      } else {         set ::null_device {/dev/null};         set ::__WR_ENV_HELPER__ {/usr/bin/env FME_SUBPROCESS_RUN_DETACHED=1}      };
Tcl2 proc RoadJunction_17861ee7_6da0_4069_87cf_4f1618cfc4510_runner { parmListString workspaceFile } {    set workspaceFileUnix [regsub -all {\\} $workspaceFile {/}];    set parmListString [string range $parmListString 1 end-1];    set comment {        Build up the command line in a list, which we'll "eval" to get        at its pieces when we actually execute the "exec".    };    lappend commandArguments {*}$::__WR_ENV_HELPER__ {$(FME_HOME_UNIX)/fme}                             $workspaceFileUnix;    set parmList [split $parmListString {,}];    set comment {        At the same time, remember the TYPES for each of the parameters so        we can avoid logging any passwords in plain text (PR 64546)    };    set parmTypes [split {MULTIFILE,FILENAME} {,}];    set comment {        Note that foreach can walk thorugh more than one list at a time.        If the lists were ever out of sync (had different #s of entries, which should be impossible)        the iteration continues with the shorter list return an empty string. So we should be okay    };    set commandArgumentsToLog $commandArguments;    foreach {parmName encodedValue} $parmList parmType $parmTypes {       set comment {           Decode the parameter value which we now know is very encoded to guard           it from the parser and append them each to a new list which will be passed           as the arguments to the exec function.  Note that the           parameter names need to be turned into macro settings by           prepending them with --           Note also that the WorkspaceRunner sometimes encodes attribute           dereferences by placing <amp> at the beginning rather than using @Value.           Further note that string range forgives if the ending index is > the length of           the string, so we can just ask for the first 5 characters           when we're checking for <amp>.       };       if {[string length $parmName] == 0} { continue; };       lappend commandArguments \"--$parmName\";       lappend commandArgumentsToLog \"--$parmName\";       set comment {           for backwards compatibility, replace first <amp>       };       if { [string range $encodedValue 0 4] == {<amp>} &&            [string length $encodedValue] > 5 } {           set encodedValue [string replace $encodedValue 0 4 {<at>Value<openparen>}]];           append encodedValue "<closeparen>";       };       set comment { We used to call FME_DecodeTextOrAttr here. After changes to                     the code that writes out the mapping file section, we don't                     need to do this any more because the value would be in the                     correct state of encoding as required by the child workspace       };       set comment { parameter values starting with '<' causes tcl exec to fail so                     we escape leading '<' with backslash and then do the reverse                     when parsing command line arguments       };       if { [string index $encodedValue 0] == {<} } {          set encodedValue "\\$encodedValue";       };       lappend commandArguments $encodedValue;       set comment {           Ensure that passwords are not added into the logmessage (PR 64546)           We'll guard against both PASSWORD and PASSWORD_CONFIRM GUI types           by checking if the word PASSWORD is in the GUI TYPE at all       };       if { [string first {PASSWORD} $parmType] != -1 } {           lappend commandArgumentsToLog {***};       } else {           lappend commandArgumentsToLog $encodedValue;       };    };    set comment {        Now optionally run this in a detached way if we were not supposed        to wait by adding & on the end to put it in the background.  And        at the same time, ensure that any stray stdout/stderr is routed to        null.    };    if { {Yes} == {No} } {        lappend commandArguments \">$::null_device\";        lappend commandArgumentsToLog \">$::null_device\";        lappend commandArguments \"<$::null_device\";        lappend commandArgumentsToLog \"<$::null_device\";        FME_LogMessage fme_inform \"RoadJunction: Initiating run of FME Workspace $workspaceFile with command line:\";    } else {        FME_LogMessage fme_inform \"RoadJunction: Running FME Workspace $workspaceFile with command line:\";    };    set comment {        The below 2>@1 forces any standard error output to go into the msg variable        or to NULL if we're running in the background.    };    lappend commandArguments {2>@1};    lappend commandArgumentsToLog {2>@1};    if { {Yes} == {No} } {        lappend commandArguments {&};        lappend commandArgumentsToLog {&};    };    FME_LogMessage fme_inform [concat RoadJunction: $commandArgumentsToLog];    if { {Yes} == {No} } {       after 1000;       while { [FME_CanSpawnFme <Unused>] == {0} } {             after 2000;       };    };    if {[catch {eval [concat exec $commandArguments] } msg ]} {       set msg [regsub {\015*\012child[^\012]*$} $msg {}];       FME_LogMessage fme_warn \"RoadJunction: Failed to run workspace $workspaceFileUnix -- Trace was:\n\n$msg\n\";       FME_SetAttribute _failure_message $msg;       return FAILURE;    } else {       global RoadJunction_17861ee7_6da0_4069_87cf_4f1618cfc4510_process_count;       incr RoadJunction_17861ee7_6da0_4069_87cf_4f1618cfc4510_process_count;       if { {Yes} == {No} } {           FME_LogMessage fme_inform \"RoadJunction: Successfully initiated run of workspace $workspaceFile\";           global RoadJunction_17861ee7_6da0_4069_87cf_4f1618cfc4510_all_processes;           lappend RoadJunction_17861ee7_6da0_4069_87cf_4f1618cfc4510_all_processes $msg;       } else {           FME_LogMessage fme_inform \"RoadJunction: Successfully ran workspace $workspaceFile\";       };       return SUCCESS;    }; }
FACTORY_DEF * TestFactory    FACTORY_NAME RoadJunction_ExecutorAndRouter    INPUT  FEATURE_TYPE FerryTerminal_Paths_SUCCEEDED    INPUT  FEATURE_TYPE FerryTerminal_Paths_FAILED    TEST @Tcl2("RoadJunction_17861ee7_6da0_4069_87cf_4f1618cfc4510_runner {(SourceDataset_RoadJunction,@EvaluateExpression(FDIV,STRING,$(ROADS_INPUT$encode)<backslash>Highways_Rrami_RoadJunction_*.gml*,RoadJunction),DestDataset_RoadJunction,@EvaluateExpression(FDIV,STRING,$(DEST_FOLDER$encode)<backslash>RoadJunction.gpkg,RoadJunction))} {RoadJunction.fmw}") == SUCCESS    OUTPUT PASSED FEATURE_TYPE RoadJunction_SUCCEEDED    OUTPUT FAILED FEATURE_TYPE RoadJunction_FAILED
Tcl2 proc RoadJunction_17861ee7_6da0_4069_87cf_4f1618cfc4510_summarizer { } {     global RoadJunction_17861ee7_6da0_4069_87cf_4f1618cfc4510_process_count;     set comment { incr 0 creates the variable if it wasn't present };     incr RoadJunction_17861ee7_6da0_4069_87cf_4f1618cfc4510_process_count 0;     FME_SetAttribute _proc_count [set RoadJunction_17861ee7_6da0_4069_87cf_4f1618cfc4510_process_count];     global RoadJunction_17861ee7_6da0_4069_87cf_4f1618cfc4510_all_processes;     if {[info exists RoadJunction_17861ee7_6da0_4069_87cf_4f1618cfc4510_all_processes]} {         set index 0;         foreach pid [set RoadJunction_17861ee7_6da0_4069_87cf_4f1618cfc4510_all_processes] {             FME_SetAttribute \"_processes{$index}\" $pid;             incr index;         }     } }
FACTORY_DEF * CreationFactory    FACTORY_NAME RoadJunction_SummaryMaker    CREATE_AT_END yes
# -------------------------------------------------------------------------
# Convert the workspace name to one containing only / -- Tcl likes this better
# (and so do I)
# And determine the "NULL" device so we can ensure we don't get stray output
# messing up our stdout if we are running workspaces in the background
# See http://wiki.tcl.tk/1649 for a description of the tcl_platform
# variable, the "platform" part seems to have valid values windows, unix, and
# macintosh (the latter of which is actually pre-OS X)
Tcl2 if { $tcl_platform(platform) == {windows} } {         set ::null_device {NUL:};         set ::__WR_ENV_HELPER__ {};      } else {         set ::null_device {/dev/null};         set ::__WR_ENV_HELPER__ {/usr/bin/env FME_SUBPROCESS_RUN_DETACHED=1}      };
Tcl2 proc AssetManagement_Roads_f86e09c7_2eab_40d1_900f_0915d9e555910_runner { parmListString workspaceFile } {    set workspaceFileUnix [regsub -all {\\} $workspaceFile {/}];    set parmListString [string range $parmListString 1 end-1];    set comment {        Build up the command line in a list, which we'll "eval" to get        at its pieces when we actually execute the "exec".    };    lappend commandArguments {*}$::__WR_ENV_HELPER__ {$(FME_HOME_UNIX)/fme}                             $workspaceFileUnix;    set parmList [split $parmListString {,}];    set comment {        At the same time, remember the TYPES for each of the parameters so        we can avoid logging any passwords in plain text (PR 64546)    };    set parmTypes [split {MULTIFILE,MULTIFILE,MULTIFILE,MULTIFILE,FILENAME,FILENAME} {,}];    set comment {        Note that foreach can walk thorugh more than one list at a time.        If the lists were ever out of sync (had different #s of entries, which should be impossible)        the iteration continues with the shorter list return an empty string. So we should be okay    };    set commandArgumentsToLog $commandArguments;    foreach {parmName encodedValue} $parmList parmType $parmTypes {       set comment {           Decode the parameter value which we now know is very encoded to guard           it from the parser and append them each to a new list which will be passed           as the arguments to the exec function.  Note that the           parameter names need to be turned into macro settings by           prepending them with --           Note also that the WorkspaceRunner sometimes encodes attribute           dereferences by placing <amp> at the beginning rather than using @Value.           Further note that string range forgives if the ending index is > the length of           the string, so we can just ask for the first 5 characters           when we're checking for <amp>.       };       if {[string length $parmName] == 0} { continue; };       lappend commandArguments \"--$parmName\";       lappend commandArgumentsToLog \"--$parmName\";       set comment {           for backwards compatibility, replace first <amp>       };       if { [string range $encodedValue 0 4] == {<amp>} &&            [string length $encodedValue] > 5 } {           set encodedValue [string replace $encodedValue 0 4 {<at>Value<openparen>}]];           append encodedValue "<closeparen>";       };       set comment { We used to call FME_DecodeTextOrAttr here. After changes to                     the code that writes out the mapping file section, we don't                     need to do this any more because the value would be in the                     correct state of encoding as required by the child workspace       };       set comment { parameter values starting with '<' causes tcl exec to fail so                     we escape leading '<' with backslash and then do the reverse                     when parsing command line arguments       };       if { [string index $encodedValue 0] == {<} } {          set encodedValue "\\$encodedValue";       };       lappend commandArguments $encodedValue;       set comment {           Ensure that passwords are not added into the logmessage (PR 64546)           We'll guard against both PASSWORD and PASSWORD_CONFIRM GUI types           by checking if the word PASSWORD is in the GUI TYPE at all       };       if { [string first {PASSWORD} $parmType] != -1 } {           lappend commandArgumentsToLog {***};       } else {           lappend commandArgumentsToLog $encodedValue;       };    };    set comment {        Now optionally run this in a detached way if we were not supposed        to wait by adding & on the end to put it in the background.  And        at the same time, ensure that any stray stdout/stderr is routed to        null.    };    if { {Yes} == {No} } {        lappend commandArguments \">$::null_device\";        lappend commandArgumentsToLog \">$::null_device\";        lappend commandArguments \"<$::null_device\";        lappend commandArgumentsToLog \"<$::null_device\";        FME_LogMessage fme_inform \"AssetManagement_Roads: Initiating run of FME Workspace $workspaceFile with command line:\";    } else {        FME_LogMessage fme_inform \"AssetManagement_Roads: Running FME Workspace $workspaceFile with command line:\";    };    set comment {        The below 2>@1 forces any standard error output to go into the msg variable        or to NULL if we're running in the background.    };    lappend commandArguments {2>@1};    lappend commandArgumentsToLog {2>@1};    if { {Yes} == {No} } {        lappend commandArguments {&};        lappend commandArgumentsToLog {&};    };    FME_LogMessage fme_inform [concat AssetManagement_Roads: $commandArgumentsToLog];    if { {Yes} == {No} } {       after 1000;       while { [FME_CanSpawnFme <Unused>] == {0} } {             after 2000;       };    };    if {[catch {eval [concat exec $commandArguments] } msg ]} {       set msg [regsub {\015*\012child[^\012]*$} $msg {}];       FME_LogMessage fme_warn \"AssetManagement_Roads: Failed to run workspace $workspaceFileUnix -- Trace was:\n\n$msg\n\";       FME_SetAttribute _failure_message $msg;       return FAILURE;    } else {       global AssetManagement_Roads_f86e09c7_2eab_40d1_900f_0915d9e555910_process_count;       incr AssetManagement_Roads_f86e09c7_2eab_40d1_900f_0915d9e555910_process_count;       if { {Yes} == {No} } {           FME_LogMessage fme_inform \"AssetManagement_Roads: Successfully initiated run of workspace $workspaceFile\";           global AssetManagement_Roads_f86e09c7_2eab_40d1_900f_0915d9e555910_all_processes;           lappend AssetManagement_Roads_f86e09c7_2eab_40d1_900f_0915d9e555910_all_processes $msg;       } else {           FME_LogMessage fme_inform \"AssetManagement_Roads: Successfully ran workspace $workspaceFile\";       };       return SUCCESS;    }; }
FACTORY_DEF * TestFactory    FACTORY_NAME AssetManagement_Roads_ExecutorAndRouter    INPUT  FEATURE_TYPE RoadJunction_SUCCEEDED    INPUT  FEATURE_TYPE RoadJunction_FAILED    TEST @Tcl2("AssetManagement_Roads_f86e09c7_2eab_40d1_900f_0915d9e555910_runner {(SourceDataset_Maintenance,@EvaluateExpression(FDIV,STRING,$(ROADS_INPUT$encode)<backslash>Highways_Rrami_Maintenance_*.gml.gz,AssetManagement_Roads),SourceDataset_Reinstatement,@EvaluateExpression(FDIV,STRING,$(ROADS_INPUT$encode)<backslash>Highways_Rrami_Reinstatement_*.gml.gz,AssetManagement_Roads),SourceDataset_SpecialDesignation,@EvaluateExpression(FDIV,STRING,$(ROADS_INPUT$encode)<backslash>Highways_Rrami_SpecialDesignation_*.gml.gz,AssetManagement_Roads),SourceDataset_Street,@EvaluateExpression(FDIV,STRING,$(ROADS_INPUT$encode)<backslash>Highways_Rrami_Street_*.gml.gz,AssetManagement_Roads),DestDataset_AssetManagement,@EvaluateExpression(FDIV,STRING,$(DEST_FOLDER$encode)<backslash>AssetManagement_Roads.gpkg,AssetManagement_Roads),DestDataset_SpDesignation,@EvaluateExpression(FDIV,STRING,$(DEST_FOLDER$encode)<backslash>SpDesignation_Roads.gpkg,AssetManagement_Roads))} {AssetManagement.fmw}") == SUCCESS    OUTPUT PASSED FEATURE_TYPE AssetManagement_Roads_SUCCEEDED    OUTPUT FAILED FEATURE_TYPE AssetManagement_Roads_FAILED
Tcl2 proc AssetManagement_Roads_f86e09c7_2eab_40d1_900f_0915d9e555910_summarizer { } {     global AssetManagement_Roads_f86e09c7_2eab_40d1_900f_0915d9e555910_process_count;     set comment { incr 0 creates the variable if it wasn't present };     incr AssetManagement_Roads_f86e09c7_2eab_40d1_900f_0915d9e555910_process_count 0;     FME_SetAttribute _proc_count [set AssetManagement_Roads_f86e09c7_2eab_40d1_900f_0915d9e555910_process_count];     global AssetManagement_Roads_f86e09c7_2eab_40d1_900f_0915d9e555910_all_processes;     if {[info exists AssetManagement_Roads_f86e09c7_2eab_40d1_900f_0915d9e555910_all_processes]} {         set index 0;         foreach pid [set AssetManagement_Roads_f86e09c7_2eab_40d1_900f_0915d9e555910_all_processes] {             FME_SetAttribute \"_processes{$index}\" $pid;             incr index;         }     } }
FACTORY_DEF * CreationFactory    FACTORY_NAME AssetManagement_Roads_SummaryMaker    CREATE_AT_END yes
# -------------------------------------------------------------------------
# Convert the workspace name to one containing only / -- Tcl likes this better
# (and so do I)
# And determine the "NULL" device so we can ensure we don't get stray output
# messing up our stdout if we are running workspaces in the background
# See http://wiki.tcl.tk/1649 for a description of the tcl_platform
# variable, the "platform" part seems to have valid values windows, unix, and
# macintosh (the latter of which is actually pre-OS X)
Tcl2 if { $tcl_platform(platform) == {windows} } {         set ::null_device {NUL:};         set ::__WR_ENV_HELPER__ {};      } else {         set ::null_device {/dev/null};         set ::__WR_ENV_HELPER__ {/usr/bin/env FME_SUBPROCESS_RUN_DETACHED=1}      };
Tcl2 proc AssetManagement_Paths_32340e2d_5339_449f_a691_33a37dddf4360_runner { parmListString workspaceFile } {    set workspaceFileUnix [regsub -all {\\} $workspaceFile {/}];    set parmListString [string range $parmListString 1 end-1];    set comment {        Build up the command line in a list, which we'll "eval" to get        at its pieces when we actually execute the "exec".    };    lappend commandArguments {*}$::__WR_ENV_HELPER__ {$(FME_HOME_UNIX)/fme}                             $workspaceFileUnix;    set parmList [split $parmListString {,}];    set comment {        At the same time, remember the TYPES for each of the parameters so        we can avoid logging any passwords in plain text (PR 64546)    };    set parmTypes [split {MULTIFILE,MULTIFILE,MULTIFILE,MULTIFILE,FILENAME,FILENAME} {,}];    set comment {        Note that foreach can walk thorugh more than one list at a time.        If the lists were ever out of sync (had different #s of entries, which should be impossible)        the iteration continues with the shorter list return an empty string. So we should be okay    };    set commandArgumentsToLog $commandArguments;    foreach {parmName encodedValue} $parmList parmType $parmTypes {       set comment {           Decode the parameter value which we now know is very encoded to guard           it from the parser and append them each to a new list which will be passed           as the arguments to the exec function.  Note that the           parameter names need to be turned into macro settings by           prepending them with --           Note also that the WorkspaceRunner sometimes encodes attribute           dereferences by placing <amp> at the beginning rather than using @Value.           Further note that string range forgives if the ending index is > the length of           the string, so we can just ask for the first 5 characters           when we're checking for <amp>.       };       if {[string length $parmName] == 0} { continue; };       lappend commandArguments \"--$parmName\";       lappend commandArgumentsToLog \"--$parmName\";       set comment {           for backwards compatibility, replace first <amp>       };       if { [string range $encodedValue 0 4] == {<amp>} &&            [string length $encodedValue] > 5 } {           set encodedValue [string replace $encodedValue 0 4 {<at>Value<openparen>}]];           append encodedValue "<closeparen>";       };       set comment { We used to call FME_DecodeTextOrAttr here. After changes to                     the code that writes out the mapping file section, we don't                     need to do this any more because the value would be in the                     correct state of encoding as required by the child workspace       };       set comment { parameter values starting with '<' causes tcl exec to fail so                     we escape leading '<' with backslash and then do the reverse                     when parsing command line arguments       };       if { [string index $encodedValue 0] == {<} } {          set encodedValue "\\$encodedValue";       };       lappend commandArguments $encodedValue;       set comment {           Ensure that passwords are not added into the logmessage (PR 64546)           We'll guard against both PASSWORD and PASSWORD_CONFIRM GUI types           by checking if the word PASSWORD is in the GUI TYPE at all       };       if { [string first {PASSWORD} $parmType] != -1 } {           lappend commandArgumentsToLog {***};       } else {           lappend commandArgumentsToLog $encodedValue;       };    };    set comment {        Now optionally run this in a detached way if we were not supposed        to wait by adding & on the end to put it in the background.  And        at the same time, ensure that any stray stdout/stderr is routed to        null.    };    if { {Yes} == {No} } {        lappend commandArguments \">$::null_device\";        lappend commandArgumentsToLog \">$::null_device\";        lappend commandArguments \"<$::null_device\";        lappend commandArgumentsToLog \"<$::null_device\";        FME_LogMessage fme_inform \"AssetManagement_Paths: Initiating run of FME Workspace $workspaceFile with command line:\";    } else {        FME_LogMessage fme_inform \"AssetManagement_Paths: Running FME Workspace $workspaceFile with command line:\";    };    set comment {        The below 2>@1 forces any standard error output to go into the msg variable        or to NULL if we're running in the background.    };    lappend commandArguments {2>@1};    lappend commandArgumentsToLog {2>@1};    if { {Yes} == {No} } {        lappend commandArguments {&};        lappend commandArgumentsToLog {&};    };    FME_LogMessage fme_inform [concat AssetManagement_Paths: $commandArgumentsToLog];    if { {Yes} == {No} } {       after 1000;       while { [FME_CanSpawnFme <Unused>] == {0} } {             after 2000;       };    };    if {[catch {eval [concat exec $commandArguments] } msg ]} {       set msg [regsub {\015*\012child[^\012]*$} $msg {}];       FME_LogMessage fme_warn \"AssetManagement_Paths: Failed to run workspace $workspaceFileUnix -- Trace was:\n\n$msg\n\";       FME_SetAttribute _failure_message $msg;       return FAILURE;    } else {       global AssetManagement_Paths_32340e2d_5339_449f_a691_33a37dddf4360_process_count;       incr AssetManagement_Paths_32340e2d_5339_449f_a691_33a37dddf4360_process_count;       if { {Yes} == {No} } {           FME_LogMessage fme_inform \"AssetManagement_Paths: Successfully initiated run of workspace $workspaceFile\";           global AssetManagement_Paths_32340e2d_5339_449f_a691_33a37dddf4360_all_processes;           lappend AssetManagement_Paths_32340e2d_5339_449f_a691_33a37dddf4360_all_processes $msg;       } else {           FME_LogMessage fme_inform \"AssetManagement_Paths: Successfully ran workspace $workspaceFile\";       };       return SUCCESS;    }; }
FACTORY_DEF * TestFactory    FACTORY_NAME AssetManagement_Paths_ExecutorAndRouter    INPUT  FEATURE_TYPE AssetManagement_Roads_SUCCEEDED    INPUT  FEATURE_TYPE AssetManagement_Roads_FAILED    TEST @Tcl2("AssetManagement_Paths_32340e2d_5339_449f_a691_33a37dddf4360_runner {(SourceDataset_Maintenance,@EvaluateExpression(FDIV,STRING,$(PATHS_INPUT$encode)<backslash>Highways_Paths_Maintenance_*.gml.gz,AssetManagement_Paths),SourceDataset_Reinstatement,@EvaluateExpression(FDIV,STRING,$(PATHS_INPUT$encode)<backslash>Highways_Paths_Reinstatement_*.gml.gz,AssetManagement_Paths),SourceDataset_SpecialDesignation,@EvaluateExpression(FDIV,STRING,$(PATHS_INPUT$encode)<backslash>Highways_Paths_SpecialDesignation_*.gml.gz,AssetManagement_Paths),SourceDataset_Street,@EvaluateExpression(FDIV,STRING,$(PATHS_INPUT$encode)<backslash>Highways_Paths_Street_*.gml.gz,AssetManagement_Paths),DestDataset_AssetManagement,@EvaluateExpression(FDIV,STRING,$(DEST_FOLDER$encode)<backslash>AssetManagement_Paths.gpkg,AssetManagement_Paths),DestDataset_SpDesignation,@EvaluateExpression(FDIV,STRING,$(DEST_FOLDER$encode)<backslash>SpDesignation_Paths.gpkg,AssetManagement_Paths))} {AssetManagement.fmw}") == SUCCESS    OUTPUT PASSED FEATURE_TYPE AssetManagement_Paths_SUCCEEDED    OUTPUT FAILED FEATURE_TYPE AssetManagement_Paths_FAILED
Tcl2 proc AssetManagement_Paths_32340e2d_5339_449f_a691_33a37dddf4360_summarizer { } {     global AssetManagement_Paths_32340e2d_5339_449f_a691_33a37dddf4360_process_count;     set comment { incr 0 creates the variable if it wasn't present };     incr AssetManagement_Paths_32340e2d_5339_449f_a691_33a37dddf4360_process_count 0;     FME_SetAttribute _proc_count [set AssetManagement_Paths_32340e2d_5339_449f_a691_33a37dddf4360_process_count];     global AssetManagement_Paths_32340e2d_5339_449f_a691_33a37dddf4360_all_processes;     if {[info exists AssetManagement_Paths_32340e2d_5339_449f_a691_33a37dddf4360_all_processes]} {         set index 0;         foreach pid [set AssetManagement_Paths_32340e2d_5339_449f_a691_33a37dddf4360_all_processes] {             FME_SetAttribute \"_processes{$index}\" $pid;             incr index;         }     } }
FACTORY_DEF * CreationFactory    FACTORY_NAME AssetManagement_Paths_SummaryMaker    CREATE_AT_END yes
# -------------------------------------------------------------------------
# Convert the workspace name to one containing only / -- Tcl likes this better
# (and so do I)
# And determine the "NULL" device so we can ensure we don't get stray output
# messing up our stdout if we are running workspaces in the background
# See http://wiki.tcl.tk/1649 for a description of the tcl_platform
# variable, the "platform" part seems to have valid values windows, unix, and
# macintosh (the latter of which is actually pre-OS X)
Tcl2 if { $tcl_platform(platform) == {windows} } {         set ::null_device {NUL:};         set ::__WR_ENV_HELPER__ {};      } else {         set ::null_device {/dev/null};         set ::__WR_ENV_HELPER__ {/usr/bin/env FME_SUBPROCESS_RUN_DETACHED=1}      };
Tcl2 proc AccessRestriction_aceee611_3518_42b2_96c1_2d7f5885f8f90_runner { parmListString workspaceFile } {    set workspaceFileUnix [regsub -all {\\} $workspaceFile {/}];    set parmListString [string range $parmListString 1 end-1];    set comment {        Build up the command line in a list, which we'll "eval" to get        at its pieces when we actually execute the "exec".    };    lappend commandArguments {*}$::__WR_ENV_HELPER__ {$(FME_HOME_UNIX)/fme}                             $workspaceFileUnix;    set parmList [split $parmListString {,}];    set comment {        At the same time, remember the TYPES for each of the parameters so        we can avoid logging any passwords in plain text (PR 64546)    };    set parmTypes [split {MULTIFILE,MULTIFILE,FILENAME} {,}];    set comment {        Note that foreach can walk thorugh more than one list at a time.        If the lists were ever out of sync (had different #s of entries, which should be impossible)        the iteration continues with the shorter list return an empty string. So we should be okay    };    set commandArgumentsToLog $commandArguments;    foreach {parmName encodedValue} $parmList parmType $parmTypes {       set comment {           Decode the parameter value which we now know is very encoded to guard           it from the parser and append them each to a new list which will be passed           as the arguments to the exec function.  Note that the           parameter names need to be turned into macro settings by           prepending them with --           Note also that the WorkspaceRunner sometimes encodes attribute           dereferences by placing <amp> at the beginning rather than using @Value.           Further note that string range forgives if the ending index is > the length of           the string, so we can just ask for the first 5 characters           when we're checking for <amp>.       };       if {[string length $parmName] == 0} { continue; };       lappend commandArguments \"--$parmName\";       lappend commandArgumentsToLog \"--$parmName\";       set comment {           for backwards compatibility, replace first <amp>       };       if { [string range $encodedValue 0 4] == {<amp>} &&            [string length $encodedValue] > 5 } {           set encodedValue [string replace $encodedValue 0 4 {<at>Value<openparen>}]];           append encodedValue "<closeparen>";       };       set comment { We used to call FME_DecodeTextOrAttr here. After changes to                     the code that writes out the mapping file section, we don't                     need to do this any more because the value would be in the                     correct state of encoding as required by the child workspace       };       set comment { parameter values starting with '<' causes tcl exec to fail so                     we escape leading '<' with backslash and then do the reverse                     when parsing command line arguments       };       if { [string index $encodedValue 0] == {<} } {          set encodedValue "\\$encodedValue";       };       lappend commandArguments $encodedValue;       set comment {           Ensure that passwords are not added into the logmessage (PR 64546)           We'll guard against both PASSWORD and PASSWORD_CONFIRM GUI types           by checking if the word PASSWORD is in the GUI TYPE at all       };       if { [string first {PASSWORD} $parmType] != -1 } {           lappend commandArgumentsToLog {***};       } else {           lappend commandArgumentsToLog $encodedValue;       };    };    set comment {        Now optionally run this in a detached way if we were not supposed        to wait by adding & on the end to put it in the background.  And        at the same time, ensure that any stray stdout/stderr is routed to        null.    };    if { {Yes} == {No} } {        lappend commandArguments \">$::null_device\";        lappend commandArgumentsToLog \">$::null_device\";        lappend commandArguments \"<$::null_device\";        lappend commandArgumentsToLog \"<$::null_device\";        FME_LogMessage fme_inform \"AccessRestriction: Initiating run of FME Workspace $workspaceFile with command line:\";    } else {        FME_LogMessage fme_inform \"AccessRestriction: Running FME Workspace $workspaceFile with command line:\";    };    set comment {        The below 2>@1 forces any standard error output to go into the msg variable        or to NULL if we're running in the background.    };    lappend commandArguments {2>@1};    lappend commandArgumentsToLog {2>@1};    if { {Yes} == {No} } {        lappend commandArguments {&};        lappend commandArgumentsToLog {&};    };    FME_LogMessage fme_inform [concat AccessRestriction: $commandArgumentsToLog];    if { {Yes} == {No} } {       after 1000;       while { [FME_CanSpawnFme <Unused>] == {0} } {             after 2000;       };    };    if {[catch {eval [concat exec $commandArguments] } msg ]} {       set msg [regsub {\015*\012child[^\012]*$} $msg {}];       FME_LogMessage fme_warn \"AccessRestriction: Failed to run workspace $workspaceFileUnix -- Trace was:\n\n$msg\n\";       FME_SetAttribute _failure_message $msg;       return FAILURE;    } else {       global AccessRestriction_aceee611_3518_42b2_96c1_2d7f5885f8f90_process_count;       incr AccessRestriction_aceee611_3518_42b2_96c1_2d7f5885f8f90_process_count;       if { {Yes} == {No} } {           FME_LogMessage fme_inform \"AccessRestriction: Successfully initiated run of workspace $workspaceFile\";           global AccessRestriction_aceee611_3518_42b2_96c1_2d7f5885f8f90_all_processes;           lappend AccessRestriction_aceee611_3518_42b2_96c1_2d7f5885f8f90_all_processes $msg;       } else {           FME_LogMessage fme_inform \"AccessRestriction: Successfully ran workspace $workspaceFile\";       };       return SUCCESS;    }; }
FACTORY_DEF * TestFactory    FACTORY_NAME AccessRestriction_ExecutorAndRouter    INPUT  FEATURE_TYPE AssetManagement_Paths_SUCCEEDED    INPUT  FEATURE_TYPE AssetManagement_Paths_FAILED    TEST @Tcl2("AccessRestriction_aceee611_3518_42b2_96c1_2d7f5885f8f90_runner {(SourceDataset_RoadLink,@EvaluateExpression(FDIV,STRING,$(ROADS_INPUT$encode)<backslash>Highways_Rrami_RoadLink_*.gml.gz,AccessRestriction),SourceDataset_GML_3,@EvaluateExpression(FDIV,STRING,$(ROADS_INPUT$encode)<backslash>Highways_Rrami_AccessRestriction_*.gml.gz,AccessRestriction),DestDataset_GEOPACKAGE,@EvaluateExpression(FDIV,STRING,$(DEST_FOLDER$encode)<backslash>AccessRestriction.gpkg,AccessRestriction))} {AccessRestriction.fmw}") == SUCCESS    OUTPUT PASSED FEATURE_TYPE AccessRestriction_SUCCEEDED    OUTPUT FAILED FEATURE_TYPE AccessRestriction_FAILED
Tcl2 proc AccessRestriction_aceee611_3518_42b2_96c1_2d7f5885f8f90_summarizer { } {     global AccessRestriction_aceee611_3518_42b2_96c1_2d7f5885f8f90_process_count;     set comment { incr 0 creates the variable if it wasn't present };     incr AccessRestriction_aceee611_3518_42b2_96c1_2d7f5885f8f90_process_count 0;     FME_SetAttribute _proc_count [set AccessRestriction_aceee611_3518_42b2_96c1_2d7f5885f8f90_process_count];     global AccessRestriction_aceee611_3518_42b2_96c1_2d7f5885f8f90_all_processes;     if {[info exists AccessRestriction_aceee611_3518_42b2_96c1_2d7f5885f8f90_all_processes]} {         set index 0;         foreach pid [set AccessRestriction_aceee611_3518_42b2_96c1_2d7f5885f8f90_all_processes] {             FME_SetAttribute \"_processes{$index}\" $pid;             incr index;         }     } }
FACTORY_DEF * CreationFactory    FACTORY_NAME AccessRestriction_SummaryMaker    CREATE_AT_END yes
# -------------------------------------------------------------------------
# Convert the workspace name to one containing only / -- Tcl likes this better
# (and so do I)
# And determine the "NULL" device so we can ensure we don't get stray output
# messing up our stdout if we are running workspaces in the background
# See http://wiki.tcl.tk/1649 for a description of the tcl_platform
# variable, the "platform" part seems to have valid values windows, unix, and
# macintosh (the latter of which is actually pre-OS X)
Tcl2 if { $tcl_platform(platform) == {windows} } {         set ::null_device {NUL:};         set ::__WR_ENV_HELPER__ {};      } else {         set ::null_device {/dev/null};         set ::__WR_ENV_HELPER__ {/usr/bin/env FME_SUBPROCESS_RUN_DETACHED=1}      };
Tcl2 proc TurnRestriction_7b087b2f_7e76_45bb_a9e7_2905be80c0a70_runner { parmListString workspaceFile } {    set workspaceFileUnix [regsub -all {\\} $workspaceFile {/}];    set parmListString [string range $parmListString 1 end-1];    set comment {        Build up the command line in a list, which we'll "eval" to get        at its pieces when we actually execute the "exec".    };    lappend commandArguments {*}$::__WR_ENV_HELPER__ {$(FME_HOME_UNIX)/fme}                             $workspaceFileUnix;    set parmList [split $parmListString {,}];    set comment {        At the same time, remember the TYPES for each of the parameters so        we can avoid logging any passwords in plain text (PR 64546)    };    set parmTypes [split {MULTIFILE,MULTIFILE,FILENAME} {,}];    set comment {        Note that foreach can walk thorugh more than one list at a time.        If the lists were ever out of sync (had different #s of entries, which should be impossible)        the iteration continues with the shorter list return an empty string. So we should be okay    };    set commandArgumentsToLog $commandArguments;    foreach {parmName encodedValue} $parmList parmType $parmTypes {       set comment {           Decode the parameter value which we now know is very encoded to guard           it from the parser and append them each to a new list which will be passed           as the arguments to the exec function.  Note that the           parameter names need to be turned into macro settings by           prepending them with --           Note also that the WorkspaceRunner sometimes encodes attribute           dereferences by placing <amp> at the beginning rather than using @Value.           Further note that string range forgives if the ending index is > the length of           the string, so we can just ask for the first 5 characters           when we're checking for <amp>.       };       if {[string length $parmName] == 0} { continue; };       lappend commandArguments \"--$parmName\";       lappend commandArgumentsToLog \"--$parmName\";       set comment {           for backwards compatibility, replace first <amp>       };       if { [string range $encodedValue 0 4] == {<amp>} &&            [string length $encodedValue] > 5 } {           set encodedValue [string replace $encodedValue 0 4 {<at>Value<openparen>}]];           append encodedValue "<closeparen>";       };       set comment { We used to call FME_DecodeTextOrAttr here. After changes to                     the code that writes out the mapping file section, we don't                     need to do this any more because the value would be in the                     correct state of encoding as required by the child workspace       };       set comment { parameter values starting with '<' causes tcl exec to fail so                     we escape leading '<' with backslash and then do the reverse                     when parsing command line arguments       };       if { [string index $encodedValue 0] == {<} } {          set encodedValue "\\$encodedValue";       };       lappend commandArguments $encodedValue;       set comment {           Ensure that passwords are not added into the logmessage (PR 64546)           We'll guard against both PASSWORD and PASSWORD_CONFIRM GUI types           by checking if the word PASSWORD is in the GUI TYPE at all       };       if { [string first {PASSWORD} $parmType] != -1 } {           lappend commandArgumentsToLog {***};       } else {           lappend commandArgumentsToLog $encodedValue;       };    };    set comment {        Now optionally run this in a detached way if we were not supposed        to wait by adding & on the end to put it in the background.  And        at the same time, ensure that any stray stdout/stderr is routed to        null.    };    if { {Yes} == {No} } {        lappend commandArguments \">$::null_device\";        lappend commandArgumentsToLog \">$::null_device\";        lappend commandArguments \"<$::null_device\";        lappend commandArgumentsToLog \"<$::null_device\";        FME_LogMessage fme_inform \"TurnRestriction: Initiating run of FME Workspace $workspaceFile with command line:\";    } else {        FME_LogMessage fme_inform \"TurnRestriction: Running FME Workspace $workspaceFile with command line:\";    };    set comment {        The below 2>@1 forces any standard error output to go into the msg variable        or to NULL if we're running in the background.    };    lappend commandArguments {2>@1};    lappend commandArgumentsToLog {2>@1};    if { {Yes} == {No} } {        lappend commandArguments {&};        lappend commandArgumentsToLog {&};    };    FME_LogMessage fme_inform [concat TurnRestriction: $commandArgumentsToLog];    if { {Yes} == {No} } {       after 1000;       while { [FME_CanSpawnFme <Unused>] == {0} } {             after 2000;       };    };    if {[catch {eval [concat exec $commandArguments] } msg ]} {       set msg [regsub {\015*\012child[^\012]*$} $msg {}];       FME_LogMessage fme_warn \"TurnRestriction: Failed to run workspace $workspaceFileUnix -- Trace was:\n\n$msg\n\";       FME_SetAttribute _failure_message $msg;       return FAILURE;    } else {       global TurnRestriction_7b087b2f_7e76_45bb_a9e7_2905be80c0a70_process_count;       incr TurnRestriction_7b087b2f_7e76_45bb_a9e7_2905be80c0a70_process_count;       if { {Yes} == {No} } {           FME_LogMessage fme_inform \"TurnRestriction: Successfully initiated run of workspace $workspaceFile\";           global TurnRestriction_7b087b2f_7e76_45bb_a9e7_2905be80c0a70_all_processes;           lappend TurnRestriction_7b087b2f_7e76_45bb_a9e7_2905be80c0a70_all_processes $msg;       } else {           FME_LogMessage fme_inform \"TurnRestriction: Successfully ran workspace $workspaceFile\";       };       return SUCCESS;    }; }
FACTORY_DEF * TestFactory    FACTORY_NAME TurnRestriction_ExecutorAndRouter    INPUT  FEATURE_TYPE AccessRestriction_SUCCEEDED    INPUT  FEATURE_TYPE AccessRestriction_FAILED    TEST @Tcl2("TurnRestriction_7b087b2f_7e76_45bb_a9e7_2905be80c0a70_runner {(SourceDataset_RoadLink,@EvaluateExpression(FDIV,STRING,$(ROADS_INPUT$encode)<backslash>Highways_Rrami_RoadLink_*.gml.gz,TurnRestriction),SourceDataset_TurnRestriction,@EvaluateExpression(FDIV,STRING,$(ROADS_INPUT$encode)<backslash>Highways_Rrami_TurnRestriction_*.gml.gz,TurnRestriction),DestDataset_GEOPACKAGE,@EvaluateExpression(FDIV,STRING,$(DEST_FOLDER$encode)<backslash>TurnRestriction.gpkg,TurnRestriction))} {TurnRestrictions.fmw}") == SUCCESS    OUTPUT PASSED FEATURE_TYPE TurnRestriction_SUCCEEDED    OUTPUT FAILED FEATURE_TYPE TurnRestriction_FAILED
Tcl2 proc TurnRestriction_7b087b2f_7e76_45bb_a9e7_2905be80c0a70_summarizer { } {     global TurnRestriction_7b087b2f_7e76_45bb_a9e7_2905be80c0a70_process_count;     set comment { incr 0 creates the variable if it wasn't present };     incr TurnRestriction_7b087b2f_7e76_45bb_a9e7_2905be80c0a70_process_count 0;     FME_SetAttribute _proc_count [set TurnRestriction_7b087b2f_7e76_45bb_a9e7_2905be80c0a70_process_count];     global TurnRestriction_7b087b2f_7e76_45bb_a9e7_2905be80c0a70_all_processes;     if {[info exists TurnRestriction_7b087b2f_7e76_45bb_a9e7_2905be80c0a70_all_processes]} {         set index 0;         foreach pid [set TurnRestriction_7b087b2f_7e76_45bb_a9e7_2905be80c0a70_all_processes] {             FME_SetAttribute \"_processes{$index}\" $pid;             incr index;         }     } }
FACTORY_DEF * CreationFactory    FACTORY_NAME TurnRestriction_SummaryMaker    CREATE_AT_END yes
# -------------------------------------------------------------------------
# Convert the workspace name to one containing only / -- Tcl likes this better
# (and so do I)
# And determine the "NULL" device so we can ensure we don't get stray output
# messing up our stdout if we are running workspaces in the background
# See http://wiki.tcl.tk/1649 for a description of the tcl_platform
# variable, the "platform" part seems to have valid values windows, unix, and
# macintosh (the latter of which is actually pre-OS X)
Tcl2 if { $tcl_platform(platform) == {windows} } {         set ::null_device {NUL:};         set ::__WR_ENV_HELPER__ {};      } else {         set ::null_device {/dev/null};         set ::__WR_ENV_HELPER__ {/usr/bin/env FME_SUBPROCESS_RUN_DETACHED=1}      };
Tcl2 proc RestrictionForVehicles_1db42255_d050_4328_b32e_c379bac01fec0_runner { parmListString workspaceFile } {    set workspaceFileUnix [regsub -all {\\} $workspaceFile {/}];    set parmListString [string range $parmListString 1 end-1];    set comment {        Build up the command line in a list, which we'll "eval" to get        at its pieces when we actually execute the "exec".    };    lappend commandArguments {*}$::__WR_ENV_HELPER__ {$(FME_HOME_UNIX)/fme}                             $workspaceFileUnix;    set parmList [split $parmListString {,}];    set comment {        At the same time, remember the TYPES for each of the parameters so        we can avoid logging any passwords in plain text (PR 64546)    };    set parmTypes [split {MULTIFILE,MULTIFILE,FILENAME} {,}];    set comment {        Note that foreach can walk thorugh more than one list at a time.        If the lists were ever out of sync (had different #s of entries, which should be impossible)        the iteration continues with the shorter list return an empty string. So we should be okay    };    set commandArgumentsToLog $commandArguments;    foreach {parmName encodedValue} $parmList parmType $parmTypes {       set comment {           Decode the parameter value which we now know is very encoded to guard           it from the parser and append them each to a new list which will be passed           as the arguments to the exec function.  Note that the           parameter names need to be turned into macro settings by           prepending them with --           Note also that the WorkspaceRunner sometimes encodes attribute           dereferences by placing <amp> at the beginning rather than using @Value.           Further note that string range forgives if the ending index is > the length of           the string, so we can just ask for the first 5 characters           when we're checking for <amp>.       };       if {[string length $parmName] == 0} { continue; };       lappend commandArguments \"--$parmName\";       lappend commandArgumentsToLog \"--$parmName\";       set comment {           for backwards compatibility, replace first <amp>       };       if { [string range $encodedValue 0 4] == {<amp>} &&            [string length $encodedValue] > 5 } {           set encodedValue [string replace $encodedValue 0 4 {<at>Value<openparen>}]];           append encodedValue "<closeparen>";       };       set comment { We used to call FME_DecodeTextOrAttr here. After changes to                     the code that writes out the mapping file section, we don't                     need to do this any more because the value would be in the                     correct state of encoding as required by the child workspace       };       set comment { parameter values starting with '<' causes tcl exec to fail so                     we escape leading '<' with backslash and then do the reverse                     when parsing command line arguments       };       if { [string index $encodedValue 0] == {<} } {          set encodedValue "\\$encodedValue";       };       lappend commandArguments $encodedValue;       set comment {           Ensure that passwords are not added into the logmessage (PR 64546)           We'll guard against both PASSWORD and PASSWORD_CONFIRM GUI types           by checking if the word PASSWORD is in the GUI TYPE at all       };       if { [string first {PASSWORD} $parmType] != -1 } {           lappend commandArgumentsToLog {***};       } else {           lappend commandArgumentsToLog $encodedValue;       };    };    set comment {        Now optionally run this in a detached way if we were not supposed        to wait by adding & on the end to put it in the background.  And        at the same time, ensure that any stray stdout/stderr is routed to        null.    };    if { {Yes} == {No} } {        lappend commandArguments \">$::null_device\";        lappend commandArgumentsToLog \">$::null_device\";        lappend commandArguments \"<$::null_device\";        lappend commandArgumentsToLog \"<$::null_device\";        FME_LogMessage fme_inform \"RestrictionForVehicles: Initiating run of FME Workspace $workspaceFile with command line:\";    } else {        FME_LogMessage fme_inform \"RestrictionForVehicles: Running FME Workspace $workspaceFile with command line:\";    };    set comment {        The below 2>@1 forces any standard error output to go into the msg variable        or to NULL if we're running in the background.    };    lappend commandArguments {2>@1};    lappend commandArgumentsToLog {2>@1};    if { {Yes} == {No} } {        lappend commandArguments {&};        lappend commandArgumentsToLog {&};    };    FME_LogMessage fme_inform [concat RestrictionForVehicles: $commandArgumentsToLog];    if { {Yes} == {No} } {       after 1000;       while { [FME_CanSpawnFme <Unused>] == {0} } {             after 2000;       };    };    if {[catch {eval [concat exec $commandArguments] } msg ]} {       set msg [regsub {\015*\012child[^\012]*$} $msg {}];       FME_LogMessage fme_warn \"RestrictionForVehicles: Failed to run workspace $workspaceFileUnix -- Trace was:\n\n$msg\n\";       FME_SetAttribute _failure_message $msg;       return FAILURE;    } else {       global RestrictionForVehicles_1db42255_d050_4328_b32e_c379bac01fec0_process_count;       incr RestrictionForVehicles_1db42255_d050_4328_b32e_c379bac01fec0_process_count;       if { {Yes} == {No} } {           FME_LogMessage fme_inform \"RestrictionForVehicles: Successfully initiated run of workspace $workspaceFile\";           global RestrictionForVehicles_1db42255_d050_4328_b32e_c379bac01fec0_all_processes;           lappend RestrictionForVehicles_1db42255_d050_4328_b32e_c379bac01fec0_all_processes $msg;       } else {           FME_LogMessage fme_inform \"RestrictionForVehicles: Successfully ran workspace $workspaceFile\";       };       return SUCCESS;    }; }
FACTORY_DEF * TestFactory    FACTORY_NAME RestrictionForVehicles_ExecutorAndRouter    INPUT  FEATURE_TYPE TurnRestriction_SUCCEEDED    INPUT  FEATURE_TYPE TurnRestriction_FAILED    TEST @Tcl2("RestrictionForVehicles_1db42255_d050_4328_b32e_c379bac01fec0_runner {(SourceDataset_RoadLink,@EvaluateExpression(FDIV,STRING,$(ROADS_INPUT$encode)<backslash>Highways_Rrami_RoadLink_*.gml.gz,RestrictionForVehicles),SourceDataset_GML,@EvaluateExpression(FDIV,STRING,$(ROADS_INPUT$encode)<backslash>Highways_Rrami_RestrictionForVehicles_*.gml.gz,RestrictionForVehicles),DestDataset_GEOPACKAGE,@EvaluateExpression(FDIV,STRING,$(DEST_FOLDER$encode)<backslash>RestrictionForVehicles.gpkg,RestrictionForVehicles))} {RestrictionForVehicles.fmw}") == SUCCESS
Tcl2 proc RestrictionForVehicles_1db42255_d050_4328_b32e_c379bac01fec0_summarizer { } {     global RestrictionForVehicles_1db42255_d050_4328_b32e_c379bac01fec0_process_count;     set comment { incr 0 creates the variable if it wasn't present };     incr RestrictionForVehicles_1db42255_d050_4328_b32e_c379bac01fec0_process_count 0;     FME_SetAttribute _proc_count [set RestrictionForVehicles_1db42255_d050_4328_b32e_c379bac01fec0_process_count];     global RestrictionForVehicles_1db42255_d050_4328_b32e_c379bac01fec0_all_processes;     if {[info exists RestrictionForVehicles_1db42255_d050_4328_b32e_c379bac01fec0_all_processes]} {         set index 0;         foreach pid [set RestrictionForVehicles_1db42255_d050_4328_b32e_c379bac01fec0_all_processes] {             FME_SetAttribute \"_processes{$index}\" $pid;             incr index;         }     } }
FACTORY_DEF * CreationFactory    FACTORY_NAME RestrictionForVehicles_SummaryMaker    CREATE_AT_END yes
# -------------------------------------------------------------------------

FACTORY_DEF * RoutingFactory FACTORY_NAME "Destination Feature Type Routing Correlator"   COMMAND_PARM_EVALUATION SINGLE_PASS   INPUT FEATURE_TYPE *   FEATURE_TYPE_ATTRIBUTE __wb_out_feat_type__   OUTPUT ROUTED FEATURE_TYPE *    OUTPUT NOT_ROUTED FEATURE_TYPE __nuke_me__ @Tcl2("FME_StatMessage 818059 [FME_GetAttribute fme_template_feature_type] 818060 818061 fme_warn")
# -------------------------------------------------------------------------

FACTORY_DEF * TeeFactory   FACTORY_NAME "Final Output Nuker"   INPUT FEATURE_TYPE __nuke_me__

